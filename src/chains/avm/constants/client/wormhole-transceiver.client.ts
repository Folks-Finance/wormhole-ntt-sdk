/* eslint-disable */
// @ts-nocheck
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from "@algorandfoundation/algokit-utils/types/algorand-client";
import { ABIReturn, AppReturn, SendAppTransactionResult } from "@algorandfoundation/algokit-utils/types/app";
import {
  Arc56Contract,
  getArc56ReturnValue,
  getABIStructFromABITuple,
} from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from "@algorandfoundation/algokit-utils/types/app-client";
import {
  AppFactory as _AppFactory,
  AppFactoryAppClientParams,
  AppFactoryResolveAppClientByCreatorAndNameParams,
  AppFactoryDeployParams,
  AppFactoryParams,
  CreateSchema,
} from "@algorandfoundation/algokit-utils/types/app-factory";
import {
  TransactionComposer,
  AppCallMethodCall,
  AppMethodCallTransactionArgument,
  SimulateOptions,
  RawSimulateOptions,
  SkipSignaturesSimulateOptions,
} from "@algorandfoundation/algokit-utils/types/composer";
import {
  SendParams,
  SendSingleTransactionResult,
  SendAtomicTransactionComposerResults,
} from "@algorandfoundation/algokit-utils/types/transaction";
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from "algosdk";

export const APP_SPEC: Arc56Contract = {
  name: "WormholeTransceiver",
  structs: {
    AddressRoleKey: [
      { name: "role", type: "byte[16]" },
      { name: "address", type: "address" },
    ],
    MinimumUpgradeDelay: [
      { name: "delay_0", type: "uint64" },
      { name: "delay_1", type: "uint64" },
      { name: "timestamp", type: "uint64" },
    ],
    ScheduledContractUpgrade: [
      { name: "programSha256", type: "byte[32]" },
      { name: "timestamp", type: "uint64" },
    ],
    MessageToSend: [
      { name: "id", type: "byte[32]" },
      { name: "userAddress", type: "byte[32]" },
      { name: "sourceAddress", type: "byte[32]" },
      { name: "destinationChainId", type: "uint16" },
      { name: "handlerAddress", type: "byte[32]" },
      { name: "payload", type: "byte[]" },
    ],
  },
  methods: [
    {
      name: "create",
      args: [
        { type: "uint64", name: "transceiver_manager" },
        { type: "uint64", name: "wormhole_core" },
        { type: "uint16", name: "chain_id" },
        { type: "uint64", name: "min_upgrade_delay" },
      ],
      returns: { type: "void" },
      actions: { create: ["NoOp"], call: [] },
      readonly: false,
      events: [],
      recommendations: {},
    },
    {
      name: "initialise",
      args: [{ type: "address", name: "admin" }],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "RoleGranted",
          args: [
            { type: "byte[16]", name: "role" },
            { type: "address", name: "account" },
            { type: "address", name: "sender" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "get_transceiver_type",
      args: [],
      returns: { type: "string" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      events: [],
      recommendations: {},
    },
    {
      name: "set_wormhole_peer",
      args: [
        {
          type: "uint16",
          name: "peer_chain_id",
          desc: "The peer chain to set",
        },
        {
          type: "byte[32]",
          name: "peer_contract_address",
          desc: "The peer contract address",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Set the WormholeTransceiver on a peer chain, overriding if needed.",
      events: [
        {
          name: "WormholePeerSet",
          args: [
            { type: "uint16", name: "peer_chain_id" },
            { type: "byte[32]", name: "peer_contract_address" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "receive_message",
      args: [
        {
          type: "appl",
          name: "verify_vaa",
          desc: "The call to Wormhole call to verify the VAA",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Receive a Wormhole message directly with manual delivery.",
      events: [
        {
          name: "ReceivedMessage",
          args: [
            { type: "byte[32]", name: "vaa_digest" },
            { type: "byte[32]", name: "message_id" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "manager_role",
      args: [],
      returns: { type: "byte[16]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      events: [],
      recommendations: {},
    },
    {
      name: "get_wormhole_peer",
      args: [
        {
          type: "uint16",
          name: "peer_chain_id",
          desc: "The peer chain to get the address of",
        },
      ],
      returns: { type: "byte[32]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Get the address of the peer WormholeTransceiver set on a given chain.",
      events: [],
      recommendations: {},
    },
    {
      name: "quote_delivery_price",
      args: [
        {
          type: "(byte[32],byte[32],byte[32],uint16,byte[32],byte[])",
          struct: "MessageToSend",
          name: "message",
        },
        { type: "byte[]", name: "transceiver_instruction" },
      ],
      returns: { type: "uint64" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      events: [],
      recommendations: {},
    },
    {
      name: "send_message",
      args: [
        { type: "pay", name: "fee_payment" },
        {
          type: "(byte[32],byte[32],byte[32],uint16,byte[32],byte[])",
          struct: "MessageToSend",
          name: "message",
        },
        { type: "byte[]", name: "transceiver_instruction" },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "MessageSent",
          args: [{ type: "byte[32]", name: "message_id" }],
        },
      ],
      recommendations: {},
    },
    {
      name: "update_min_upgrade_delay",
      args: [
        { type: "uint64", name: "min_upgrade_delay", desc: "The new delay" },
        {
          type: "uint64",
          name: "timestamp",
          desc: "The timestamp to schedule the change",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Schedule a change in the minimum delay needed for an upgrade.\nAutomatically comes into effect at given timestamp.",
      events: [
        {
          name: "MinimumUpgradeDelayChange",
          args: [
            { type: "uint64", name: "delay" },
            { type: "uint64", name: "timestamp" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "schedule_contract_upgrade",
      args: [
        {
          type: "byte[32]",
          name: "program_sha256",
          desc: "The SHA256 of the new program",
        },
        {
          type: "uint64",
          name: "timestamp",
          desc: "The timestamp to schedule the upgrade",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Schedule the upgrade of the contract.\nThe upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.",
      events: [
        {
          name: "UpgradeScheduled",
          args: [
            { type: "byte[32]", name: "program_sha256" },
            { type: "uint64", name: "timestamp" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "cancel_contract_upgrade",
      args: [],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Cancel the scheduled upgrade",
      events: [
        {
          name: "UpgradeCancelled",
          args: [
            { type: "byte[32]", name: "program_sha256" },
            { type: "uint64", name: "timestamp" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "complete_contract_upgrade",
      args: [],
      returns: { type: "void" },
      actions: { create: [], call: ["UpdateApplication"] },
      readonly: false,
      desc: "Complete the scheduled upgrade",
      events: [
        {
          name: "UpgradeCompleted",
          args: [
            { type: "byte[32]", name: "program_sha256" },
            { type: "uint64", name: "version" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "upgradable_admin_role",
      args: [],
      returns: { type: "byte[16]", desc: "Role bytes of length 16" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the role identifier for the upgradeable admin role",
      events: [],
      recommendations: {},
    },
    {
      name: "max_for_min_upgrade_delay",
      args: [],
      returns: { type: "uint64", desc: "The maximum minimum upgrade delay" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the maximum delay allowed for the minimum upgrade delay\nThis is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.",
      events: [],
      recommendations: {},
    },
    {
      name: "get_active_min_upgrade_delay",
      args: [],
      returns: { type: "uint64", desc: "The active minimum upgrade delay" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Clarifies the active minimum upgrade delay in cases where there was a scheduled update.",
      events: [],
      recommendations: {},
    },
    {
      name: "grant_role",
      args: [
        { type: "byte[16]", name: "role", desc: "The role to grant" },
        {
          type: "address",
          name: "account",
          desc: "The account to grant the role to",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Grant a role to an account\nIncreases the MBR for the contract's ledger balance.",
      events: [
        {
          name: "RoleGranted",
          args: [
            { type: "byte[16]", name: "role" },
            { type: "address", name: "account" },
            { type: "address", name: "sender" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "revoke_role",
      args: [
        { type: "byte[16]", name: "role", desc: "The role to revoke" },
        {
          type: "address",
          name: "account",
          desc: "The account to revoke the role from",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Revokes a role from an account\nReduces the MBR for the contract's ledger balance.",
      events: [
        {
          name: "RoleRevoked",
          args: [
            { type: "byte[16]", name: "role" },
            { type: "address", name: "account" },
            { type: "address", name: "sender" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "renounce_role",
      args: [{ type: "byte[16]", name: "role", desc: "The role to renounce" }],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Revokes a role from the caller\nReduces the MBR for the contract's ledger balance.",
      events: [
        {
          name: "RoleRevoked",
          args: [
            { type: "byte[16]", name: "role" },
            { type: "address", name: "account" },
            { type: "address", name: "sender" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "default_admin_role",
      args: [],
      returns: { type: "byte[16]", desc: "Empty bytes of length 16" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the role identifier for the default admin role",
      events: [],
      recommendations: {},
    },
    {
      name: "has_role",
      args: [
        { type: "byte[16]", name: "role", desc: "The role to check" },
        { type: "address", name: "account", desc: "The account to check" },
      ],
      returns: {
        type: "bool",
        desc: "Whether the account has been granted a role",
      },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns whether the account has been granted a role",
      events: [],
      recommendations: {},
    },
    {
      name: "get_role_admin",
      args: [
        {
          type: "byte[16]",
          name: "role",
          desc: "The role to get its admin of",
        },
      ],
      returns: { type: "byte[16]", desc: "The role admin" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the admin role that controls a role",
      events: [],
      recommendations: {},
    },
  ],
  arcs: [22, 28],
  desc: "Transceiver implementation for Wormhole.\n\n    This contract is responsible for sending and receiving NTT messages that are authenticated through Wormhole Core.\n\n    The messages can be delivered either manually or via a (custom) relayer. There is built in replay protection which\n    prevents the same message from being delivered multiple times.\n    ",
  networks: {},
  state: {
    schema: { global: { ints: 4, bytes: 4 }, local: { ints: 0, bytes: 0 } },
    keys: {
      global: {
        is_initialised: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "aXNfaW5pdGlhbGlzZWQ=",
        },
        min_upgrade_delay: {
          keyType: "AVMString",
          valueType: "MinimumUpgradeDelay",
          key: "bWluX3VwZ3JhZGVfZGVsYXk=",
        },
        scheduled_contract_upgrade: {
          keyType: "AVMString",
          valueType: "ScheduledContractUpgrade",
          key: "c2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGU=",
        },
        version: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "dmVyc2lvbg==",
        },
        transceiver_manager: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "dHJhbnNjZWl2ZXJfbWFuYWdlcg==",
        },
        wormhole_core: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "d29ybWhvbGVfY29yZQ==",
        },
        chain_id: {
          keyType: "AVMString",
          valueType: "uint16",
          key: "Y2hhaW5faWQ=",
        },
        emitter_lsig: {
          keyType: "AVMString",
          valueType: "address",
          key: "ZW1pdHRlcl9sc2ln",
        },
      },
      local: {},
      box: {},
    },
    maps: {
      global: {},
      local: {},
      box: {
        roles: {
          keyType: "byte[16]",
          valueType: "byte[16]",
          prefix: "cm9sZV8=",
        },
        addresses_roles: {
          keyType: "AddressRoleKey",
          valueType: "bool",
          prefix: "YWRkcmVzc19yb2xlc18=",
        },
        wormhole_peers: {
          keyType: "uint16",
          valueType: "byte[32]",
          prefix: "d29ybWhvbGVfcGVlcl8=",
        },
        vaas_consumed: {
          keyType: "byte[32]",
          valueType: "bool",
          prefix: "dmFhc19jb25zdW1lZF8=",
        },
      },
    },
  },
  bareActions: { create: [], call: [] },
  sourceInfo: {
    approval: {
      sourceInfo: [
        { pc: [2185], errorMessage: "Access control unauthorised account" },
        { pc: [1015], errorMessage: "Address length is 32 bytes" },
        { pc: [918], errorMessage: "Caller must be TransceiverManager" },
        { pc: [1587], errorMessage: "Caller must be the contract creator" },
        { pc: [1534], errorMessage: "Cannot set itself as peer chain" },
        { pc: [1593], errorMessage: "Contract already initialised" },
        { pc: [761, 1682], errorMessage: "Delay exceeds maximum allowed" },
        { pc: [1214], errorMessage: "Incorrect app call id" },
        { pc: [1236], errorMessage: "Incorrect app call method" },
        { pc: [1219], errorMessage: "Incorrect app call on completion" },
        { pc: [948], errorMessage: "Incorrect fee payment amount" },
        { pc: [1431], errorMessage: "Incorrect length" },
        { pc: [1315], errorMessage: "Incorrect prefix" },
        { pc: [1945], errorMessage: "Invalid program SHA256" },
        {
          pc: [2090],
          errorMessage: "Must schedule at least min upgrade delay time in future",
        },
        { pc: [272], errorMessage: "OnCompletion must be NoOp" },
        {
          pc: [1811],
          errorMessage: "OnCompletion must be UpdateApplication && can only call when not creating",
        },
        { pc: [1841], errorMessage: "Schedule complete ts not met" },
        { pc: [914], errorMessage: "TransceiverManager address unknown" },
        {
          pc: [637, 693, 750, 953, 1205, 1519, 1816],
          errorMessage: "Uninitialised contract",
        },
        { pc: [926], errorMessage: "Unknown fee payment receiver" },
        { pc: [1346], errorMessage: "Unknown peer address" },
        { pc: [1993], errorMessage: "Unknown peer chain" },
        { pc: [648, 1833], errorMessage: "Upgrade not scheduled" },
        { pc: [1392], errorMessage: "VAA already seen" },
        { pc: [944, 1137], errorMessage: "Wormhole message fee is unknown" },
        { pc: [1003, 1713], errorMessage: "WormholeCore address unknown" },
        { pc: [2131], errorMessage: "check self.addresses_roles entry exists" },
        { pc: [1530], errorMessage: "check self.chain_id exists" },
        { pc: [1010], errorMessage: "check self.emitter_lsig exists" },
        {
          pc: [636, 692, 749, 952, 1204, 1518, 1591, 1815],
          errorMessage: "check self.is_initialised exists",
        },
        {
          pc: [768, 782, 795, 2056],
          errorMessage: "check self.min_upgrade_delay exists",
        },
        { pc: [2165], errorMessage: "check self.roles entry exists" },
        {
          pc: [911, 1458],
          errorMessage: "check self.transceiver_manager exists",
        },
        { pc: [1384], errorMessage: "check self.vaas_consumed entry exists" },
        { pc: [1953, 1967], errorMessage: "check self.version exists" },
        {
          pc: [940, 999, 1133, 1212, 1709],
          errorMessage: "check self.wormhole_core exists",
        },
        {
          pc: [860, 899, 1103, 1118],
          errorMessage: "invalid array length header",
        },
        {
          pc: [906, 1125],
          errorMessage: "invalid number of bytes for arc4.dynamic_array<arc4.uint8>",
        },
        {
          pc: [433, 452, 504, 521, 554],
          errorMessage: "invalid number of bytes for arc4.static_array<arc4.uint8, 16>",
        },
        {
          pc: [460, 529, 562, 677, 1514, 1581],
          errorMessage: "invalid number of bytes for arc4.static_array<arc4.uint8, 32>",
        },
        {
          pc: [1154, 1506, 1667],
          errorMessage: "invalid number of bytes for arc4.uint16",
        },
        {
          pc: [686, 731, 744, 1647, 1657, 1676],
          errorMessage: "invalid number of bytes for arc4.uint64",
        },
        {
          pc: [868, 1109],
          errorMessage: "invalid number of bytes for ntt_contracts.types.MessageToSend",
        },
        {
          pc: [851, 1095],
          errorMessage:
            "invalid tail pointer at index 5 of (uint8[32],uint8[32],uint8[32],uint16,uint8[32],(len+uint8[]))",
        },
        { pc: [845, 1089], errorMessage: "invalid tuple encoding" },
        { pc: [984, 1281], errorMessage: "overflow" },
        { pc: [1200], errorMessage: "transaction type is appl" },
        { pc: [834], errorMessage: "transaction type is pay" },
      ],
      pcOffsetMethod: "none",
    },
    clear: { sourceInfo: [], pcOffsetMethod: "none" },
  },
  source: {
    approval:
      "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMTYgMzIgMTIwOTYwMAogICAgYnl0ZWNibG9jayAiaXNfaW5pdGlhbGlzZWQiIDB4MDAgIm1pbl91cGdyYWRlX2RlbGF5IiAid29ybWhvbGVfY29yZSIgMHgxNTFmN2M3NSAweGNmOGNkMzI3YjhhMmU4ZTA1MTJhMzk2ZGJhOWYwMDdiICJzY2hlZHVsZWRfY29udHJhY3RfdXBncmFkZSIgInZlcnNpb24iIDB4ODAgInRyYW5zY2VpdmVyX21hbmFnZXIiIDB4NjE2NDY0NzI2NTczNzM1ZjcyNmY2YzY1NzM1ZiAweDRkNjU3MzczNjE2NzY1NDY2NTY1IDB4OTk0NWZmMTAgImVtaXR0ZXJfbHNpZyIgMHhhZjI5MGQ4NjgwODIwYWFkOTIyODU1ZjM5YjMwNjA5NyAiY2hhaW5faWQiIDB4Nzc2ZjcyNmQ2ODZmNmM2NTVmNzA2NTY1NzI1ZiAweDAwMDAwMDAwMDAwMDAwMDAKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDkKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAyCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo0NAogICAgLy8gc2VsZi5pc19pbml0aWFsaXNlZCA9IEZhbHNlCiAgICBieXRlY18wIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjcwCiAgICAvLyBzZWxmLnZlcnNpb24gPSBVSW50NjQoMSkKICAgIGJ5dGVjIDcgLy8gInZlcnNpb24iCiAgICBpbnRjXzEgLy8gMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9Jbml0aWFsaXNhYmxlLnB5OjQ0CiAgICAvLyBzZWxmLmlzX2luaXRpYWxpc2VkID0gRmFsc2UKICAgIGJ5dGVjXzAgLy8gImlzX2luaXRpYWxpc2VkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CgptYWluX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNQogICAgLy8gY2xhc3MgV29ybWhvbGVUcmFuc2NlaXZlcihUcmFuc2NlaXZlciwgSW5pdGlhbGlzYWJsZVdpdGhDcmVhdG9yKToKICAgIHB1c2hieXRlcyAweDhmYTM4ODhiIC8vIG1ldGhvZCAiY29tcGxldGVfY29udHJhY3RfdXBncmFkZSgpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fY29tcGxldGVfY29udHJhY3RfdXBncmFkZV9yb3V0ZUA0CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJ6IG1haW5fY3JlYXRlX05vT3BAMjgKICAgIHB1c2hieXRlc3MgMHgzZDUyNjNiMyAweDVlNzNiMGIyIDB4ZDZlMTE2N2YgMHg2ZmQ2Yzg3NCAweGIxOTQwODA3IDB4NzNkMDc5MWQgMHgxNDJlZTA2NSAweGY2MWQzZTY0IDB4ZTAzNGU5NmIgMHg1NjMzMTk1ZSAweDEwOGI2ODk3IDB4ZmZiODkxNDggMHhkOTdjZTMxMCAweDdkZWRiY2QyIDB4ZDczYmEyNDQgMHg3MmJhMzBlZSAweDBlOTRkYmZjIDB4NjdiZDUyMzcgMHhmZDYxYThiZSAweDU1NTc3N2Y2IC8vIG1ldGhvZCAiaW5pdGlhbGlzZShhZGRyZXNzKXZvaWQiLCBtZXRob2QgImdldF90cmFuc2NlaXZlcl90eXBlKClzdHJpbmciLCBtZXRob2QgInNldF93b3JtaG9sZV9wZWVyKHVpbnQxNixieXRlWzMyXSl2b2lkIiwgbWV0aG9kICJyZWNlaXZlX21lc3NhZ2UoYXBwbCl2b2lkIiwgbWV0aG9kICJtYW5hZ2VyX3JvbGUoKWJ5dGVbMTZdIiwgbWV0aG9kICJnZXRfd29ybWhvbGVfcGVlcih1aW50MTYpYnl0ZVszMl0iLCBtZXRob2QgInF1b3RlX2RlbGl2ZXJ5X3ByaWNlKChieXRlWzMyXSxieXRlWzMyXSxieXRlWzMyXSx1aW50MTYsYnl0ZVszMl0sYnl0ZVtdKSxieXRlW10pdWludDY0IiwgbWV0aG9kICJzZW5kX21lc3NhZ2UocGF5LChieXRlWzMyXSxieXRlWzMyXSxieXRlWzMyXSx1aW50MTYsYnl0ZVszMl0sYnl0ZVtdKSxieXRlW10pdm9pZCIsIG1ldGhvZCAidXBkYXRlX21pbl91cGdyYWRlX2RlbGF5KHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAic2NoZWR1bGVfY29udHJhY3RfdXBncmFkZShieXRlWzMyXSx1aW50NjQpdm9pZCIsIG1ldGhvZCAiY2FuY2VsX2NvbnRyYWN0X3VwZ3JhZGUoKXZvaWQiLCBtZXRob2QgInVwZ3JhZGFibGVfYWRtaW5fcm9sZSgpYnl0ZVsxNl0iLCBtZXRob2QgIm1heF9mb3JfbWluX3VwZ3JhZGVfZGVsYXkoKXVpbnQ2NCIsIG1ldGhvZCAiZ2V0X2FjdGl2ZV9taW5fdXBncmFkZV9kZWxheSgpdWludDY0IiwgbWV0aG9kICJncmFudF9yb2xlKGJ5dGVbMTZdLGFkZHJlc3Mpdm9pZCIsIG1ldGhvZCAicmV2b2tlX3JvbGUoYnl0ZVsxNl0sYWRkcmVzcyl2b2lkIiwgbWV0aG9kICJyZW5vdW5jZV9yb2xlKGJ5dGVbMTZdKXZvaWQiLCBtZXRob2QgImRlZmF1bHRfYWRtaW5fcm9sZSgpYnl0ZVsxNl0iLCBtZXRob2QgImhhc19yb2xlKGJ5dGVbMTZdLGFkZHJlc3MpYm9vbCIsIG1ldGhvZCAiZ2V0X3JvbGVfYWRtaW4oYnl0ZVsxNl0pYnl0ZVsxNl0iCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2luaXRpYWxpc2Vfcm91dGVANyBtYWluX2dldF90cmFuc2NlaXZlcl90eXBlX3JvdXRlQDggbWFpbl9zZXRfd29ybWhvbGVfcGVlcl9yb3V0ZUA5IG1haW5fcmVjZWl2ZV9tZXNzYWdlX3JvdXRlQDEwIG1haW5fbWFuYWdlcl9yb2xlX3JvdXRlQDExIG1haW5fZ2V0X3dvcm1ob2xlX3BlZXJfcm91dGVAMTIgbWFpbl9xdW90ZV9kZWxpdmVyeV9wcmljZV9yb3V0ZUAxMyBtYWluX3NlbmRfbWVzc2FnZV9yb3V0ZUAxNCBtYWluX3VwZGF0ZV9taW5fdXBncmFkZV9kZWxheV9yb3V0ZUAxNSBtYWluX3NjaGVkdWxlX2NvbnRyYWN0X3VwZ3JhZGVfcm91dGVAMTYgbWFpbl9jYW5jZWxfY29udHJhY3RfdXBncmFkZV9yb3V0ZUAxNyBtYWluX3VwZ3JhZGFibGVfYWRtaW5fcm9sZV9yb3V0ZUAxOCBtYWluX21heF9mb3JfbWluX3VwZ3JhZGVfZGVsYXlfcm91dGVAMTkgbWFpbl9nZXRfYWN0aXZlX21pbl91cGdyYWRlX2RlbGF5X3JvdXRlQDIwIG1haW5fZ3JhbnRfcm9sZV9yb3V0ZUAyMSBtYWluX3Jldm9rZV9yb2xlX3JvdXRlQDIyIG1haW5fcmVub3VuY2Vfcm9sZV9yb3V0ZUAyMyBtYWluX2RlZmF1bHRfYWRtaW5fcm9sZV9yb3V0ZUAyNCBtYWluX2hhc19yb2xlX3JvdXRlQDI1IG1haW5fZ2V0X3JvbGVfYWRtaW5fcm91dGVAMjYKICAgIGVycgoKbWFpbl9nZXRfcm9sZV9hZG1pbl9yb3V0ZUAyNjoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjEyNQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxNgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMTY+CiAgICBjYWxsc3ViIGdldF9yb2xlX2FkbWluCiAgICBwb3AKICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faGFzX3JvbGVfcm91dGVAMjU6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxMTEKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMTYKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDE2PgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICBjYWxsc3ViIGhhc19yb2xlCiAgICBwb3AKICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVmYXVsdF9hZG1pbl9yb2xlX3JvdXRlQDI0OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTAyCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcmVub3VuY2Vfcm9sZV9yb3V0ZUAyMzoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjkxCiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDE2CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAxNj4KICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjEwMAogICAgLy8gc2VsZi5fcmV2b2tlX3JvbGUocm9sZSwgQWRkcmVzcyhUeG4uc2VuZGVyKSkKICAgIHR4biBTZW5kZXIKICAgIGNhbGxzdWIgX3Jldm9rZV9yb2xlCiAgICBwb3BuIDIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjkxCiAgICAvLyBAYWJpbWV0aG9kCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3Jldm9rZV9yb2xlX3JvdXRlQDIyOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6NzUKICAgIC8vIEBhYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMTYKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDE2PgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weTo4OAogICAgLy8gc2VsZi5fY2hlY2tfc2VuZGVyX3JvbGUoc2VsZi5nZXRfcm9sZV9hZG1pbihyb2xlKSkKICAgIHN3YXAKICAgIGNhbGxzdWIgZ2V0X3JvbGVfYWRtaW4KICAgIHN3YXAKICAgIGNhbGxzdWIgX2NoZWNrX3NlbmRlcl9yb2xlCiAgICBwb3AKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5Ojg5CiAgICAvLyBzZWxmLl9yZXZva2Vfcm9sZShyb2xlLCBhY2NvdW50KQogICAgc3dhcAogICAgY2FsbHN1YiBfcmV2b2tlX3JvbGUKICAgIHBvcG4gMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6NzUKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ3JhbnRfcm9sZV9yb3V0ZUAyMToKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjU5CiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDE2CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAxNj4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6NzIKICAgIC8vIHNlbGYuX2NoZWNrX3NlbmRlcl9yb2xlKHNlbGYuZ2V0X3JvbGVfYWRtaW4ocm9sZSkpCiAgICBzd2FwCiAgICBjYWxsc3ViIGdldF9yb2xlX2FkbWluCiAgICBzd2FwCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weTo3MwogICAgLy8gc2VsZi5fZ3JhbnRfcm9sZShyb2xlLCBhY2NvdW50KQogICAgc3dhcAogICAgY2FsbHN1YiBfZ3JhbnRfcm9sZQogICAgcG9wbiAyCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weTo1OQogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRfYWN0aXZlX21pbl91cGdyYWRlX2RlbGF5X3JvdXRlQDIwOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIxMwogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBnZXRfYWN0aXZlX21pbl91cGdyYWRlX2RlbGF5CiAgICBpdG9iCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX21heF9mb3JfbWluX3VwZ3JhZGVfZGVsYXlfcm91dGVAMTk6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjAxCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NTAwMDAwMDAwMDAxMjc1MDAKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl91cGdyYWRhYmxlX2FkbWluX3JvbGVfcm91dGVAMTg6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTkyCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NWNmOGNkMzI3YjhhMmU4ZTA1MTJhMzk2ZGJhOWYwMDdiCiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY2FuY2VsX2NvbnRyYWN0X3VwZ3JhZGVfcm91dGVAMTc6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxOTkKICAgIC8vIHJldHVybiBCeXRlczE2LmZyb21fYnl0ZXMob3AuZXh0cmFjdChvcC5rZWNjYWsyNTYoYiJVUEdSQURFQUJMRV9BRE1JTiIpLCAwLCBjb25zdC5CWVRFUzE2X0xFTkdUSCkpCiAgICBieXRlYyA1IC8vIDB4Y2Y4Y2QzMjdiOGEyZThlMDUxMmEzOTZkYmE5ZjAwN2IKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxNDgKICAgIC8vIHNlbGYuX2NoZWNrX3NlbmRlcl9yb2xlKHNlbGYudXBncmFkYWJsZV9hZG1pbl9yb2xlKCkpCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjM4CiAgICAvLyBleGlzdHMgPSBzZWxmLnNjaGVkdWxlZF9jb250cmFjdF91cGdyYWRlLm1heWJlKClbMV0KICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJzY2hlZHVsZWRfY29udHJhY3RfdXBncmFkZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjM5CiAgICAvLyBhc3NlcnQgZXhpc3RzLCAiVXBncmFkZSBub3Qgc2NoZWR1bGVkIgogICAgYXNzZXJ0IC8vIFVwZ3JhZGUgbm90IHNjaGVkdWxlZAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE1MgogICAgLy8gcHJvZ3JhbV9zaGEyNTYgPSBzZWxmLnNjaGVkdWxlZF9jb250cmFjdF91cGdyYWRlLnZhbHVlLnByb2dyYW1fc2hhMjU2LmNvcHkoKQogICAgZXh0cmFjdCAwIDMyCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTUzCiAgICAvLyBkZWwgc2VsZi5zY2hlZHVsZWRfY29udHJhY3RfdXBncmFkZS52YWx1ZQogICAgYnl0ZWMgNiAvLyAic2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUiCiAgICBhcHBfZ2xvYmFsX2RlbAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE1NQogICAgLy8gZW1pdChVcGdyYWRlQ2FuY2VsbGVkKHByb2dyYW1fc2hhMjU2LCBBUkM0VUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSkpCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDAwYTZjOGYxIC8vIG1ldGhvZCAiVXBncmFkZUNhbmNlbGxlZChieXRlWzMyXSx1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMzgKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc2NoZWR1bGVfY29udHJhY3RfdXBncmFkZV9yb3V0ZUAxNjoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMTEKICAgIC8vIEBhYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgOCAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgZHVwCiAgICBidG9pCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxOTkKICAgIC8vIHJldHVybiBCeXRlczE2LmZyb21fYnl0ZXMob3AuZXh0cmFjdChvcC5rZWNjYWsyNTYoYiJVUEdSQURFQUJMRV9BRE1JTiIpLCAwLCBjb25zdC5CWVRFUzE2X0xFTkdUSCkpCiAgICBieXRlYyA1IC8vIDB4Y2Y4Y2QzMjdiOGEyZThlMDUxMmEzOTZkYmE5ZjAwN2IKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMjgKICAgIC8vIHNlbGYuX2NoZWNrX3NlbmRlcl9yb2xlKHNlbGYudXBncmFkYWJsZV9hZG1pbl9yb2xlKCkpCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTMwLTEzMQogICAgLy8gIyBlbnN1cmUgdGltZXN0YW1wIGlzIHN1ZmZpY2llbnRseSBpbiB0aGUgZnV0dXJlCiAgICAvLyBzZWxmLl9jaGVja19zY2hlZHVsZV90aW1lc3RhbXAodGltZXN0YW1wKQogICAgY2FsbHN1YiBfY2hlY2tfc2NoZWR1bGVfdGltZXN0YW1wCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTMzLTEzNAogICAgLy8gIyBzY2hlZHVsZSBjb250cmFjdCB1cGdyYWRlLCBwb3NzaWJseSBvdmVycmlkaW5nIGV4aXN0aW5nIHNjaGVkdWxlZCB1cGdyYWRlCiAgICAvLyBzZWxmLnNjaGVkdWxlZF9jb250cmFjdF91cGdyYWRlLnZhbHVlID0gU2NoZWR1bGVkQ29udHJhY3RVcGdyYWRlKHByb2dyYW1fc2hhMjU2LmNvcHkoKSwgQVJDNFVJbnQ2NCh0aW1lc3RhbXApKQogICAgY29uY2F0CiAgICBieXRlYyA2IC8vICJzY2hlZHVsZWRfY29udHJhY3RfdXBncmFkZSIKICAgIGRpZyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjEzNgogICAgLy8gZW1pdChVcGdyYWRlU2NoZWR1bGVkKHByb2dyYW1fc2hhMjU2LCBBUkM0VUludDY0KHRpbWVzdGFtcCkpKQogICAgcHVzaGJ5dGVzIDB4OTA4YmM1NTEgLy8gbWV0aG9kICJVcGdyYWRlU2NoZWR1bGVkKGJ5dGVbMzJdLHVpbnQ2NCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjExMQogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl91cGRhdGVfbWluX3VwZ3JhZGVfZGVsYXlfcm91dGVAMTU6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6NzgKICAgIC8vIEBhYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgYnVyeSA3CiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA4IC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGJ1cnkgNwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgOCAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0luaXRpYWxpc2FibGUucHk6NjMKICAgIC8vIGFzc2VydCBzZWxmLmlzX2luaXRpYWxpc2VkLCAiVW5pbml0aWFsaXNlZCBjb250cmFjdCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19pbml0aWFsaXNlZCBleGlzdHMKICAgIGFzc2VydCAvLyBVbmluaXRpYWxpc2VkIGNvbnRyYWN0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTk5CiAgICAvLyByZXR1cm4gQnl0ZXMxNi5mcm9tX2J5dGVzKG9wLmV4dHJhY3Qob3Aua2VjY2FrMjU2KGIiVVBHUkFERUFCTEVfQURNSU4iKSwgMCwgY29uc3QuQllURVMxNl9MRU5HVEgpKQogICAgYnl0ZWMgNSAvLyAweGNmOGNkMzI3YjhhMmU4ZTA1MTJhMzk2ZGJhOWYwMDdiCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6OTMKICAgIC8vIHNlbGYuX2NoZWNrX3NlbmRlcl9yb2xlKHNlbGYudXBncmFkYWJsZV9hZG1pbl9yb2xlKCkpCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjI4CiAgICAvLyBhc3NlcnQgbWluX3VwZ3JhZGVfZGVsYXkgPD0gc2VsZi5tYXhfZm9yX21pbl91cGdyYWRlX2RlbGF5KCksICJEZWxheSBleGNlZWRzIG1heGltdW0gYWxsb3dlZCIKICAgIHN3YXAKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMTEKICAgIC8vIHJldHVybiBVSW50NjQoVFdPX1dFRUtTX0lOX1NFQ09ORFMpCiAgICBpbnRjIDQgLy8gMTIwOTYwMAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIyOAogICAgLy8gYXNzZXJ0IG1pbl91cGdyYWRlX2RlbGF5IDw9IHNlbGYubWF4X2Zvcl9taW5fdXBncmFkZV9kZWxheSgpLCAiRGVsYXkgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQiCiAgICA8PQogICAgYXNzZXJ0IC8vIERlbGF5IGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6OTgtOTkKICAgIC8vICMgZW5zdXJlIHRpbWVzdGFtcCBpcyBzdWZmaWNpZW50bHkgaW4gdGhlIGZ1dHVyZQogICAgLy8gc2VsZi5fY2hlY2tfc2NoZWR1bGVfdGltZXN0YW1wKHRpbWVzdGFtcCkKICAgIGNhbGxzdWIgX2NoZWNrX3NjaGVkdWxlX3RpbWVzdGFtcAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjEwMS0xMDIKICAgIC8vICMgaWYgaXQncyBhY3RpdmUsIGZyZWUgdXAgZGVsYXlfMSB0byB3cml0ZSB0byBpdAogICAgLy8gaWYgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgPj0gc2VsZi5taW5fdXBncmFkZV9kZWxheS52YWx1ZS50aW1lc3RhbXA6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAibWluX3VwZ3JhZGVfZGVsYXkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubWluX3VwZ3JhZGVfZGVsYXkgZXhpc3RzCiAgICBleHRyYWN0IDE2IDgKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIGI8PQogICAgYnogbWFpbl9hZnRlcl9pZl9lbHNlQDU4CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTAzCiAgICAvLyBzZWxmLm1pbl91cGdyYWRlX2RlbGF5LnZhbHVlLmRlbGF5XzAgPSBzZWxmLm1pbl91cGdyYWRlX2RlbGF5LnZhbHVlLmRlbGF5XzEKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJtaW5fdXBncmFkZV9kZWxheSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5taW5fdXBncmFkZV9kZWxheSBleGlzdHMKICAgIGR1cAogICAgZXh0cmFjdCA4IDgKICAgIHJlcGxhY2UyIDAKICAgIGJ5dGVjXzIgLy8gIm1pbl91cGdyYWRlX2RlbGF5IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKCm1haW5fYWZ0ZXJfaWZfZWxzZUA1ODoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMDUtMTA2CiAgICAvLyAjIHNjaGVkdWxlIGRlbGF5IGNoYW5nZSwgcG9zc2libHkgb3ZlcnJpZGluZyBleGlzdGluZyBzY2hlZHVsZWQgZGVsYXkgY2hhbmdlCiAgICAvLyBzZWxmLm1pbl91cGdyYWRlX2RlbGF5LnZhbHVlLmRlbGF5XzEgPSBBUkM0VUludDY0KG1pbl91cGdyYWRlX2RlbGF5KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gIm1pbl91cGdyYWRlX2RlbGF5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm1pbl91cGdyYWRlX2RlbGF5IGV4aXN0cwogICAgZGlnIDYKICAgIGR1cAogICAgY292ZXIgMgogICAgcmVwbGFjZTIgOAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjEwNwogICAgLy8gc2VsZi5taW5fdXBncmFkZV9kZWxheS52YWx1ZS50aW1lc3RhbXAgPSBBUkM0VUludDY0KHRpbWVzdGFtcCkKICAgIGRpZyA2CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHJlcGxhY2UyIDE2CiAgICBieXRlY18yIC8vICJtaW5fdXBncmFkZV9kZWxheSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTA5CiAgICAvLyBlbWl0KE1pbmltdW1VcGdyYWRlRGVsYXlDaGFuZ2UoQVJDNFVJbnQ2NChtaW5fdXBncmFkZV9kZWxheSksIEFSQzRVSW50NjQodGltZXN0YW1wKSkpCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDQ1N2RmOWY3IC8vIG1ldGhvZCAiTWluaW11bVVwZ3JhZGVEZWxheUNoYW5nZSh1aW50NjQsdWludDY0KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6NzgKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc2VuZF9tZXNzYWdlX3JvdXRlQDE0OgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9UcmFuc2NlaXZlci5weTozNwogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgZGlnIDEKICAgIHB1c2hpbnQgMTMwIC8vIDEzMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgdHVwbGUgZW5jb2RpbmcKICAgIGR1cAogICAgcHVzaGludCAxMzIgLy8gMTMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgdGFpbCBwb2ludGVyIGF0IGluZGV4IDUgb2YgKHVpbnQ4WzMyXSx1aW50OFszMl0sdWludDhbMzJdLHVpbnQxNix1aW50OFszMl0sKGxlbit1aW50OFtdKSkKICAgIGRpZyAyCiAgICBzd2FwCiAgICBkaWcgMgogICAgc3Vic3RyaW5nMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgcHVzaGludCAxMzQgLy8gMTM0CiAgICArCiAgICB1bmNvdmVyIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIG50dF9jb250cmFjdHMudHlwZXMuTWVzc2FnZVRvU2VuZAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCAzMgogICAgZGlnIDIKICAgIGV4dHJhY3QgMzIgMzIKICAgIGRpZyAzCiAgICBleHRyYWN0IDY0IDMyCiAgICBkaWcgNAogICAgZXh0cmFjdCA5NiAyCiAgICB1bmNvdmVyIDUKICAgIGV4dHJhY3QgOTggMzIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBzd2FwCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9UcmFuc2NlaXZlci5weTo0NC00NQogICAgLy8gIyBjaGVjayBjYWxsZXIgaXMgVHJhbnNjZWl2ZXJNYW5hZ2VyCiAgICAvLyB0cmFuc2NlaXZlcl9tYW5hZ2VyX2FkZHJlc3MsIGV4aXN0cyA9IG9wLkFwcFBhcmFtc0dldC5hcHBfYWRkcmVzcyhzZWxmLnRyYW5zY2VpdmVyX21hbmFnZXIudmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOSAvLyAidHJhbnNjZWl2ZXJfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9UcmFuc2NlaXZlci5weTo0NgogICAgLy8gYXNzZXJ0IGV4aXN0cywgZXJyLlRSQU5TQ0VJVkVSX01BTkFHRVJfQUREUkVTU19VTktOT1dOCiAgICBhc3NlcnQgLy8gVHJhbnNjZWl2ZXJNYW5hZ2VyIGFkZHJlc3MgdW5rbm93bgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9UcmFuc2NlaXZlci5weTo0NwogICAgLy8gYXNzZXJ0IHRyYW5zY2VpdmVyX21hbmFnZXJfYWRkcmVzcyA9PSBUeG4uc2VuZGVyLCBlcnIuVFJBTlNDRUlWRVJfTUFOQUdFUl9DQUxMRVIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gQ2FsbGVyIG11c3QgYmUgVHJhbnNjZWl2ZXJNYW5hZ2VyCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1RyYW5zY2VpdmVyLnB5OjQ5LTUwCiAgICAvLyAjIGNoZWNrIHBheW1lbnQKICAgIC8vIGFzc2VydCBmZWVfcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCBlcnIuRkVFX1BBWU1FTlRfUkVDRUlWRVJfVU5LTk9XTgogICAgZGlnIDYKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBVbmtub3duIGZlZSBwYXltZW50IHJlY2VpdmVyCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1RyYW5zY2VpdmVyLnB5OjUxCiAgICAvLyBhc3NlcnQgZmVlX3BheW1lbnQuYW1vdW50ID09IHNlbGYuX3F1b3RlX2RlbGl2ZXJ5X3ByaWNlKG1lc3NhZ2UsIHRyYW5zY2VpdmVyX2luc3RydWN0aW9uKSwgZXJyLkZFRV9QQVlNRU5UX0FNT1VOVF9JTkNPUlJFQ1QKICAgIHVuY292ZXIgNgogICAgZ3R4bnMgQW1vdW50CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTkyLTE5MwogICAgLy8gIyBjaGVjayB3aGV0aGVyIHBlZXIgY2hhaW4gaXMgcmVnaXN0ZXJlZAogICAgLy8gc2VsZi5nZXRfd29ybWhvbGVfcGVlcihtZXNzYWdlLmRlc3RpbmF0aW9uX2NoYWluX2lkKQogICAgZGlnIDIKICAgIGNhbGxzdWIgZ2V0X3dvcm1ob2xlX3BlZXIKICAgIHBvcAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIzMgogICAgLy8gbWVzc2FnZV9mZWUsIGV4aXN0cyA9IG9wLkFwcEdsb2JhbC5nZXRfZXhfdWludDY0KHNlbGYud29ybWhvbGVfY29yZS52YWx1ZSwgQnl0ZXMoYiJNZXNzYWdlRmVlIikpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAid29ybWhvbGVfY29yZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi53b3JtaG9sZV9jb3JlIGV4aXN0cwogICAgYnl0ZWMgMTEgLy8gMHg0ZDY1NzM3MzYxNjc2NTQ2NjU2NQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyMzMKICAgIC8vIGFzc2VydCBleGlzdHMsIGVyci5XT1JNSE9MRV9NRVNTQUdFX0ZFRV9VTktOT1dOCiAgICBhc3NlcnQgLy8gV29ybWhvbGUgbWVzc2FnZSBmZWUgaXMgdW5rbm93bgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9UcmFuc2NlaXZlci5weTo1MQogICAgLy8gYXNzZXJ0IGZlZV9wYXltZW50LmFtb3VudCA9PSBzZWxmLl9xdW90ZV9kZWxpdmVyeV9wcmljZShtZXNzYWdlLCB0cmFuc2NlaXZlcl9pbnN0cnVjdGlvbiksIGVyci5GRUVfUEFZTUVOVF9BTU9VTlRfSU5DT1JSRUNUCiAgICBkaWcgMQogICAgPT0KICAgIGFzc2VydCAvLyBJbmNvcnJlY3QgZmVlIHBheW1lbnQgYW1vdW50CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyMDItMjAzCiAgICAvLyAjIGNoZWNrIHdoZXRoZXIgcGVlciBjaGFpbiBpcyByZWdpc3RlcmVkCiAgICAvLyBzZWxmLmdldF93b3JtaG9sZV9wZWVyKG1lc3NhZ2UuZGVzdGluYXRpb25fY2hhaW5faWQpCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgZ2V0X3dvcm1ob2xlX3BlZXIKICAgIHBvcAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIwNS0yMDcKICAgIC8vICMgdHJhbnNjZWl2ZXJfaW5zdHJ1Y3Rpb24gaXMgaWdub3JlZCwgd2hlbiBhdXRvbWF0aWMgcmVsYXllciBpcyBzdXBwb3J0ZWQKICAgIC8vICMgaXQgY291bGQgYmUgdXNlZCB0byBzaWduYWwgdGhlIHJlbGF5IGFwcHJvYWNoIChhdXRvbWF0aWMvbWFudWFsKQogICAgLy8gaGFuZGxlcl9wYXlsb2FkID0gbWVzc2FnZS5pZC5ieXRlcyArIG1lc3NhZ2UudXNlcl9hZGRyZXNzLmJ5dGVzICsgbWVzc2FnZS5wYXlsb2FkLmJ5dGVzCiAgICBkaWcgNAogICAgdW5jb3ZlciA0CiAgICBjb25jYXQKICAgIHVuY292ZXIgNQogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjA5CiAgICAvLyBCeXRlcy5mcm9tX2hleChXSF9UUkFOU0NFSVZFUl9QQVlMT0FEX1BSRUZJWCkgKwogICAgYnl0ZWMgMTIgLy8gMHg5OTQ1ZmYxMAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIwOS0yMTAKICAgIC8vIEJ5dGVzLmZyb21faGV4KFdIX1RSQU5TQ0VJVkVSX1BBWUxPQURfUFJFRklYKSArCiAgICAvLyBtZXNzYWdlLnNvdXJjZV9hZGRyZXNzLmJ5dGVzICsKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjA5LTIxMQogICAgLy8gQnl0ZXMuZnJvbV9oZXgoV0hfVFJBTlNDRUlWRVJfUEFZTE9BRF9QUkVGSVgpICsKICAgIC8vIG1lc3NhZ2Uuc291cmNlX2FkZHJlc3MuYnl0ZXMgKwogICAgLy8gbWVzc2FnZS5oYW5kbGVyX2FkZHJlc3MuYnl0ZXMgKwogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyMTIKICAgIC8vIFVJbnQxNihoYW5kbGVyX3BheWxvYWQubGVuZ3RoKS5ieXRlcyArCiAgICBkaWcgMQogICAgbGVuCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18yIC8vIDE2CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDYgMgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIwOS0yMTIKICAgIC8vIEJ5dGVzLmZyb21faGV4KFdIX1RSQU5TQ0VJVkVSX1BBWUxPQURfUFJFRklYKSArCiAgICAvLyBtZXNzYWdlLnNvdXJjZV9hZGRyZXNzLmJ5dGVzICsKICAgIC8vIG1lc3NhZ2UuaGFuZGxlcl9hZGRyZXNzLmJ5dGVzICsKICAgIC8vIFVJbnQxNihoYW5kbGVyX3BheWxvYWQubGVuZ3RoKS5ieXRlcyArCiAgICBjb25jYXQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyMDktMjEzCiAgICAvLyBCeXRlcy5mcm9tX2hleChXSF9UUkFOU0NFSVZFUl9QQVlMT0FEX1BSRUZJWCkgKwogICAgLy8gbWVzc2FnZS5zb3VyY2VfYWRkcmVzcy5ieXRlcyArCiAgICAvLyBtZXNzYWdlLmhhbmRsZXJfYWRkcmVzcy5ieXRlcyArCiAgICAvLyBVSW50MTYoaGFuZGxlcl9wYXlsb2FkLmxlbmd0aCkuYnl0ZXMgKwogICAgLy8gaGFuZGxlcl9wYXlsb2FkICsKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIxNAogICAgLy8gVUludDE2KDApLmJ5dGVzICMgdHJhbnNjZWl2ZXIgcGF5bG9hZCBlbXB0eQogICAgcHVzaGJ5dGVzIDB4MDAwMAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIwOS0yMTQKICAgIC8vIEJ5dGVzLmZyb21faGV4KFdIX1RSQU5TQ0VJVkVSX1BBWUxPQURfUFJFRklYKSArCiAgICAvLyBtZXNzYWdlLnNvdXJjZV9hZGRyZXNzLmJ5dGVzICsKICAgIC8vIG1lc3NhZ2UuaGFuZGxlcl9hZGRyZXNzLmJ5dGVzICsKICAgIC8vIFVJbnQxNihoYW5kbGVyX3BheWxvYWQubGVuZ3RoKS5ieXRlcyArCiAgICAvLyBoYW5kbGVyX3BheWxvYWQgKwogICAgLy8gVUludDE2KDApLmJ5dGVzICMgdHJhbnNjZWl2ZXIgcGF5bG9hZCBlbXB0eQogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjE3LTIxOAogICAgLy8gIyBwdWJsaXNoIG1lc3NhZ2UKICAgIC8vIHdvcm1ob2xlX2NvcmVfYWRkcmVzcywgZXhpc3RzID0gb3AuQXBwUGFyYW1zR2V0LmFwcF9hZGRyZXNzKHNlbGYud29ybWhvbGVfY29yZS52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJ3b3JtaG9sZV9jb3JlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLndvcm1ob2xlX2NvcmUgZXhpc3RzCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyMTkKICAgIC8vIGFzc2VydCBleGlzdHMsIGVyci5XT1JNSE9MRV9DT1JFX0FERFJFU1NfVU5LTk9XTgogICAgYXNzZXJ0IC8vIFdvcm1ob2xlQ29yZSBhZGRyZXNzIHVua25vd24KICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyMjQKICAgIC8vIGFwcF9hcmdzPShCeXRlcyhiInB1Ymxpc2hNZXNzYWdlIiksIHBheWxvYWQsIG9wLml0b2IoMCkpLAogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyMjUKICAgIC8vIGFjY291bnRzPShBY2NvdW50KHNlbGYuZW1pdHRlcl9sc2lnLnZhbHVlLmJ5dGVzKSwpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEzIC8vICJlbWl0dGVyX2xzaWciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZW1pdHRlcl9sc2lnIGV4aXN0cwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIyOAogICAgLy8gaXR4bi5zdWJtaXRfdHhucyhwYXltZW50LCBhcHBfY2FsbCkKICAgIGl0eG5fYmVnaW4KICAgIHVuY292ZXIgNQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIyMQogICAgLy8gcGF5bWVudCA9IGl0eG4uUGF5bWVudChyZWNlaXZlcj13b3JtaG9sZV9jb3JlX2FkZHJlc3MsIGFtb3VudD10b3RhbF9mZWUsIGZlZT0wKQogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjI4CiAgICAvLyBpdHhuLnN1Ym1pdF90eG5zKHBheW1lbnQsIGFwcF9jYWxsKQogICAgaXR4bl9uZXh0CiAgICBpdHhuX2ZpZWxkIEFjY291bnRzCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjI0CiAgICAvLyBhcHBfYXJncz0oQnl0ZXMoYiJwdWJsaXNoTWVzc2FnZSIpLCBwYXlsb2FkLCBvcC5pdG9iKDApKSwKICAgIHB1c2hieXRlcyAweDcwNzU2MjZjNjk3MzY4NGQ2NTczNzM2MTY3NjUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjIyCiAgICAvLyBhcHBfY2FsbCA9IGl0eG4uQXBwbGljYXRpb25DYWxsKAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyMjYKICAgIC8vIGZlZT0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjI4CiAgICAvLyBpdHhuLnN1Ym1pdF90eG5zKHBheW1lbnQsIGFwcF9jYWxsKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvVHJhbnNjZWl2ZXIucHk6NTYtNTcKICAgIC8vICMgZW1pdCBldmVudAogICAgLy8gZW1pdChNZXNzYWdlU2VudChtZXNzYWdlLmlkKSkKICAgIHB1c2hieXRlcyAweGU1ZDBkZjM3IC8vIG1ldGhvZCAiTWVzc2FnZVNlbnQoYnl0ZVszMl0pIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvVHJhbnNjZWl2ZXIucHk6MzcKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcXVvdGVfZGVsaXZlcnlfcHJpY2Vfcm91dGVAMTM6CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1RyYW5zY2VpdmVyLnB5OjMzCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgZGlnIDEKICAgIHB1c2hpbnQgMTMwIC8vIDEzMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgdHVwbGUgZW5jb2RpbmcKICAgIGR1cAogICAgcHVzaGludCAxMzIgLy8gMTMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgdGFpbCBwb2ludGVyIGF0IGluZGV4IDUgb2YgKHVpbnQ4WzMyXSx1aW50OFszMl0sdWludDhbMzJdLHVpbnQxNix1aW50OFszMl0sKGxlbit1aW50OFtdKSkKICAgIGRpZyAyCiAgICBzd2FwCiAgICBkaWcgMgogICAgc3Vic3RyaW5nMwogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIHB1c2hpbnQgMTM0IC8vIDEzNAogICAgKwogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgbnR0X2NvbnRyYWN0cy50eXBlcy5NZXNzYWdlVG9TZW5kCiAgICBleHRyYWN0IDk2IDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBzd2FwCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjE5Mi0xOTMKICAgIC8vICMgY2hlY2sgd2hldGhlciBwZWVyIGNoYWluIGlzIHJlZ2lzdGVyZWQKICAgIC8vIHNlbGYuZ2V0X3dvcm1ob2xlX3BlZXIobWVzc2FnZS5kZXN0aW5hdGlvbl9jaGFpbl9pZCkKICAgIGNhbGxzdWIgZ2V0X3dvcm1ob2xlX3BlZXIKICAgIHBvcAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIzMgogICAgLy8gbWVzc2FnZV9mZWUsIGV4aXN0cyA9IG9wLkFwcEdsb2JhbC5nZXRfZXhfdWludDY0KHNlbGYud29ybWhvbGVfY29yZS52YWx1ZSwgQnl0ZXMoYiJNZXNzYWdlRmVlIikpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAid29ybWhvbGVfY29yZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi53b3JtaG9sZV9jb3JlIGV4aXN0cwogICAgYnl0ZWMgMTEgLy8gMHg0ZDY1NzM3MzYxNjc2NTQ2NjU2NQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyMzMKICAgIC8vIGFzc2VydCBleGlzdHMsIGVyci5XT1JNSE9MRV9NRVNTQUdFX0ZFRV9VTktOT1dOCiAgICBhc3NlcnQgLy8gV29ybWhvbGUgbWVzc2FnZSBmZWUgaXMgdW5rbm93bgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9UcmFuc2NlaXZlci5weTozMwogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgaXRvYgogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRfd29ybWhvbGVfcGVlcl9yb3V0ZUAxMjoKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxMjgKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDIgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MTYKICAgIGNhbGxzdWIgZ2V0X3dvcm1ob2xlX3BlZXIKICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fbWFuYWdlcl9yb2xlX3JvdXRlQDExOgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjEyNAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzVhZjI5MGQ4NjgwODIwYWFkOTIyODU1ZjM5YjMwNjA5NwogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3JlY2VpdmVfbWVzc2FnZV9yb3V0ZUAxMDoKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weTo5MQogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIGFwcGwKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9Jbml0aWFsaXNhYmxlLnB5OjYzCiAgICAvLyBhc3NlcnQgc2VsZi5pc19pbml0aWFsaXNlZCwgIlVuaW5pdGlhbGlzZWQgY29udHJhY3QiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfaW5pdGlhbGlzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfaW5pdGlhbGlzZWQgZXhpc3RzCiAgICBhc3NlcnQgLy8gVW5pbml0aWFsaXNlZCBjb250cmFjdAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjEwMC0xMDEKICAgIC8vICMgY2hlY2sgbWVzc2FnZSBoYXMgYmVlbiB2ZXJpZmllZAogICAgLy8gYXNzZXJ0IHZlcmlmeV92YWEuYXBwX2lkLmlkID09IHNlbGYud29ybWhvbGVfY29yZS52YWx1ZSwgZXJyLkFQUF9DQUxMX0lEX0lOQ09SUkVDVAogICAgZHVwCiAgICBndHhucyBBcHBsaWNhdGlvbklECiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAid29ybWhvbGVfY29yZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi53b3JtaG9sZV9jb3JlIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBJbmNvcnJlY3QgYXBwIGNhbGwgaWQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxMDIKICAgIC8vIGFzc2VydCB2ZXJpZnlfdmFhLm9uX2NvbXBsZXRpb24gPT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wLCBlcnIuQVBQX0NBTExfT05fQ09NUExFVElPTl9JTkNPUlJFQ1QKICAgIGR1cAogICAgZ3R4bnMgT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gSW5jb3JyZWN0IGFwcCBjYWxsIG9uIGNvbXBsZXRpb24KICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxMDMKICAgIC8vIGFzc2VydCB2ZXJpZnlfdmFhLmFwcF9hcmdzKDApID09IEJ5dGVzKGIidmVyaWZ5VkFBIiksIGVyci5BUFBfQ0FMTF9NRVRIT0RfSU5DT1JSRUNUCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBndHhuc2FzIEFwcGxpY2F0aW9uQXJncwogICAgcHVzaGJ5dGVzIDB4NzY2NTcyNjk2Njc5NTY0MTQxCiAgICA9PQogICAgYXNzZXJ0IC8vIEluY29ycmVjdCBhcHAgY2FsbCBtZXRob2QKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxMDcKICAgIC8vIG51bV9zaWdzID0gb3AuYnRvaShvcC5leHRyYWN0KHZlcmlmeV92YWEuYXBwX2FyZ3MoMSksIGluZGV4LCBjb25zdC5VSU5UOF9MRU5HVEgpKQogICAgaW50Y18xIC8vIDEKICAgIGd0eG5zYXMgQXBwbGljYXRpb25BcmdzCiAgICBkdXAKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxMDUtMTA2CiAgICAvLyAjIGhlYWRlcgogICAgLy8gaW5kZXggPSBVSW50NjQoY29uc3QuQllURV9MRU5HVEggKyBjb25zdC5VSU5UMzJfTEVOR1RIKSAjIHNraXAgdmVyc2lvbiBhbmQgZ3VhcmRpYW5fc2V0X2luZGV4CiAgICBwdXNoaW50IDUgLy8gNQogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjEwNwogICAgLy8gbnVtX3NpZ3MgPSBvcC5idG9pKG9wLmV4dHJhY3QodmVyaWZ5X3ZhYS5hcHBfYXJncygxKSwgaW5kZXgsIGNvbnN0LlVJTlQ4X0xFTkdUSCkpCiAgICBnZXRieXRlCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTA4CiAgICAvLyBpbmRleCArPSBjb25zdC5VSU5UOF9MRU5HVEggKyBudW1fc2lncyAqIFNJR05BVFVSRV9MRU5HVEggIyBza2lwIHNpZ25hdHVyZXMKICAgIHB1c2hpbnQgNjYgLy8gNjYKICAgICoKICAgIHB1c2hpbnQgNiAvLyA2CiAgICArCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTEyCiAgICAvLyBvcC5rZWNjYWsyNTYob3Aua2VjY2FrMjU2KG9wLnN1YnN0cmluZyh2ZXJpZnlfdmFhLmFwcF9hcmdzKDEpLCBpbmRleCwgdmVyaWZ5X3ZhYS5hcHBfYXJncygxKS5sZW5ndGgpKSkKICAgIGRpZyAxCiAgICBsZW4KICAgIGRpZyAyCiAgICBkaWcgMgogICAgZGlnIDIKICAgIHN1YnN0cmluZzMKICAgIGtlY2NhazI1NgogICAga2VjY2FrMjU2CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTEwLTExMwogICAgLy8gIyBib2R5CiAgICAvLyB2YWFfZGlnZXN0ID0gVmFhRGlnZXN0LmZyb21fYnl0ZXMoCiAgICAvLyAgICAgb3Aua2VjY2FrMjU2KG9wLmtlY2NhazI1NihvcC5zdWJzdHJpbmcodmVyaWZ5X3ZhYS5hcHBfYXJncygxKSwgaW5kZXgsIHZlcmlmeV92YWEuYXBwX2FyZ3MoMSkubGVuZ3RoKSkpCiAgICAvLyApCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGJ1cnkgOAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjExNAogICAgLy8gaW5kZXggKz0gY29uc3QuVUlOVDMyX0xFTkdUSCArIGNvbnN0LlVJTlQzMl9MRU5HVEggIyBza2lwIHRpbWVzdGFtcCBhbmQgbm9uY2UKICAgIHN3YXAKICAgIHB1c2hpbnQgOCAvLyA4CiAgICArCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTE1CiAgICAvLyBlbWl0dGVyX2NoYWluX2lkID0gVUludDE2KG9wLmV4dHJhY3RfdWludDE2KHZlcmlmeV92YWEuYXBwX2FyZ3MoMSksIGluZGV4KSkKICAgIGRpZyAyCiAgICBkaWcgMQogICAgZXh0cmFjdF91aW50MTYKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzIgLy8gMTYKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNiAyCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGJ1cnkgMTcKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxMTYKICAgIC8vIGluZGV4ICs9IGNvbnN0LlVJTlQxNl9MRU5HVEgKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTE3CiAgICAvLyBlbWl0dGVyX2FkZHJlc3MgPSBVbml2ZXJzYWxBZGRyZXNzLmZyb21fYnl0ZXMob3AuZXh0cmFjdCh2ZXJpZnlfdmFhLmFwcF9hcmdzKDEpLCBpbmRleCwgY29uc3QuQllURVMzMl9MRU5HVEgpKQogICAgZGlnIDIKICAgIGRpZyAxCiAgICBpbnRjXzMgLy8gMzIKICAgIGV4dHJhY3QzCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTE4CiAgICAvLyBpbmRleCArPSBjb25zdC5CWVRFUzMyX0xFTkdUSCArIGNvbnN0LlVJTlQ2NF9MRU5HVEggKyBjb25zdC5VSU5UOF9MRU5HVEggIyBza2lwIHNlcXVlbmNlIGFuZCBjb25zaXN0ZW5jeV9sZXZlbAogICAgc3dhcAogICAgcHVzaGludCA0MSAvLyA0MQogICAgKwogICAgY292ZXIgMgogICAgY292ZXIgMwogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjExOQogICAgLy8gcGF5bG9hZCA9IG9wLnN1YnN0cmluZyh2ZXJpZnlfdmFhLmFwcF9hcmdzKDEpLCBpbmRleCwgdmVyaWZ5X3ZhYS5hcHBfYXJncygxKS5sZW5ndGgpCiAgICBzdWJzdHJpbmczCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTQ3CiAgICAvLyBhc3NlcnQgQnl0ZXMuZnJvbV9oZXgoV0hfVFJBTlNDRUlWRVJfUEFZTE9BRF9QUkVGSVgpID09IG9wLmV4dHJhY3QocGF5bG9hZCwgaW5kZXgsIGNvbnN0LkJZVEVTNF9MRU5HVEgpLCBlcnIuUFJFRklYX0lOQ09SUkVDVAogICAgZHVwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWMgMTIgLy8gMHg5OTQ1ZmYxMAogICAgPT0KICAgIGFzc2VydCAvLyBJbmNvcnJlY3QgcHJlZml4CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTQ5CiAgICAvLyBzb3VyY2VfYWRkcmVzcyA9IFVuaXZlcnNhbEFkZHJlc3MuZnJvbV9ieXRlcyhvcC5leHRyYWN0KHBheWxvYWQsIGluZGV4LCBjb25zdC5CWVRFUzMyX0xFTkdUSCkpCiAgICBkdXAKICAgIGV4dHJhY3QgNCAzMgogICAgYnVyeSAxMQogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjE1MQogICAgLy8gaGFuZGxlcl9hZGRyZXNzID0gVW5pdmVyc2FsQWRkcmVzcy5mcm9tX2J5dGVzKG9wLmV4dHJhY3QocGF5bG9hZCwgaW5kZXgsIGNvbnN0LkJZVEVTMzJfTEVOR1RIKSkKICAgIGR1cAogICAgZXh0cmFjdCAzNiAzMgogICAgYnVyeSAxNQogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjE1MwogICAgLy8gaGFuZGxlcl9wYXlsb2FkX2xlbmd0aCA9IG9wLmV4dHJhY3RfdWludDE2KHBheWxvYWQsIGluZGV4KQogICAgZHVwCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTUyCiAgICAvLyBpbmRleCArPSBjb25zdC5CWVRFUzMyX0xFTkdUSAogICAgcHVzaGludCA2OCAvLyA2OAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjE1MwogICAgLy8gaGFuZGxlcl9wYXlsb2FkX2xlbmd0aCA9IG9wLmV4dHJhY3RfdWludDE2KHBheWxvYWQsIGluZGV4KQogICAgZXh0cmFjdF91aW50MTYKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxNTQKICAgIC8vIGluZGV4ICs9IGNvbnN0LlVJTlQxNl9MRU5HVEgKICAgIHB1c2hpbnQgNzAgLy8gNzAKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxNTUKICAgIC8vIGhhbmRsZXJfcGF5bG9hZCA9IG9wLnN1YnN0cmluZyhwYXlsb2FkLCBpbmRleCwgaW5kZXggKyBoYW5kbGVyX3BheWxvYWRfbGVuZ3RoKQogICAgKwogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjE1NAogICAgLy8gaW5kZXggKz0gY29uc3QuVUlOVDE2X0xFTkdUSAogICAgcHVzaGludCA3MCAvLyA3MAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjE1NQogICAgLy8gaGFuZGxlcl9wYXlsb2FkID0gb3Auc3Vic3RyaW5nKHBheWxvYWQsIGluZGV4LCBpbmRleCArIGhhbmRsZXJfcGF5bG9hZF9sZW5ndGgpCiAgICBzd2FwCiAgICBzdWJzdHJpbmczCiAgICBidXJ5IDEzCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTU4LTE1OQogICAgLy8gIyBjaGVjayBtZXNzYWdlIGNvbWVzIGZyb20gcGVlcgogICAgLy8gYXNzZXJ0IGVtaXR0ZXJfYWRkcmVzcyA9PSBzZWxmLmdldF93b3JtaG9sZV9wZWVyKGVtaXR0ZXJfY2hhaW5faWQpLCBlcnIuUEVFUl9BRERSRVNTX1VOS05PV04KICAgIHN3YXAKICAgIGNhbGxzdWIgZ2V0X3dvcm1ob2xlX3BlZXIKICAgID09CiAgICBhc3NlcnQgLy8gVW5rbm93biBwZWVyIGFkZHJlc3MKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyMzgKICAgIC8vIGFzc2VydCBub3QgKEJvb2wodmFhX2RpZ2VzdCBpbiBzZWxmLnZhYXNfY29uc3VtZWQpIGFuZCBzZWxmLnZhYXNfY29uc3VtZWRbdmFhX2RpZ2VzdF0pLCBlcnIuVkFBX0FMUkVBRFlfU0VFTgogICAgcHVzaGJ5dGVzIDB4NzY2MTYxNzM1ZjYzNmY2ZTczNzU2ZDY1NjQ1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJ1cnkgMTQKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnl0ZWNfMSAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGJ5dGVjXzEgLy8gMHgwMAogICAgIT0KICAgIGJ6IG1haW5fYm9vbF9mYWxzZUA5OAogICAgZGlnIDEyCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWFzX2NvbnN1bWVkIGVudHJ5IGV4aXN0cwogICAgYnl0ZWNfMSAvLyAweDAwCiAgICAhPQogICAgYnogbWFpbl9ib29sX2ZhbHNlQDk4CiAgICBpbnRjXzEgLy8gMQoKbWFpbl9ib29sX21lcmdlQDk5OgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIzOAogICAgLy8gYXNzZXJ0IG5vdCAoQm9vbCh2YWFfZGlnZXN0IGluIHNlbGYudmFhc19jb25zdW1lZCkgYW5kIHNlbGYudmFhc19jb25zdW1lZFt2YWFfZGlnZXN0XSksIGVyci5WQUFfQUxSRUFEWV9TRUVOCiAgICAhCiAgICBhc3NlcnQgLy8gVkFBIGFscmVhZHkgc2VlbgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjIzOQogICAgLy8gc2VsZi52YWFzX2NvbnN1bWVkW3ZhYV9kaWdlc3RdID0gQm9vbChUcnVlKQogICAgZGlnIDEyCiAgICBieXRlYyA4IC8vIDB4ODAKICAgIGJveF9wdXQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxNjYKICAgIC8vIG1lc3NhZ2VfaWQgPSBNZXNzYWdlSWQuZnJvbV9ieXRlcyhvcC5leHRyYWN0KGhhbmRsZXJfcGF5bG9hZCwgaW5kZXgsIGNvbnN0LkJZVEVTMzJfTEVOR1RIKSkKICAgIGRpZyA5CiAgICBkdXAKICAgIGV4dHJhY3QgMCAzMgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjE2OAogICAgLy8gbWVzc2FnZV91c2VyX2FkZHJlc3MgPSBVbml2ZXJzYWxBZGRyZXNzLmZyb21fYnl0ZXMob3AuZXh0cmFjdChoYW5kbGVyX3BheWxvYWQsIGluZGV4LCBjb25zdC5CWVRFUzMyX0xFTkdUSCkpCiAgICBkaWcgMQogICAgZXh0cmFjdCAzMiAzMgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjE3MAogICAgLy8gbWVzc2FnZV9wYXlsb2FkID0gRHluYW1pY0J5dGVzLmZyb21fYnl0ZXMob3Auc3Vic3RyaW5nKGhhbmRsZXJfcGF5bG9hZCwgaW5kZXgsIGhhbmRsZXJfcGF5bG9hZC5sZW5ndGgpKQogICAgZGlnIDIKICAgIGxlbgogICAgZGlnIDMKICAgIGV4dHJhY3QgNjQgMAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjE3Mi0xNzMKICAgIC8vICMgZW5zdXJlIG1lc3NhZ2UgcGF5bG9hZCBzcGVjaWZpZXMgY29ycmVjdCBsZW5ndGgKICAgIC8vIG1lc3NhZ2VfcGF5bG9hZF9sZW5ndGggPSBvcC5idG9pKG9wLmV4dHJhY3QoaGFuZGxlcl9wYXlsb2FkLCBpbmRleCwgY29uc3QuVUlOVDE2X0xFTkdUSCkpCiAgICB1bmNvdmVyIDQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxNjkKICAgIC8vIGluZGV4ICs9IGNvbnN0LkJZVEVTMzJfTEVOR1RICiAgICBwdXNoaW50IDY0IC8vIDY0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTcyLTE3MwogICAgLy8gIyBlbnN1cmUgbWVzc2FnZSBwYXlsb2FkIHNwZWNpZmllcyBjb3JyZWN0IGxlbmd0aAogICAgLy8gbWVzc2FnZV9wYXlsb2FkX2xlbmd0aCA9IG9wLmJ0b2kob3AuZXh0cmFjdChoYW5kbGVyX3BheWxvYWQsIGluZGV4LCBjb25zdC5VSU5UMTZfTEVOR1RIKSkKICAgIGV4dHJhY3RfdWludDE2CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTc0CiAgICAvLyBhc3NlcnQgaGFuZGxlcl9wYXlsb2FkLmxlbmd0aCAtIGluZGV4IC0gY29uc3QuVUlOVDE2X0xFTkdUSCA9PSBtZXNzYWdlX3BheWxvYWRfbGVuZ3RoLCBlcnIuTEVOR1RIX0lOQ09SUkVDVAogICAgdW5jb3ZlciAyCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTY5CiAgICAvLyBpbmRleCArPSBjb25zdC5CWVRFUzMyX0xFTkdUSAogICAgcHVzaGludCA2NCAvLyA2NAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjE3NAogICAgLy8gYXNzZXJ0IGhhbmRsZXJfcGF5bG9hZC5sZW5ndGggLSBpbmRleCAtIGNvbnN0LlVJTlQxNl9MRU5HVEggPT0gbWVzc2FnZV9wYXlsb2FkX2xlbmd0aCwgZXJyLkxFTkdUSF9JTkNPUlJFQ1QKICAgIC0KICAgIHB1c2hpbnQgMiAvLyAyCiAgICAtCiAgICA9PQogICAgYXNzZXJ0IC8vIEluY29ycmVjdCBsZW5ndGgKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvVHJhbnNjZWl2ZXIucHk6NjctNzIKICAgIC8vIGFiaV9jYWxsKAogICAgLy8gICAgIElUcmFuc2NlaXZlck1hbmFnZXIuYXR0ZXN0YXRpb25fcmVjZWl2ZWQsCiAgICAvLyAgICAgbWVzc2FnZSwKICAgIC8vICAgICBhcHBfaWQ9c2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyLnZhbHVlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9UcmFuc2NlaXZlci5weTo2OQogICAgLy8gbWVzc2FnZSwKICAgIGRpZyAyCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgZGlnIDE0CiAgICBjb25jYXQKICAgIGRpZyA5CiAgICBjb25jYXQKICAgIGRpZyAxMwogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHgwMDg0CiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9UcmFuc2NlaXZlci5weTo3MAogICAgLy8gYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA5IC8vICJ0cmFuc2NlaXZlcl9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRyYW5zY2VpdmVyX21hbmFnZXIgZXhpc3RzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvVHJhbnNjZWl2ZXIucHk6NjctNzIKICAgIC8vIGFiaV9jYWxsKAogICAgLy8gICAgIElUcmFuc2NlaXZlck1hbmFnZXIuYXR0ZXN0YXRpb25fcmVjZWl2ZWQsCiAgICAvLyAgICAgbWVzc2FnZSwKICAgIC8vICAgICBhcHBfaWQ9c2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyLnZhbHVlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4YjFmYzQ3YjggLy8gbWV0aG9kICJhdHRlc3RhdGlvbl9yZWNlaXZlZCgoYnl0ZVszMl0sYnl0ZVszMl0sdWludDE2LGJ5dGVbMzJdLGJ5dGVbMzJdLGJ5dGVbXSkpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvVHJhbnNjZWl2ZXIucHk6NzEKICAgIC8vIGZlZT0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1RyYW5zY2VpdmVyLnB5OjY3LTcyCiAgICAvLyBhYmlfY2FsbCgKICAgIC8vICAgICBJVHJhbnNjZWl2ZXJNYW5hZ2VyLmF0dGVzdGF0aW9uX3JlY2VpdmVkLAogICAgLy8gICAgIG1lc3NhZ2UsCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTg3LTE4OAogICAgLy8gIyBlbWl0IGV2ZW50CiAgICAvLyBlbWl0KFJlY2VpdmVkTWVzc2FnZSh2YWFfZGlnZXN0LCBtZXNzYWdlX2lkKSkKICAgIGRpZyA0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDYwODhlMGNjIC8vIG1ldGhvZCAiUmVjZWl2ZWRNZXNzYWdlKGJ5dGVbMzJdLGJ5dGVbMzJdKSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6OTEKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYm9vbF9mYWxzZUA5ODoKICAgIGludGNfMCAvLyAwCiAgICBiIG1haW5fYm9vbF9tZXJnZUA5OQoKbWFpbl9zZXRfd29ybWhvbGVfcGVlcl9yb3V0ZUA5OgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5Ojc0CiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAyIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9Jbml0aWFsaXNhYmxlLnB5OjYzCiAgICAvLyBhc3NlcnQgc2VsZi5pc19pbml0aWFsaXNlZCwgIlVuaW5pdGlhbGlzZWQgY29udHJhY3QiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfaW5pdGlhbGlzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfaW5pdGlhbGlzZWQgZXhpc3RzCiAgICBhc3NlcnQgLy8gVW5pbml0aWFsaXNlZCBjb250cmFjdAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjEyNgogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5leHRyYWN0KG9wLmtlY2NhazI1NihiIk1BTkFHRVIiKSwgMCwgY29uc3QuQllURVMxNl9MRU5HVEgpKQogICAgYnl0ZWMgMTQgLy8gMHhhZjI5MGQ4NjgwODIwYWFkOTIyODU1ZjM5YjMwNjA5NwogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjgzCiAgICAvLyBzZWxmLl9jaGVja19zZW5kZXJfcm9sZShzZWxmLm1hbmFnZXJfcm9sZSgpKQogICAgY2FsbHN1YiBfY2hlY2tfc2VuZGVyX3JvbGUKICAgIHBvcAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5Ojg1CiAgICAvLyBhc3NlcnQgcGVlcl9jaGFpbl9pZCAhPSBzZWxmLmNoYWluX2lkLnZhbHVlLCBlcnIuUEVFUl9DQU5OT1RfQkVfSVRTRUxGCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTUgLy8gImNoYWluX2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNoYWluX2lkIGV4aXN0cwogICAgZGlnIDIKICAgIGIhPQogICAgYXNzZXJ0IC8vIENhbm5vdCBzZXQgaXRzZWxmIGFzIHBlZXIgY2hhaW4KICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weTo4Ny04OAogICAgLy8gIyBzZXQgcGVlciAob3ZlcnJpZGluZyBpZiBuZWVkZWQpCiAgICAvLyBzZWxmLndvcm1ob2xlX3BlZXJzW3BlZXJfY2hhaW5faWRdID0gcGVlcl9jb250cmFjdF9hZGRyZXNzLmNvcHkoKQogICAgYnl0ZWMgMTYgLy8gMHg3NzZmNzI2ZDY4NmY2YzY1NWY3MDY1NjU3MjVmCiAgICBkaWcgMgogICAgY29uY2F0CiAgICBkaWcgMQogICAgYm94X3B1dAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5Ojg5CiAgICAvLyBlbWl0KFdvcm1ob2xlUGVlclNldChwZWVyX2NoYWluX2lkLCBwZWVyX2NvbnRyYWN0X2FkZHJlc3MpKQogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHhmNWE4NjQ2MyAvLyBtZXRob2QgIldvcm1ob2xlUGVlclNldCh1aW50MTYsYnl0ZVszMl0pIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weTo3NAogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRfdHJhbnNjZWl2ZXJfdHlwZV9yb3V0ZUA4OgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjcwCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NTAwMDg3NzZmNzI2ZDY4NmY2YzY1CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faW5pdGlhbGlzZV9yb3V0ZUA3OgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjYxCiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9leHRlbnNpb25zL0luaXRpYWxpc2FibGVXaXRoQ3JlYXRvci5weToyNQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgIkNhbGxlciBtdXN0IGJlIHRoZSBjb250cmFjdCBjcmVhdG9yIgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbGxlciBtdXN0IGJlIHRoZSBjb250cmFjdCBjcmVhdG9yCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo1NwogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX2luaXRpYWxpc2VkLCAiQ29udHJhY3QgYWxyZWFkeSBpbml0aWFsaXNlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19pbml0aWFsaXNlZCBleGlzdHMKICAgICEKICAgIGFzc2VydCAvLyBDb250cmFjdCBhbHJlYWR5IGluaXRpYWxpc2VkCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo1OQogICAgLy8gc2VsZi5pc19pbml0aWFsaXNlZCA9IFRydWUKICAgIGJ5dGVjXzAgLy8gImlzX2luaXRpYWxpc2VkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxMDkKICAgIC8vIHJldHVybiBCeXRlczE2LmZyb21fYnl0ZXMob3AuYnplcm8oY29uc3QuQllURVMxNl9MRU5HVEgpKQogICAgaW50Y18yIC8vIDE2CiAgICBiemVybwogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjY2CiAgICAvLyBzZWxmLl9ncmFudF9yb2xlKHNlbGYuZGVmYXVsdF9hZG1pbl9yb2xlKCksIGFkbWluKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2dyYW50X3JvbGUKICAgIHBvcG4gMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE5OQogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5leHRyYWN0KG9wLmtlY2NhazI1NihiIlVQR1JBREVBQkxFX0FETUlOIiksIDAsIGNvbnN0LkJZVEVTMTZfTEVOR1RIKSkKICAgIGJ5dGVjIDUgLy8gMHhjZjhjZDMyN2I4YTJlOGUwNTEyYTM5NmRiYTlmMDA3YgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjY3CiAgICAvLyBzZWxmLl9ncmFudF9yb2xlKHNlbGYudXBncmFkYWJsZV9hZG1pbl9yb2xlKCksIGFkbWluKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2dyYW50X3JvbGUKICAgIHBvcG4gMgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjEyNgogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5leHRyYWN0KG9wLmtlY2NhazI1NihiIk1BTkFHRVIiKSwgMCwgY29uc3QuQllURVMxNl9MRU5HVEgpKQogICAgYnl0ZWMgMTQgLy8gMHhhZjI5MGQ4NjgwODIwYWFkOTIyODU1ZjM5YjMwNjA5NwogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjY4CiAgICAvLyBzZWxmLl9ncmFudF9yb2xlKHNlbGYubWFuYWdlcl9yb2xlKCksIGFkbWluKQogICAgc3dhcAogICAgY2FsbHN1YiBfZ3JhbnRfcm9sZQogICAgcG9wbiAyCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6NjEKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX05vT3BAMjg6CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjUKICAgIC8vIGNsYXNzIFdvcm1ob2xlVHJhbnNjZWl2ZXIoVHJhbnNjZWl2ZXIsIEluaXRpYWxpc2FibGVXaXRoQ3JlYXRvcik6CiAgICBwdXNoYnl0ZXMgMHg1ZDM4YTViOCAvLyBtZXRob2QgImNyZWF0ZSh1aW50NjQsdWludDY0LHVpbnQxNix1aW50NjQpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fY3JlYXRlX3JvdXRlQDI5CiAgICBlcnIKCm1haW5fY3JlYXRlX3JvdXRlQDI5OgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjQ3CiAgICAvLyBAYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA4IC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA4IC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAyIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA4IC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBkdXAKICAgIGJ0b2kKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMTEKICAgIC8vIHJldHVybiBVSW50NjQoVFdPX1dFRUtTX0lOX1NFQ09ORFMpCiAgICBpbnRjIDQgLy8gMTIwOTYwMAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIyOAogICAgLy8gYXNzZXJ0IG1pbl91cGdyYWRlX2RlbGF5IDw9IHNlbGYubWF4X2Zvcl9taW5fdXBncmFkZV9kZWxheSgpLCAiRGVsYXkgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQiCiAgICA8PQogICAgYXNzZXJ0IC8vIERlbGF5IGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6NzYKICAgIC8vIHNlbGYubWluX3VwZ3JhZGVfZGVsYXkudmFsdWUgPSBNaW5pbXVtVXBncmFkZURlbGF5KEFSQzRVSW50NjQoMCksIEFSQzRVSW50NjQobWluX3VwZ3JhZGVfZGVsYXkpLCBBUkM0VUludDY0KDApKQogICAgYnl0ZWMgMTcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjIDE3IC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgY29uY2F0CiAgICBieXRlY18yIC8vICJtaW5fdXBncmFkZV9kZWxheSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1RyYW5zY2VpdmVyLnB5OjMxCiAgICAvLyBzZWxmLnRyYW5zY2VpdmVyX21hbmFnZXIudmFsdWUgPSB0cmFuc2NlaXZlcl9tYW5hZ2VyCiAgICBieXRlYyA5IC8vICJ0cmFuc2NlaXZlcl9tYW5hZ2VyIgogICAgdW5jb3ZlciAzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjU3CiAgICAvLyBzZWxmLndvcm1ob2xlX2NvcmUudmFsdWUgPSB3b3JtaG9sZV9jb3JlCiAgICBieXRlY18zIC8vICJ3b3JtaG9sZV9jb3JlIgogICAgdW5jb3ZlciAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjU4CiAgICAvLyBzZWxmLmNoYWluX2lkLnZhbHVlID0gY2hhaW5faWQKICAgIGJ5dGVjIDE1IC8vICJjaGFpbl9pZCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjQzCiAgICAvLyB3b3JtaG9sZV9jb3JlX2FkZHJlc3MsIGV4aXN0cyA9IG9wLkFwcFBhcmFtc0dldC5hcHBfYWRkcmVzcyhzZWxmLndvcm1ob2xlX2NvcmUudmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAid29ybWhvbGVfY29yZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi53b3JtaG9sZV9jb3JlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjQ0CiAgICAvLyBhc3NlcnQgZXhpc3RzLCBlcnIuV09STUhPTEVfQ09SRV9BRERSRVNTX1VOS05PV04KICAgIGFzc2VydCAvLyBXb3JtaG9sZUNvcmUgYWRkcmVzcyB1bmtub3duCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjQ3LTI0OAogICAgLy8gQnl0ZXMoYiJQcm9ncmFtIikgKwogICAgLy8gQnl0ZXMuZnJvbV9oZXgoIjA2MjAwMTAxODEwMDQ4ODAyMCIpICsgICMgaGFyZGNvZGVkIFRNUExfQUREUl9JRFggYXMgMCwgc3VmZml4IDIwIGlzIGxlbmd0aCBvZiBiZWxvdyBieXRlcwogICAgcHVzaGJ5dGVzIDB4NTA3MjZmNjc3MjYxNmQwNjIwMDEwMTgxMDA0ODgwMjAKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNDkKICAgIC8vIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYnl0ZXMgKyAgIyBUTVBMX0VNSVRURVJfSUQKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjQ3LTI0OQogICAgLy8gQnl0ZXMoYiJQcm9ncmFtIikgKwogICAgLy8gQnl0ZXMuZnJvbV9oZXgoIjA2MjAwMTAxODEwMDQ4ODAyMCIpICsgICMgaGFyZGNvZGVkIFRNUExfQUREUl9JRFggYXMgMCwgc3VmZml4IDIwIGlzIGxlbmd0aCBvZiBiZWxvdyBieXRlcwogICAgLy8gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5ieXRlcyArICAjIFRNUExfRU1JVFRFUl9JRAogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjUwCiAgICAvLyBCeXRlcy5mcm9tX2hleCgiNDgzMTEwODEwNjEyNDQzMTE5MjIxMjQ0MzExODgxIikgKwogICAgcHVzaGJ5dGVzIDB4NDgzMTEwODEwNjEyNDQzMTE5MjIxMjQ0MzExODgxCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjQ3LTI1MAogICAgLy8gQnl0ZXMoYiJQcm9ncmFtIikgKwogICAgLy8gQnl0ZXMuZnJvbV9oZXgoIjA2MjAwMTAxODEwMDQ4ODAyMCIpICsgICMgaGFyZGNvZGVkIFRNUExfQUREUl9JRFggYXMgMCwgc3VmZml4IDIwIGlzIGxlbmd0aCBvZiBiZWxvdyBieXRlcwogICAgLy8gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5ieXRlcyArICAjIFRNUExfRU1JVFRFUl9JRAogICAgLy8gQnl0ZXMuZnJvbV9oZXgoIjQ4MzExMDgxMDYxMjQ0MzExOTIyMTI0NDMxMTg4MSIpICsKICAgIGNvbmNhdAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjI1OQogICAgLy8gcmV0dXJuIHNlbGYuX2VuY29kZV91dmFyaW50X2hlbHBlcih2YWwsIEJ5dGVzKGIiIikpCiAgICB1bmNvdmVyIDIKICAgIHB1c2hieXRlcyAweAogICAgY2FsbHN1YiBfZW5jb2RlX3V2YXJpbnRfaGVscGVyCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjQ3LTI1MQogICAgLy8gQnl0ZXMoYiJQcm9ncmFtIikgKwogICAgLy8gQnl0ZXMuZnJvbV9oZXgoIjA2MjAwMTAxODEwMDQ4ODAyMCIpICsgICMgaGFyZGNvZGVkIFRNUExfQUREUl9JRFggYXMgMCwgc3VmZml4IDIwIGlzIGxlbmd0aCBvZiBiZWxvdyBieXRlcwogICAgLy8gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5ieXRlcyArICAjIFRNUExfRU1JVFRFUl9JRAogICAgLy8gQnl0ZXMuZnJvbV9oZXgoIjQ4MzExMDgxMDYxMjQ0MzExOTIyMTI0NDMxMTg4MSIpICsKICAgIC8vIHNlbGYuX2VuY29kZV91dmFyaW50KHNlbGYud29ybWhvbGVfY29yZS52YWx1ZSkgKyAgIyBUTVBMX0FQUF9JRAogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjUyCiAgICAvLyBCeXRlcy5mcm9tX2hleCgiMTI0NDMxMjA4MDIwIikgKyAgIyBzdWZmaXggMjAgaXMgbGVuZ3RoIG9mIGJlbG93IGJ5dGVzCiAgICBwdXNoYnl0ZXMgMHgxMjQ0MzEyMDgwMjAKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNDctMjUyCiAgICAvLyBCeXRlcyhiIlByb2dyYW0iKSArCiAgICAvLyBCeXRlcy5mcm9tX2hleCgiMDYyMDAxMDE4MTAwNDg4MDIwIikgKyAgIyBoYXJkY29kZWQgVE1QTF9BRERSX0lEWCBhcyAwLCBzdWZmaXggMjAgaXMgbGVuZ3RoIG9mIGJlbG93IGJ5dGVzCiAgICAvLyBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJ5dGVzICsgICMgVE1QTF9FTUlUVEVSX0lECiAgICAvLyBCeXRlcy5mcm9tX2hleCgiNDgzMTEwODEwNjEyNDQzMTE5MjIxMjQ0MzExODgxIikgKwogICAgLy8gc2VsZi5fZW5jb2RlX3V2YXJpbnQoc2VsZi53b3JtaG9sZV9jb3JlLnZhbHVlKSArICAjIFRNUExfQVBQX0lECiAgICAvLyBCeXRlcy5mcm9tX2hleCgiMTI0NDMxMjA4MDIwIikgKyAgIyBzdWZmaXggMjAgaXMgbGVuZ3RoIG9mIGJlbG93IGJ5dGVzCiAgICBjb25jYXQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNDctMjUzCiAgICAvLyBCeXRlcyhiIlByb2dyYW0iKSArCiAgICAvLyBCeXRlcy5mcm9tX2hleCgiMDYyMDAxMDE4MTAwNDg4MDIwIikgKyAgIyBoYXJkY29kZWQgVE1QTF9BRERSX0lEWCBhcyAwLCBzdWZmaXggMjAgaXMgbGVuZ3RoIG9mIGJlbG93IGJ5dGVzCiAgICAvLyBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJ5dGVzICsgICMgVE1QTF9FTUlUVEVSX0lECiAgICAvLyBCeXRlcy5mcm9tX2hleCgiNDgzMTEwODEwNjEyNDQzMTE5MjIxMjQ0MzExODgxIikgKwogICAgLy8gc2VsZi5fZW5jb2RlX3V2YXJpbnQoc2VsZi53b3JtaG9sZV9jb3JlLnZhbHVlKSArICAjIFRNUExfQVBQX0lECiAgICAvLyBCeXRlcy5mcm9tX2hleCgiMTI0NDMxMjA4MDIwIikgKyAgIyBzdWZmaXggMjAgaXMgbGVuZ3RoIG9mIGJlbG93IGJ5dGVzCiAgICAvLyB3b3JtaG9sZV9jb3JlX2FkZHJlc3MuYnl0ZXMgKyAgIyBUTVBMX0FQUF9BRERSRVNTCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNTQKICAgIC8vIEJ5dGVzLmZyb21faGV4KCIxMjQ0MzEwMTgxMDAxMjQ0MzEwOTMyMDMxMjQ0MzExNTMyMDMxMjQ0MjIiKQogICAgcHVzaGJ5dGVzIDB4MTI0NDMxMDE4MTAwMTI0NDMxMDkzMjAzMTI0NDMxMTUzMjAzMTI0NDIyCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjQ3LTI1NAogICAgLy8gQnl0ZXMoYiJQcm9ncmFtIikgKwogICAgLy8gQnl0ZXMuZnJvbV9oZXgoIjA2MjAwMTAxODEwMDQ4ODAyMCIpICsgICMgaGFyZGNvZGVkIFRNUExfQUREUl9JRFggYXMgMCwgc3VmZml4IDIwIGlzIGxlbmd0aCBvZiBiZWxvdyBieXRlcwogICAgLy8gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5ieXRlcyArICAjIFRNUExfRU1JVFRFUl9JRAogICAgLy8gQnl0ZXMuZnJvbV9oZXgoIjQ4MzExMDgxMDYxMjQ0MzExOTIyMTI0NDMxMTg4MSIpICsKICAgIC8vIHNlbGYuX2VuY29kZV91dmFyaW50KHNlbGYud29ybWhvbGVfY29yZS52YWx1ZSkgKyAgIyBUTVBMX0FQUF9JRAogICAgLy8gQnl0ZXMuZnJvbV9oZXgoIjEyNDQzMTIwODAyMCIpICsgICMgc3VmZml4IDIwIGlzIGxlbmd0aCBvZiBiZWxvdyBieXRlcwogICAgLy8gd29ybWhvbGVfY29yZV9hZGRyZXNzLmJ5dGVzICsgICMgVE1QTF9BUFBfQUREUkVTUwogICAgLy8gQnl0ZXMuZnJvbV9oZXgoIjEyNDQzMTAxODEwMDEyNDQzMTA5MzIwMzEyNDQzMTE1MzIwMzEyNDQyMiIpCiAgICBjb25jYXQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNDYtMjU1CiAgICAvLyByZXR1cm4gQWRkcmVzcy5mcm9tX2J5dGVzKG9wLnNoYTUxMl8yNTYoCiAgICAvLyAgICAgQnl0ZXMoYiJQcm9ncmFtIikgKwogICAgLy8gICAgIEJ5dGVzLmZyb21faGV4KCIwNjIwMDEwMTgxMDA0ODgwMjAiKSArICAjIGhhcmRjb2RlZCBUTVBMX0FERFJfSURYIGFzIDAsIHN1ZmZpeCAyMCBpcyBsZW5ndGggb2YgYmVsb3cgYnl0ZXMKICAgIC8vICAgICBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJ5dGVzICsgICMgVE1QTF9FTUlUVEVSX0lECiAgICAvLyAgICAgQnl0ZXMuZnJvbV9oZXgoIjQ4MzExMDgxMDYxMjQ0MzExOTIyMTI0NDMxMTg4MSIpICsKICAgIC8vICAgICBzZWxmLl9lbmNvZGVfdXZhcmludChzZWxmLndvcm1ob2xlX2NvcmUudmFsdWUpICsgICMgVE1QTF9BUFBfSUQKICAgIC8vICAgICBCeXRlcy5mcm9tX2hleCgiMTI0NDMxMjA4MDIwIikgKyAgIyBzdWZmaXggMjAgaXMgbGVuZ3RoIG9mIGJlbG93IGJ5dGVzCiAgICAvLyAgICAgd29ybWhvbGVfY29yZV9hZGRyZXNzLmJ5dGVzICsgICMgVE1QTF9BUFBfQUREUkVTUwogICAgLy8gICAgIEJ5dGVzLmZyb21faGV4KCIxMjQ0MzEwMTgxMDAxMjQ0MzEwOTMyMDMxMjQ0MzExNTMyMDMxMjQ0MjIiKQogICAgLy8gKSkKICAgIHNoYTUxMl8yNTYKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weTo1OQogICAgLy8gc2VsZi5lbWl0dGVyX2xzaWcudmFsdWUgPSBzZWxmLl9jYWxjdWxhdGVfZW1pdHRlcl9sc2lnKCkKICAgIGJ5dGVjIDEzIC8vICJlbWl0dGVyX2xzaWciCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjQ3CiAgICAvLyBAYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NvbXBsZXRlX2NvbnRyYWN0X3VwZ3JhZGVfcm91dGVANDoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxNTcKICAgIC8vIEBhYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIlVwZGF0ZUFwcGxpY2F0aW9uIl0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBwdXNoaW50IDQgLy8gVXBkYXRlQXBwbGljYXRpb24KICAgID09CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgJiYKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBVcGRhdGVBcHBsaWNhdGlvbiAmJiBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxOTkKICAgIC8vIHJldHVybiBCeXRlczE2LmZyb21fYnl0ZXMob3AuZXh0cmFjdChvcC5rZWNjYWsyNTYoYiJVUEdSQURFQUJMRV9BRE1JTiIpLCAwLCBjb25zdC5CWVRFUzE2X0xFTkdUSCkpCiAgICBieXRlYyA1IC8vIDB4Y2Y4Y2QzMjdiOGEyZThlMDUxMmEzOTZkYmE5ZjAwN2IKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxNjgKICAgIC8vIHNlbGYuX2NoZWNrX3NlbmRlcl9yb2xlKHNlbGYudXBncmFkYWJsZV9hZG1pbl9yb2xlKCkpCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjM4CiAgICAvLyBleGlzdHMgPSBzZWxmLnNjaGVkdWxlZF9jb250cmFjdF91cGdyYWRlLm1heWJlKClbMV0KICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJzY2hlZHVsZWRfY29udHJhY3RfdXBncmFkZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgMTAKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMzkKICAgIC8vIGFzc2VydCBleGlzdHMsICJVcGdyYWRlIG5vdCBzY2hlZHVsZWQiCiAgICBhc3NlcnQgLy8gVXBncmFkZSBub3Qgc2NoZWR1bGVkCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTczCiAgICAvLyBhc3NlcnQgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgPj0gc2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUudGltZXN0YW1wLCAiU2NoZWR1bGUgY29tcGxldGUgdHMgbm90IG1ldCIKICAgIGV4dHJhY3QgMzIgOAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgYjw9CiAgICBhc3NlcnQgLy8gU2NoZWR1bGUgY29tcGxldGUgdHMgbm90IG1ldAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE3NS0xNzYKICAgIC8vICMgY2hlY2sgd2UgYXJlIHVwZ3JhZGluZyB0byBzYW1lIGNvbnRyYWN0CiAgICAvLyBwcm9ncmFtID0gQnl0ZXMoYiJhcHByb3ZhbCIpCiAgICBwdXNoYnl0ZXMgMHg2MTcwNzA3MjZmNzY2MTZjCiAgICBidXJ5IDkKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxNzcKICAgIC8vIGZvciBwYWdlX2luZGV4IGluIHVyYW5nZShUeG4ubnVtX2FwcHJvdmFsX3Byb2dyYW1fcGFnZXMpOgogICAgdHhuIE51bUFwcHJvdmFsUHJvZ3JhbVBhZ2VzCiAgICBidXJ5IDIKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDMKCm1haW5fZm9yX2hlYWRlckA3NzoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxNzcKICAgIC8vIGZvciBwYWdlX2luZGV4IGluIHVyYW5nZShUeG4ubnVtX2FwcHJvdmFsX3Byb2dyYW1fcGFnZXMpOgogICAgZGlnIDIKICAgIGRpZyAyCiAgICA8CiAgICBieiBtYWluX2FmdGVyX2ZvckA3OQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE3OAogICAgLy8gcHJvZ3JhbSArPSBvcC5zaGEyNTYoVHhuLmFwcHJvdmFsX3Byb2dyYW1fcGFnZXMocGFnZV9pbmRleCkpCiAgICBkaWcgMgogICAgZHVwCiAgICB0eG5hcyBBcHByb3ZhbFByb2dyYW1QYWdlcwogICAgc2hhMjU2CiAgICBkaWcgMTAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnVyeSAxMAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE3NwogICAgLy8gZm9yIHBhZ2VfaW5kZXggaW4gdXJhbmdlKFR4bi5udW1fYXBwcm92YWxfcHJvZ3JhbV9wYWdlcyk6CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAzCiAgICBiIG1haW5fZm9yX2hlYWRlckA3NwoKbWFpbl9hZnRlcl9mb3JANzk6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTc5CiAgICAvLyBwcm9ncmFtICs9IEJ5dGVzKGIiY2xlYXIiKQogICAgZGlnIDgKICAgIHB1c2hieXRlcyAweDYzNmM2NTYxNzIKICAgIGNvbmNhdAogICAgYnVyeSA5CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTgwCiAgICAvLyBmb3IgcGFnZV9pbmRleCBpbiB1cmFuZ2UoVHhuLm51bV9jbGVhcl9zdGF0ZV9wcm9ncmFtX3BhZ2VzKToKICAgIHR4biBOdW1DbGVhclN0YXRlUHJvZ3JhbVBhZ2VzCiAgICBidXJ5IDEKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDMKCm1haW5fZm9yX2hlYWRlckA4MDoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxODAKICAgIC8vIGZvciBwYWdlX2luZGV4IGluIHVyYW5nZShUeG4ubnVtX2NsZWFyX3N0YXRlX3Byb2dyYW1fcGFnZXMpOgogICAgZGlnIDIKICAgIGRpZyAxCiAgICA8CiAgICBieiBtYWluX2FmdGVyX2ZvckA4MgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE4MQogICAgLy8gcHJvZ3JhbSArPSBvcC5zaGEyNTYoVHhuLmNsZWFyX3N0YXRlX3Byb2dyYW1fcGFnZXMocGFnZV9pbmRleCkpCiAgICBkaWcgMgogICAgZHVwCiAgICB0eG5hcyBDbGVhclN0YXRlUHJvZ3JhbVBhZ2VzCiAgICBzaGEyNTYKICAgIGRpZyAxMAogICAgc3dhcAogICAgY29uY2F0CiAgICBidXJ5IDEwCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTgwCiAgICAvLyBmb3IgcGFnZV9pbmRleCBpbiB1cmFuZ2UoVHhuLm51bV9jbGVhcl9zdGF0ZV9wcm9ncmFtX3BhZ2VzKToKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDMKICAgIGIgbWFpbl9mb3JfaGVhZGVyQDgwCgptYWluX2FmdGVyX2ZvckA4MjoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxODIKICAgIC8vIHByb2dyYW1fc2hhMjU2ID0gQnl0ZXMzMi5mcm9tX2J5dGVzKG9wLnNoYTI1Nihwcm9ncmFtKSkKICAgIGRpZyA4CiAgICBzaGEyNTYKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxODMKICAgIC8vIGFzc2VydCBzY2hlZHVsZWRfY29udHJhY3RfdXBncmFkZS5wcm9ncmFtX3NoYTI1NiA9PSBwcm9ncmFtX3NoYTI1NiwgIkludmFsaWQgcHJvZ3JhbSBTSEEyNTYiCiAgICBkaWcgOAogICAgZXh0cmFjdCAwIDMyCiAgICBkaWcgMQogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIHByb2dyYW0gU0hBMjU2CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTg1LTE4NgogICAgLy8gIyByZXNldCB0byBuZXcgY29udHJhY3QgdmVyc2lvbgogICAgLy8gZGVsIHNlbGYuc2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUudmFsdWUKICAgIGJ5dGVjIDYgLy8gInNjaGVkdWxlZF9jb250cmFjdF91cGdyYWRlIgogICAgYXBwX2dsb2JhbF9kZWwKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxODcKICAgIC8vIHNlbGYudmVyc2lvbiArPSBVSW50NjQoMSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJ2ZXJzaW9uIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZlcnNpb24gZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWMgNyAvLyAidmVyc2lvbiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTg4CiAgICAvLyBzZWxmLmlzX2luaXRpYWxpc2VkID0gRmFsc2UKICAgIGJ5dGVjXzAgLy8gImlzX2luaXRpYWxpc2VkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTkwCiAgICAvLyBlbWl0KFVwZ3JhZGVDb21wbGV0ZWQocHJvZ3JhbV9zaGEyNTYsIEFSQzRVSW50NjQoc2VsZi52ZXJzaW9uKSkpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAidmVyc2lvbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52ZXJzaW9uIGV4aXN0cwogICAgaXRvYgogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHg5MjQyZGFmMSAvLyBtZXRob2QgIlVwZ3JhZGVDb21wbGV0ZWQoYnl0ZVszMl0sdWludDY0KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTU3CiAgICAvLyBAYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJVcGRhdGVBcHBsaWNhdGlvbiJdKQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIG50dF9jb250cmFjdHMudHJhbnNjZWl2ZXIuV29ybWhvbGVUcmFuc2NlaXZlci5Xb3JtaG9sZVRyYW5zY2VpdmVyLmdldF93b3JtaG9sZV9wZWVyKHBlZXJfY2hhaW5faWQ6IGJ5dGVzKSAtPiBieXRlczoKZ2V0X3dvcm1ob2xlX3BlZXI6CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MTI4LTEyOQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgLy8gZGVmIGdldF93b3JtaG9sZV9wZWVyKHNlbGYsIHBlZXJfY2hhaW5faWQ6IFVJbnQxNikgLT4gVW5pdmVyc2FsQWRkcmVzczoKICAgIHByb3RvIDEgMQogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjEzNQogICAgLy8gYXNzZXJ0IHBlZXJfY2hhaW5faWQgaW4gc2VsZi53b3JtaG9sZV9wZWVycywgZXJyLlBFRVJfQ0hBSU5fVU5LTk9XTgogICAgYnl0ZWMgMTYgLy8gMHg3NzZmNzI2ZDY4NmY2YzY1NWY3MDY1NjU3MjVmCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBVbmtub3duIHBlZXIgY2hhaW4KICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToxMzYKICAgIC8vIHJldHVybiBzZWxmLndvcm1ob2xlX3BlZXJzW3BlZXJfY2hhaW5faWRdCiAgICBib3hfZ2V0CiAgICBwb3AKICAgIHJldHN1YgoKCi8vIG50dF9jb250cmFjdHMudHJhbnNjZWl2ZXIuV29ybWhvbGVUcmFuc2NlaXZlci5Xb3JtaG9sZVRyYW5zY2VpdmVyLl9lbmNvZGVfdXZhcmludF9oZWxwZXIodmFsOiB1aW50NjQsIGI6IGJ5dGVzKSAtPiBieXRlczoKX2VuY29kZV91dmFyaW50X2hlbHBlcjoKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNjEtMjYyCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9lbmNvZGVfdXZhcmludF9oZWxwZXIoc2VsZiwgdmFsOiBVSW50NjQsIGI6IEJ5dGVzKSAtPiBCeXRlczoKICAgIHByb3RvIDIgMQogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9Xb3JtaG9sZVRyYW5zY2VpdmVyLnB5OjI2NwogICAgLy8gKSBpZiB2YWwgPj0gMTI4IGVsc2Ugb3AuZXh0cmFjdChvcC5pdG9iKHZhbCAmIDI1NSksIDcsIDEpCiAgICBmcmFtZV9kaWcgLTIKICAgIHB1c2hpbnQgMTI4IC8vIDEyOAogICAgPj0KICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNjQtMjY3CiAgICAvLyBzZWxmLl9lbmNvZGVfdXZhcmludF9oZWxwZXIoCiAgICAvLyAgICAgdmFsID4+IDcsCiAgICAvLyAgICAgb3AuZXh0cmFjdChvcC5pdG9iKCh2YWwgJiAyNTUpIHwgMTI4KSwgNywgMSkKICAgIC8vICkgaWYgdmFsID49IDEyOCBlbHNlIG9wLmV4dHJhY3Qob3AuaXRvYih2YWwgJiAyNTUpLCA3LCAxKQogICAgYnogX2VuY29kZV91dmFyaW50X2hlbHBlcl90ZXJuYXJ5X2ZhbHNlQDIKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNjUKICAgIC8vIHZhbCA+PiA3LAogICAgZnJhbWVfZGlnIC0yCiAgICBwdXNoaW50IDcgLy8gNwogICAgc2hyCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjY2CiAgICAvLyBvcC5leHRyYWN0KG9wLml0b2IoKHZhbCAmIDI1NSkgfCAxMjgpLCA3LCAxKQogICAgZnJhbWVfZGlnIC0yCiAgICBwdXNoaW50IDI1NSAvLyAyNTUKICAgICYKICAgIHB1c2hpbnQgMTI4IC8vIDEyOAogICAgfAogICAgaXRvYgogICAgZXh0cmFjdCA3IDEKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNjQtMjY3CiAgICAvLyBzZWxmLl9lbmNvZGVfdXZhcmludF9oZWxwZXIoCiAgICAvLyAgICAgdmFsID4+IDcsCiAgICAvLyAgICAgb3AuZXh0cmFjdChvcC5pdG9iKCh2YWwgJiAyNTUpIHwgMTI4KSwgNywgMSkKICAgIC8vICkgaWYgdmFsID49IDEyOCBlbHNlIG9wLmV4dHJhY3Qob3AuaXRvYih2YWwgJiAyNTUpLCA3LCAxKQogICAgY2FsbHN1YiBfZW5jb2RlX3V2YXJpbnRfaGVscGVyCgpfZW5jb2RlX3V2YXJpbnRfaGVscGVyX3Rlcm5hcnlfbWVyZ2VAMzoKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvV29ybWhvbGVUcmFuc2NlaXZlci5weToyNjMtMjY4CiAgICAvLyByZXR1cm4gYiArICgKICAgIC8vICAgICBzZWxmLl9lbmNvZGVfdXZhcmludF9oZWxwZXIoCiAgICAvLyAgICAgICAgIHZhbCA+PiA3LAogICAgLy8gICAgICAgICBvcC5leHRyYWN0KG9wLml0b2IoKHZhbCAmIDI1NSkgfCAxMjgpLCA3LCAxKQogICAgLy8gICAgICkgaWYgdmFsID49IDEyOCBlbHNlIG9wLmV4dHJhY3Qob3AuaXRvYih2YWwgJiAyNTUpLCA3LCAxKQogICAgLy8gKQogICAgZnJhbWVfZGlnIC0xCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHJldHN1YgoKX2VuY29kZV91dmFyaW50X2hlbHBlcl90ZXJuYXJ5X2ZhbHNlQDI6CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL1dvcm1ob2xlVHJhbnNjZWl2ZXIucHk6MjY3CiAgICAvLyApIGlmIHZhbCA+PSAxMjggZWxzZSBvcC5leHRyYWN0KG9wLml0b2IodmFsICYgMjU1KSwgNywgMSkKICAgIGZyYW1lX2RpZyAtMgogICAgcHVzaGludCAyNTUgLy8gMjU1CiAgICAmCiAgICBpdG9iCiAgICBleHRyYWN0IDcgMQogICAgYiBfZW5jb2RlX3V2YXJpbnRfaGVscGVyX3Rlcm5hcnlfbWVyZ2VAMwoKCi8vIGZvbGtzX2NvbnRyYWN0cy5saWJyYXJ5LlVwZ3JhZGVhYmxlLlVwZ3JhZGVhYmxlLmdldF9hY3RpdmVfbWluX3VwZ3JhZGVfZGVsYXkoKSAtPiB1aW50NjQ6CmdldF9hY3RpdmVfbWluX3VwZ3JhZGVfZGVsYXk6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjIwCiAgICAvLyBtaW5fdXBncmFkZV9kZWxheSA9IHNlbGYubWluX3VwZ3JhZGVfZGVsYXkudmFsdWUuY29weSgpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAibWluX3VwZ3JhZGVfZGVsYXkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm1pbl91cGdyYWRlX2RlbGF5IGV4aXN0cwogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIyMgogICAgLy8gbWluX3VwZ3JhZGVfZGVsYXkuZGVsYXlfMSBpZiBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCA+PSBtaW5fdXBncmFkZV9kZWxheS50aW1lc3RhbXAKICAgIGV4dHJhY3QgMTYgOAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgYjw9CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjIyLTIyMwogICAgLy8gbWluX3VwZ3JhZGVfZGVsYXkuZGVsYXlfMSBpZiBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCA+PSBtaW5fdXBncmFkZV9kZWxheS50aW1lc3RhbXAKICAgIC8vIGVsc2UgbWluX3VwZ3JhZGVfZGVsYXkuZGVsYXlfMAogICAgYnogZ2V0X2FjdGl2ZV9taW5fdXBncmFkZV9kZWxheV90ZXJuYXJ5X2ZhbHNlQDIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMjIKICAgIC8vIG1pbl91cGdyYWRlX2RlbGF5LmRlbGF5XzEgaWYgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgPj0gbWluX3VwZ3JhZGVfZGVsYXkudGltZXN0YW1wCiAgICBleHRyYWN0IDggOAoKZ2V0X2FjdGl2ZV9taW5fdXBncmFkZV9kZWxheV90ZXJuYXJ5X21lcmdlQDM6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjIxLTIyNAogICAgLy8gcmV0dXJuICgKICAgIC8vICAgICBtaW5fdXBncmFkZV9kZWxheS5kZWxheV8xIGlmIEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wID49IG1pbl91cGdyYWRlX2RlbGF5LnRpbWVzdGFtcAogICAgLy8gICAgIGVsc2UgbWluX3VwZ3JhZGVfZGVsYXkuZGVsYXlfMAogICAgLy8gKS5hc191aW50NjQoKQogICAgYnRvaQogICAgcmV0c3ViCgpnZXRfYWN0aXZlX21pbl91cGdyYWRlX2RlbGF5X3Rlcm5hcnlfZmFsc2VAMjoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMjMKICAgIC8vIGVsc2UgbWluX3VwZ3JhZGVfZGVsYXkuZGVsYXlfMAogICAgZXh0cmFjdCAwIDgKICAgIGIgZ2V0X2FjdGl2ZV9taW5fdXBncmFkZV9kZWxheV90ZXJuYXJ5X21lcmdlQDMKCgovLyBmb2xrc19jb250cmFjdHMubGlicmFyeS5VcGdyYWRlYWJsZS5VcGdyYWRlYWJsZS5fY2hlY2tfc2NoZWR1bGVfdGltZXN0YW1wKHRpbWVzdGFtcDogdWludDY0KSAtPiB2b2lkOgpfY2hlY2tfc2NoZWR1bGVfdGltZXN0YW1wOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIzMC0yMzEKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgX2NoZWNrX3NjaGVkdWxlX3RpbWVzdGFtcChzZWxmLCB0aW1lc3RhbXA6IFVJbnQ2NCkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIzMwogICAgLy8gdGltZXN0YW1wID49IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wICsgc2VsZi5nZXRfYWN0aXZlX21pbl91cGdyYWRlX2RlbGF5KCkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGNhbGxzdWIgZ2V0X2FjdGl2ZV9taW5fdXBncmFkZV9kZWxheQogICAgKwogICAgZnJhbWVfZGlnIC0xCiAgICA8PQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIzMi0yMzQKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgdGltZXN0YW1wID49IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wICsgc2VsZi5nZXRfYWN0aXZlX21pbl91cGdyYWRlX2RlbGF5KCkKICAgIC8vICksICJNdXN0IHNjaGVkdWxlIGF0IGxlYXN0IG1pbiB1cGdyYWRlIGRlbGF5IHRpbWUgaW4gZnV0dXJlIgogICAgYXNzZXJ0IC8vIE11c3Qgc2NoZWR1bGUgYXQgbGVhc3QgbWluIHVwZ3JhZGUgZGVsYXkgdGltZSBpbiBmdXR1cmUKICAgIHJldHN1YgoKCi8vIGZvbGtzX2NvbnRyYWN0cy5saWJyYXJ5LkFjY2Vzc0NvbnRyb2wuQWNjZXNzQ29udHJvbC5oYXNfcm9sZShyb2xlOiBieXRlcywgYWNjb3VudDogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlczoKaGFzX3JvbGU6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxMTEtMTEyCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgaGFzX3JvbGUoc2VsZiwgcm9sZTogQnl0ZXMxNiwgYWNjb3VudDogQWRkcmVzcykgLT4gQm9vbDoKICAgIHByb3RvIDIgMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTU1CiAgICAvLyByZXR1cm4gQWRkcmVzc1JvbGVLZXkocm9sZS5jb3B5KCksIGFjY291bnQpCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxMjMKICAgIC8vIHJldHVybiBCb29sKGFkZHJlc3Nfcm9sZV9rZXkgaW4gc2VsZi5hZGRyZXNzZXNfcm9sZXMpIGFuZCBzZWxmLmFkZHJlc3Nlc19yb2xlc1thZGRyZXNzX3JvbGVfa2V5XQogICAgYnl0ZWMgMTAgLy8gMHg2MTY0NjQ3MjY1NzM3MzVmNzI2ZjZjNjU3MzVmCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgZHVwCiAgICBieXRlY18xIC8vIDB4MDAKICAgID09CiAgICBieiBoYXNfcm9sZV90ZXJuYXJ5X2ZhbHNlQDQKICAgIGZyYW1lX2RpZyAxCgpoYXNfcm9sZV90ZXJuYXJ5X21lcmdlQDU6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxMjMKICAgIC8vIHJldHVybiBCb29sKGFkZHJlc3Nfcm9sZV9rZXkgaW4gc2VsZi5hZGRyZXNzZXNfcm9sZXMpIGFuZCBzZWxmLmFkZHJlc3Nlc19yb2xlc1thZGRyZXNzX3JvbGVfa2V5XQogICAgZnJhbWVfZGlnIC0yCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgMwogICAgcmV0c3ViCgpoYXNfcm9sZV90ZXJuYXJ5X2ZhbHNlQDQ6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxMjMKICAgIC8vIHJldHVybiBCb29sKGFkZHJlc3Nfcm9sZV9rZXkgaW4gc2VsZi5hZGRyZXNzZXNfcm9sZXMpIGFuZCBzZWxmLmFkZHJlc3Nlc19yb2xlc1thZGRyZXNzX3JvbGVfa2V5XQogICAgZnJhbWVfZGlnIDAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFkZHJlc3Nlc19yb2xlcyBlbnRyeSBleGlzdHMKICAgIGIgaGFzX3JvbGVfdGVybmFyeV9tZXJnZUA1CgoKLy8gZm9sa3NfY29udHJhY3RzLmxpYnJhcnkuQWNjZXNzQ29udHJvbC5BY2Nlc3NDb250cm9sLmdldF9yb2xlX2FkbWluKHJvbGU6IGJ5dGVzKSAtPiBieXRlcywgYnl0ZXM6CmdldF9yb2xlX2FkbWluOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTI1LTEyNgogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgLy8gZGVmIGdldF9yb2xlX2FkbWluKHNlbGYsIHJvbGU6IEJ5dGVzMTYpIC0+IEJ5dGVzMTY6CiAgICBwcm90byAxIDIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjEzNQogICAgLy8gaWYgcm9sZSBub3QgaW4gc2VsZi5yb2xlczoKICAgIHB1c2hieXRlcyAweDcyNmY2YzY1NWYKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYm56IGdldF9yb2xlX2FkbWluX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTA5CiAgICAvLyByZXR1cm4gQnl0ZXMxNi5mcm9tX2J5dGVzKG9wLmJ6ZXJvKGNvbnN0LkJZVEVTMTZfTEVOR1RIKSkKICAgIGludGNfMiAvLyAxNgogICAgYnplcm8KICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjEzNgogICAgLy8gcmV0dXJuIHNlbGYuZGVmYXVsdF9hZG1pbl9yb2xlKCkKICAgIGZyYW1lX2RpZyAtMQogICAgdW5jb3ZlciAyCiAgICByZXRzdWIKCmdldF9yb2xlX2FkbWluX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjEzNwogICAgLy8gcmV0dXJuIHNlbGYucm9sZXNbcm9sZV0KICAgIGZyYW1lX2RpZyAwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb2xlcyBlbnRyeSBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgdW5jb3ZlciAyCiAgICByZXRzdWIKCgovLyBmb2xrc19jb250cmFjdHMubGlicmFyeS5BY2Nlc3NDb250cm9sLkFjY2Vzc0NvbnRyb2wuX2NoZWNrX3NlbmRlcl9yb2xlKHJvbGU6IGJ5dGVzKSAtPiBieXRlczoKX2NoZWNrX3NlbmRlcl9yb2xlOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTU3LTE1OAogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBfY2hlY2tfc2VuZGVyX3JvbGUoc2VsZiwgcm9sZTogQnl0ZXMxNikgLT4gTm9uZToKICAgIHByb3RvIDEgMQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTYzCiAgICAvLyBhc3NlcnQgc2VsZi5oYXNfcm9sZShyb2xlLCBhY2NvdW50KSwgIkFjY2VzcyBjb250cm9sIHVuYXV0aG9yaXNlZCBhY2NvdW50IgogICAgZnJhbWVfZGlnIC0xCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNTkKICAgIC8vIHNlbGYuX2NoZWNrX3JvbGUocm9sZSwgQWRkcmVzcyhUeG4uc2VuZGVyKSkKICAgIHR4biBTZW5kZXIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjE2MwogICAgLy8gYXNzZXJ0IHNlbGYuaGFzX3JvbGUocm9sZSwgYWNjb3VudCksICJBY2Nlc3MgY29udHJvbCB1bmF1dGhvcmlzZWQgYWNjb3VudCIKICAgIGNhbGxzdWIgaGFzX3JvbGUKICAgIGZyYW1lX2J1cnkgLTEKICAgIGJ5dGVjXzEgLy8gMHgwMAogICAgIT0KICAgIGFzc2VydCAvLyBBY2Nlc3MgY29udHJvbCB1bmF1dGhvcmlzZWQgYWNjb3VudAogICAgZnJhbWVfZGlnIC0xCiAgICByZXRzdWIKCgovLyBmb2xrc19jb250cmFjdHMubGlicmFyeS5BY2Nlc3NDb250cm9sLkFjY2Vzc0NvbnRyb2wuX2dyYW50X3JvbGUocm9sZTogYnl0ZXMsIGFjY291bnQ6IGJ5dGVzKSAtPiBieXRlcywgYnl0ZXM6Cl9ncmFudF9yb2xlOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTY1LTE2NgogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBfZ3JhbnRfcm9sZShzZWxmLCByb2xlOiBCeXRlczE2LCBhY2NvdW50OiBBZGRyZXNzKSAtPiBCb29sOgogICAgcHJvdG8gMiAyCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNjctMTY4CiAgICAvLyAjIGdyYW50IHJvbGUgdG8gYWNjb3VudCBpZiBpdCBkb2Vzbid0IGhhdmUKICAgIC8vIGlmIG5vdCBzZWxmLmhhc19yb2xlKHJvbGUsIGFjY291bnQpOgogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgaGFzX3JvbGUKICAgIGZyYW1lX2J1cnkgLTIKICAgIGJ5dGVjXzEgLy8gMHgwMAogICAgPT0KICAgIGJ6IF9ncmFudF9yb2xlX2Vsc2VfYm9keUA2CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNTUKICAgIC8vIHJldHVybiBBZGRyZXNzUm9sZUtleShyb2xlLmNvcHkoKSwgYWNjb3VudCkKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjE3MAogICAgLy8gc2VsZi5hZGRyZXNzZXNfcm9sZXNbYWRkcmVzc19yb2xlX2tleV0gPSBCb29sKFRydWUpCiAgICBieXRlYyAxMCAvLyAweDYxNjQ2NDcyNjU3MzczNWY3MjZmNmM2NTczNWYKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGJ5dGVjIDggLy8gMHg4MAogICAgYm94X3B1dAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTcxCiAgICAvLyBlbWl0KFJvbGVHcmFudGVkKHJvbGUsIGFjY291bnQsIEFkZHJlc3MoVHhuLnNlbmRlcikpKQogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHg0ODY4MGI5NSAvLyBtZXRob2QgIlJvbGVHcmFudGVkKGJ5dGVbMTZdLGFkZHJlc3MsYWRkcmVzcykiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTcwCiAgICAvLyBzZWxmLmFkZHJlc3Nlc19yb2xlc1thZGRyZXNzX3JvbGVfa2V5XSA9IEJvb2woVHJ1ZSkKICAgIGJ5dGVjIDggLy8gMHg4MAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTcyCiAgICAvLyByZXR1cm4gQm9vbChUcnVlKQogICAgZnJhbWVfZGlnIC0yCiAgICByZXRzdWIKCl9ncmFudF9yb2xlX2Vsc2VfYm9keUA2OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTY3LTE2OAogICAgLy8gIyBncmFudCByb2xlIHRvIGFjY291bnQgaWYgaXQgZG9lc24ndCBoYXZlCiAgICAvLyBpZiBub3Qgc2VsZi5oYXNfcm9sZShyb2xlLCBhY2NvdW50KToKICAgIGJ5dGVjXzEgLy8gMHgwMAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTc0CiAgICAvLyByZXR1cm4gQm9vbChGYWxzZSkKICAgIGZyYW1lX2RpZyAtMgogICAgcmV0c3ViCgoKLy8gZm9sa3NfY29udHJhY3RzLmxpYnJhcnkuQWNjZXNzQ29udHJvbC5BY2Nlc3NDb250cm9sLl9yZXZva2Vfcm9sZShyb2xlOiBieXRlcywgYWNjb3VudDogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlczoKX3Jldm9rZV9yb2xlOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTc2LTE3NwogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBfcmV2b2tlX3JvbGUoc2VsZiwgcm9sZTogQnl0ZXMxNiwgYWNjb3VudDogQWRkcmVzcykgLT4gQm9vbDoKICAgIHByb3RvIDIgMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTc4LTE3OQogICAgLy8gIyByZXZva2Ugcm9sZSBmcm9tIGFjY291bnQgaWYgaXQgZG9lcyBoYXZlCiAgICAvLyBpZiBzZWxmLmhhc19yb2xlKHJvbGUsIGFjY291bnQpOgogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgaGFzX3JvbGUKICAgIGZyYW1lX2J1cnkgLTIKICAgIGJ5dGVjXzEgLy8gMHgwMAogICAgIT0KICAgIGJ6IF9yZXZva2Vfcm9sZV9lbHNlX2JvZHlANgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTU1CiAgICAvLyByZXR1cm4gQWRkcmVzc1JvbGVLZXkocm9sZS5jb3B5KCksIGFjY291bnQpCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxODEKICAgIC8vIGRlbCBzZWxmLmFkZHJlc3Nlc19yb2xlc1thZGRyZXNzX3JvbGVfa2V5XQogICAgYnl0ZWMgMTAgLy8gMHg2MTY0NjQ3MjY1NzM3MzVmNzI2ZjZjNjU3MzVmCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjE4MgogICAgLy8gZW1pdChSb2xlUmV2b2tlZChyb2xlLCBhY2NvdW50LCBBZGRyZXNzKFR4bi5zZW5kZXIpKSkKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4OWI1YjNlNzMgLy8gbWV0aG9kICJSb2xlUmV2b2tlZChieXRlWzE2XSxhZGRyZXNzLGFkZHJlc3MpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjE4MwogICAgLy8gcmV0dXJuIEJvb2woVHJ1ZSkKICAgIGJ5dGVjIDggLy8gMHg4MAogICAgZnJhbWVfZGlnIC0yCiAgICByZXRzdWIKCl9yZXZva2Vfcm9sZV9lbHNlX2JvZHlANjoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjE3OC0xNzkKICAgIC8vICMgcmV2b2tlIHJvbGUgZnJvbSBhY2NvdW50IGlmIGl0IGRvZXMgaGF2ZQogICAgLy8gaWYgc2VsZi5oYXNfcm9sZShyb2xlLCBhY2NvdW50KToKICAgIGJ5dGVjXzEgLy8gMHgwMAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTg1CiAgICAvLyByZXR1cm4gQm9vbChGYWxzZSkKICAgIGZyYW1lX2RpZyAtMgogICAgcmV0c3ViCg==",
    clear:
      "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K",
  },
  byteCode: {
    approval:
      "CyAFAAEQIIDqSSYSDmlzX2luaXRpYWxpc2VkAQARbWluX3VwZ3JhZGVfZGVsYXkNd29ybWhvbGVfY29yZQQVH3x1EM+M0ye4oujgUSo5bbqfAHsac2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUHdmVyc2lvbgGAE3RyYW5zY2VpdmVyX21hbmFnZXIOYWRkcmVzc19yb2xlc18KTWVzc2FnZUZlZQSZRf8QDGVtaXR0ZXJfbHNpZxCvKQ2GgIIKrZIoVfObMGCXCGNoYWluX2lkDndvcm1ob2xlX3BlZXJfCAAAAAAAAAAAIkcJgABHAjEYQAAKKCJnJwcjZygiZ4AEj6OIizYaAI4BBf4xGRREMRhBBUOCFAQ9UmOzBF5zsLIE1uEWfwRv1sh0BLGUCAcEc9B5HQQULuBlBPYdPmQE4DTpawRWMxleBBCLaJcE/7iRSATZfOMQBH3tvNIE1zuiRARyujDuBA6U2/wEZ71SNwT9Yai+BFVXd/Y2GgCOFAR9BGoEMQL9AuQC0QKOAZABJwD1ANAAtwCmAJsAegBZAEgALwAUAAEANhoBSRUkEkSIBqJIJwRMULAjQzYaAUkVJBJENhoCSRUlEkSIBlxIJwRMULAjQ4AUFR98dQAAAAAAAAAAAAAAAAAAAACwI0M2GgFJFSQSRDEAiAbCRgIjQzYaAUkVJBJENhoCSRUlEkRMiAZBTIgGYUhMiAahRgIjQzYaAUkVJBJENhoCSRUlEkRMiAYgTIgGQEhMiAZNRgIjQ4gFuhYnBExQsCNDgAwVH3x1AAAAAAASdQCwI0OAFBUffHXPjNMnuKLo4FEqOW26nwB7sCNDIihlREQnBYgF+EgiJwZlRFcAICcGaTIHFlCABACmyPFMULAjQzYaAUkVJRJENhoCSRWBCBJESRciKGVERCcFiAXASIgFX1AnBksBZ4AEkIvFUUxQsCNDNhoBSUUHSRWBCBJEFzYaAklFB0kVgQgSRBciKGVERCcFiAWHSEwhBA5EiAUhIiplRFcQCDIHFqZBAA0iKmVESVcICFwAKkxnIiplREsGSU4CXAhLBklOAlwQKkxnUIAERX3590xQsCNDMRYjCUk4ECMSRDYaAUkVSwGBggFZSYGEARJESwJMSwJSSSJZgYYBCE8CEkRLAVcAIEsCVyAgSwNXQCBLBFdgAk8FV2IgNhoCSSJZgQIITBUSRCInCWVEcghEMQASREsGOAcyChJETwY4CEsCiAQVSCIrZUQnC2VESwESRCIoZURETwKIA/5ISwRPBFBPBVAnDE8EUE8DUEsBFRZJkyQORFcGAlBMUIACAABQIitlRElyCEQiFiInDWVESRUlEkSxTwWyCE8CsgcjshAisgG2shyADnB1Ymxpc2hNZXNzYWdlshpPArIashqyGIEGshAisgGzgATl0N83TFCwI0M2GgFJFUsBgYIBWUmBhAESREsCTEsCUiJZgYYBCBJEV2ACNhoCSSJZgQIITBUSRIgDVEgiK2VEJwtlRBYnBExQsCNDNhoBSRWBAhJEiAM3JwRMULAjQ4AUFR98da8pDYaAggqtkihV85swYJewI0MxFiMJSTgQgQYSRCIoZURESTgYIitlRBJESTgZFERJIsIagAl2ZXJpZnlWQUESRCPCGkmBBVWBQguBBghLARVLAksCSwJSAgJJTgRFCEyBCAhLAksBWRZJkyQORFcGAklOBEURgQIISwJLASVYTIEpCE4CTgNSSVcABCcMEkRJVwQgRQtJVyQgRQ9JgURZgUYIgUZMUkUNTIgCfBJEgA52YWFzX2NvbnN1bWVkX0xQSUUOvUUBKSJPAlQpE0EAcUsMvkQpE0EAaCMUREsMJwi/SwlJVwAgSwFXICBLAhVLA1dAAE8EgUBZTwKBQAmBAgkSRLFLAk8CUEsOUEsJUEsNUIACAIRQTFAiJwllRLIYgASx/Ee4shqyGoEGshAisgGzSwRMUIAEYIjgzExQsCNDIkL/lTYaAUkVgQISRDYaAkkVJRJEIihlREQnDogChkgiJw9lREsCqUQnEEsCUEsBv1CABPWoZGNMULAjQ4AOFR98dQAId29ybWhvbGWwI0M2GgFJFSUSRDEAMgkSRCIoZUQURCgjZySvSwGIAklGAicFSwGIAkBGAicOTIgCOEYCI0OABF04pbg2GgCOAQABADYaAUkVgQgSRBc2GgJJFYEIEkQXNhoDSRWBAhJENhoESRWBCBJESRchBA5EJxFMUCcRUCpMZycJTwNnK08CZycPTGciK2VESXIIRIAQUHJvZ3JhbQYgAQGBAEiAIDIKUIAPSDEQgQYSRDEZIhJEMRiBUE8CgACIAO1QgAYSRDEggCBQTFCAFRJEMQGBABJEMQkyAxJEMRUyAxJEIlADJw1MZyNDMRmBBBIxGBBEIihlREQnBYgBXUgiJwZlTElOAkUKRFcgCDIHFqZEgAhhcHByb3ZhbEUJMUFFAiJFA0sCSwIMQQATSwJJwEABSwpMUEUKIwhFA0L/5UsIgAVjbGVhclBFCTFDRQEiRQNLAksBDEEAE0sCScBCAUsKTFBFCiMIRQNC/+VLCAFLCFcAIEsBEkQnBmkiJwdlRCMIJwdMZygiZyInB2VEFlCABJJC2vFMULAjQ4oBAScQi/9QSb1FAUS+SImKAgGL/oGAAQ9BABuL/oEHkYv+gf8BGoGAARkWVwcBiP/ei/9MUImL/oH/ARoWVwcBQv/uIiplTElPAkRXEAgyBxamQQAFVwgIF4lXAAhC//iKAQAyB4j/2wiL/w5EiYoCAov+i/9QJwpMUEm9RQEpIk8CVEkpEkEACYsBi/5PA08DiYsAvkRC//KKAQKABXJvbGVfi/9QSb1FAUAABySvi/9PAomLAL5Ei/9PAomKAQGL/zEAiP+njP8pE0SL/4mKAgKL/ov/iP+VjP4pEkEAHov+i/9QJwpLAVAnCL8xAFCABEhoC5VMULAnCIv+iSmL/omKAgKL/ov/iP9ijP4pE0EAHYv+i/9QJwpLAVC8SDEAUIAEm1s+c0xQsCcIi/6JKYv+iQ==",
    clear: "C4EBQw==",
  },
  events: [
    {
      name: "RoleGranted",
      args: [
        { type: "byte[16]", name: "role" },
        { type: "address", name: "account" },
        { type: "address", name: "sender" },
      ],
    },
    {
      name: "WormholePeerSet",
      args: [
        { type: "uint16", name: "peer_chain_id" },
        { type: "byte[32]", name: "peer_contract_address" },
      ],
    },
    {
      name: "ReceivedMessage",
      args: [
        { type: "byte[32]", name: "vaa_digest" },
        { type: "byte[32]", name: "message_id" },
      ],
    },
    { name: "MessageSent", args: [{ type: "byte[32]", name: "message_id" }] },
    {
      name: "MinimumUpgradeDelayChange",
      args: [
        { type: "uint64", name: "delay" },
        { type: "uint64", name: "timestamp" },
      ],
    },
    {
      name: "UpgradeScheduled",
      args: [
        { type: "byte[32]", name: "program_sha256" },
        { type: "uint64", name: "timestamp" },
      ],
    },
    {
      name: "UpgradeCancelled",
      args: [
        { type: "byte[32]", name: "program_sha256" },
        { type: "uint64", name: "timestamp" },
      ],
    },
    {
      name: "UpgradeCompleted",
      args: [
        { type: "byte[32]", name: "program_sha256" },
        { type: "uint64", name: "version" },
      ],
    },
    {
      name: "RoleRevoked",
      args: [
        { type: "byte[16]", name: "role" },
        { type: "address", name: "account" },
        { type: "address", name: "sender" },
      ],
    },
  ],
  templateVariables: {},
} as unknown as Arc56Contract;

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined;
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined;
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value;
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString("utf-8") : undefined;
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never;

// Type definitions for ARC-56 structs

export type AddressRoleKey = {
  role: Uint8Array;
  address: string;
};

/**
 * Converts the ABI tuple representation of a AddressRoleKey to the struct representation
 */
export function AddressRoleKeyFromTuple(abiTuple: [Uint8Array, string]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.AddressRoleKey, APP_SPEC.structs) as AddressRoleKey;
}

export type MinimumUpgradeDelay = {
  delay_0: bigint;
  delay_1: bigint;
  timestamp: bigint;
};

/**
 * Converts the ABI tuple representation of a MinimumUpgradeDelay to the struct representation
 */
export function MinimumUpgradeDelayFromTuple(abiTuple: [bigint, bigint, bigint]) {
  return getABIStructFromABITuple(
    abiTuple,
    APP_SPEC.structs.MinimumUpgradeDelay,
    APP_SPEC.structs,
  ) as MinimumUpgradeDelay;
}

export type ScheduledContractUpgrade = {
  programSha256: Uint8Array;
  timestamp: bigint;
};

/**
 * Converts the ABI tuple representation of a ScheduledContractUpgrade to the struct representation
 */
export function ScheduledContractUpgradeFromTuple(abiTuple: [Uint8Array, bigint]) {
  return getABIStructFromABITuple(
    abiTuple,
    APP_SPEC.structs.ScheduledContractUpgrade,
    APP_SPEC.structs,
  ) as ScheduledContractUpgrade;
}

export type MessageToSend = {
  id: Uint8Array;
  userAddress: Uint8Array;
  sourceAddress: Uint8Array;
  destinationChainId: number;
  handlerAddress: Uint8Array;
  payload: Uint8Array;
};

/**
 * Converts the ABI tuple representation of a MessageToSend to the struct representation
 */
export function MessageToSendFromTuple(abiTuple: [Uint8Array, Uint8Array, Uint8Array, number, Uint8Array, Uint8Array]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.MessageToSend, APP_SPEC.structs) as MessageToSend;
}

/**
 * The argument types for the WormholeTransceiver contract
 */
export type WormholeTransceiverArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    "create(uint64,uint64,uint16,uint64)void": {
      transceiverManager: bigint | number;
      wormholeCore: bigint | number;
      chainId: bigint | number;
      minUpgradeDelay: bigint | number;
    };
    "initialise(address)void": {
      admin: string;
    };
    "get_transceiver_type()string": Record<string, never>;
    "set_wormhole_peer(uint16,byte[32])void": {
      /**
       * The peer chain to set
       */
      peerChainId: bigint | number;
      /**
       * The peer contract address
       */
      peerContractAddress: Uint8Array;
    };
    "receive_message(appl)void": {
      /**
       * The call to Wormhole call to verify the VAA
       */
      verifyVaa: AppMethodCallTransactionArgument;
    };
    "manager_role()byte[16]": Record<string, never>;
    "get_wormhole_peer(uint16)byte[32]": {
      /**
       * The peer chain to get the address of
       */
      peerChainId: bigint | number;
    };
    "quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64": {
      message: MessageToSend;
      transceiverInstruction: Uint8Array;
    };
    "send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void": {
      feePayment: AppMethodCallTransactionArgument;
      message: MessageToSend;
      transceiverInstruction: Uint8Array;
    };
    "update_min_upgrade_delay(uint64,uint64)void": {
      /**
       * The new delay
       */
      minUpgradeDelay: bigint | number;
      /**
       * The timestamp to schedule the change
       */
      timestamp: bigint | number;
    };
    "schedule_contract_upgrade(byte[32],uint64)void": {
      /**
       * The SHA256 of the new program
       */
      programSha256: Uint8Array;
      /**
       * The timestamp to schedule the upgrade
       */
      timestamp: bigint | number;
    };
    "cancel_contract_upgrade()void": Record<string, never>;
    "complete_contract_upgrade()void": Record<string, never>;
    "upgradable_admin_role()byte[16]": Record<string, never>;
    "max_for_min_upgrade_delay()uint64": Record<string, never>;
    "get_active_min_upgrade_delay()uint64": Record<string, never>;
    "grant_role(byte[16],address)void": {
      /**
       * The role to grant
       */
      role: Uint8Array;
      /**
       * The account to grant the role to
       */
      account: string;
    };
    "revoke_role(byte[16],address)void": {
      /**
       * The role to revoke
       */
      role: Uint8Array;
      /**
       * The account to revoke the role from
       */
      account: string;
    };
    "renounce_role(byte[16])void": {
      /**
       * The role to renounce
       */
      role: Uint8Array;
    };
    "default_admin_role()byte[16]": Record<string, never>;
    "has_role(byte[16],address)bool": {
      /**
       * The role to check
       */
      role: Uint8Array;
      /**
       * The account to check
       */
      account: string;
    };
    "get_role_admin(byte[16])byte[16]": {
      /**
       * The role to get its admin of
       */
      role: Uint8Array;
    };
  };
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    "create(uint64,uint64,uint16,uint64)void": [
      transceiverManager: bigint | number,
      wormholeCore: bigint | number,
      chainId: bigint | number,
      minUpgradeDelay: bigint | number,
    ];
    "initialise(address)void": [admin: string];
    "get_transceiver_type()string": [];
    "set_wormhole_peer(uint16,byte[32])void": [peerChainId: bigint | number, peerContractAddress: Uint8Array];
    "receive_message(appl)void": [verifyVaa: AppMethodCallTransactionArgument];
    "manager_role()byte[16]": [];
    "get_wormhole_peer(uint16)byte[32]": [peerChainId: bigint | number];
    "quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64": [
      message: MessageToSend,
      transceiverInstruction: Uint8Array,
    ];
    "send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void": [
      feePayment: AppMethodCallTransactionArgument,
      message: MessageToSend,
      transceiverInstruction: Uint8Array,
    ];
    "update_min_upgrade_delay(uint64,uint64)void": [minUpgradeDelay: bigint | number, timestamp: bigint | number];
    "schedule_contract_upgrade(byte[32],uint64)void": [programSha256: Uint8Array, timestamp: bigint | number];
    "cancel_contract_upgrade()void": [];
    "complete_contract_upgrade()void": [];
    "upgradable_admin_role()byte[16]": [];
    "max_for_min_upgrade_delay()uint64": [];
    "get_active_min_upgrade_delay()uint64": [];
    "grant_role(byte[16],address)void": [role: Uint8Array, account: string];
    "revoke_role(byte[16],address)void": [role: Uint8Array, account: string];
    "renounce_role(byte[16])void": [role: Uint8Array];
    "default_admin_role()byte[16]": [];
    "has_role(byte[16],address)bool": [role: Uint8Array, account: string];
    "get_role_admin(byte[16])byte[16]": [role: Uint8Array];
  };
};

/**
 * The return type for each method
 */
export type WormholeTransceiverReturns = {
  "create(uint64,uint64,uint16,uint64)void": void;
  "initialise(address)void": void;
  "get_transceiver_type()string": string;
  "set_wormhole_peer(uint16,byte[32])void": void;
  "receive_message(appl)void": void;
  "manager_role()byte[16]": Uint8Array;
  "get_wormhole_peer(uint16)byte[32]": Uint8Array;
  "quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64": bigint;
  "send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void": void;
  "update_min_upgrade_delay(uint64,uint64)void": void;
  "schedule_contract_upgrade(byte[32],uint64)void": void;
  "cancel_contract_upgrade()void": void;
  "complete_contract_upgrade()void": void;
  "upgradable_admin_role()byte[16]": Uint8Array;
  "max_for_min_upgrade_delay()uint64": bigint;
  "get_active_min_upgrade_delay()uint64": bigint;
  "grant_role(byte[16],address)void": void;
  "revoke_role(byte[16],address)void": void;
  "renounce_role(byte[16])void": void;
  "default_admin_role()byte[16]": Uint8Array;
  "has_role(byte[16],address)bool": boolean;
  "get_role_admin(byte[16])byte[16]": Uint8Array;
};

/**
 * Defines the types of available calls and state of the WormholeTransceiver smart contract.
 */
export type WormholeTransceiverTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods: Record<
    "create(uint64,uint64,uint16,uint64)void" | "create",
    {
      argsObj: WormholeTransceiverArgs["obj"]["create(uint64,uint64,uint16,uint64)void"];
      argsTuple: WormholeTransceiverArgs["tuple"]["create(uint64,uint64,uint16,uint64)void"];
      returns: WormholeTransceiverReturns["create(uint64,uint64,uint16,uint64)void"];
    }
  > &
    Record<
      "initialise(address)void" | "initialise",
      {
        argsObj: WormholeTransceiverArgs["obj"]["initialise(address)void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["initialise(address)void"];
        returns: WormholeTransceiverReturns["initialise(address)void"];
      }
    > &
    Record<
      "get_transceiver_type()string" | "get_transceiver_type",
      {
        argsObj: WormholeTransceiverArgs["obj"]["get_transceiver_type()string"];
        argsTuple: WormholeTransceiverArgs["tuple"]["get_transceiver_type()string"];
        returns: WormholeTransceiverReturns["get_transceiver_type()string"];
      }
    > &
    Record<
      "set_wormhole_peer(uint16,byte[32])void" | "set_wormhole_peer",
      {
        argsObj: WormholeTransceiverArgs["obj"]["set_wormhole_peer(uint16,byte[32])void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["set_wormhole_peer(uint16,byte[32])void"];
        returns: WormholeTransceiverReturns["set_wormhole_peer(uint16,byte[32])void"];
      }
    > &
    Record<
      "receive_message(appl)void" | "receive_message",
      {
        argsObj: WormholeTransceiverArgs["obj"]["receive_message(appl)void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["receive_message(appl)void"];
        returns: WormholeTransceiverReturns["receive_message(appl)void"];
      }
    > &
    Record<
      "manager_role()byte[16]" | "manager_role",
      {
        argsObj: WormholeTransceiverArgs["obj"]["manager_role()byte[16]"];
        argsTuple: WormholeTransceiverArgs["tuple"]["manager_role()byte[16]"];
        returns: WormholeTransceiverReturns["manager_role()byte[16]"];
      }
    > &
    Record<
      "get_wormhole_peer(uint16)byte[32]" | "get_wormhole_peer",
      {
        argsObj: WormholeTransceiverArgs["obj"]["get_wormhole_peer(uint16)byte[32]"];
        argsTuple: WormholeTransceiverArgs["tuple"]["get_wormhole_peer(uint16)byte[32]"];
        returns: WormholeTransceiverReturns["get_wormhole_peer(uint16)byte[32]"];
      }
    > &
    Record<
      "quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64" | "quote_delivery_price",
      {
        argsObj: WormholeTransceiverArgs["obj"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"];
        argsTuple: WormholeTransceiverArgs["tuple"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"];
        returns: WormholeTransceiverReturns["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"];
      }
    > &
    Record<
      "send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void" | "send_message",
      {
        argsObj: WormholeTransceiverArgs["obj"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"];
        returns: WormholeTransceiverReturns["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"];
      }
    > &
    Record<
      "update_min_upgrade_delay(uint64,uint64)void" | "update_min_upgrade_delay",
      {
        argsObj: WormholeTransceiverArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"];
        returns: WormholeTransceiverReturns["update_min_upgrade_delay(uint64,uint64)void"];
      }
    > &
    Record<
      "schedule_contract_upgrade(byte[32],uint64)void" | "schedule_contract_upgrade",
      {
        argsObj: WormholeTransceiverArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"];
        returns: WormholeTransceiverReturns["schedule_contract_upgrade(byte[32],uint64)void"];
      }
    > &
    Record<
      "cancel_contract_upgrade()void" | "cancel_contract_upgrade",
      {
        argsObj: WormholeTransceiverArgs["obj"]["cancel_contract_upgrade()void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["cancel_contract_upgrade()void"];
        returns: WormholeTransceiverReturns["cancel_contract_upgrade()void"];
      }
    > &
    Record<
      "complete_contract_upgrade()void" | "complete_contract_upgrade",
      {
        argsObj: WormholeTransceiverArgs["obj"]["complete_contract_upgrade()void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["complete_contract_upgrade()void"];
        returns: WormholeTransceiverReturns["complete_contract_upgrade()void"];
      }
    > &
    Record<
      "upgradable_admin_role()byte[16]" | "upgradable_admin_role",
      {
        argsObj: WormholeTransceiverArgs["obj"]["upgradable_admin_role()byte[16]"];
        argsTuple: WormholeTransceiverArgs["tuple"]["upgradable_admin_role()byte[16]"];
        /**
         * Role bytes of length 16
         */
        returns: WormholeTransceiverReturns["upgradable_admin_role()byte[16]"];
      }
    > &
    Record<
      "max_for_min_upgrade_delay()uint64" | "max_for_min_upgrade_delay",
      {
        argsObj: WormholeTransceiverArgs["obj"]["max_for_min_upgrade_delay()uint64"];
        argsTuple: WormholeTransceiverArgs["tuple"]["max_for_min_upgrade_delay()uint64"];
        /**
         * The maximum minimum upgrade delay
         */
        returns: WormholeTransceiverReturns["max_for_min_upgrade_delay()uint64"];
      }
    > &
    Record<
      "get_active_min_upgrade_delay()uint64" | "get_active_min_upgrade_delay",
      {
        argsObj: WormholeTransceiverArgs["obj"]["get_active_min_upgrade_delay()uint64"];
        argsTuple: WormholeTransceiverArgs["tuple"]["get_active_min_upgrade_delay()uint64"];
        /**
         * The active minimum upgrade delay
         */
        returns: WormholeTransceiverReturns["get_active_min_upgrade_delay()uint64"];
      }
    > &
    Record<
      "grant_role(byte[16],address)void" | "grant_role",
      {
        argsObj: WormholeTransceiverArgs["obj"]["grant_role(byte[16],address)void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["grant_role(byte[16],address)void"];
        returns: WormholeTransceiverReturns["grant_role(byte[16],address)void"];
      }
    > &
    Record<
      "revoke_role(byte[16],address)void" | "revoke_role",
      {
        argsObj: WormholeTransceiverArgs["obj"]["revoke_role(byte[16],address)void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["revoke_role(byte[16],address)void"];
        returns: WormholeTransceiverReturns["revoke_role(byte[16],address)void"];
      }
    > &
    Record<
      "renounce_role(byte[16])void" | "renounce_role",
      {
        argsObj: WormholeTransceiverArgs["obj"]["renounce_role(byte[16])void"];
        argsTuple: WormholeTransceiverArgs["tuple"]["renounce_role(byte[16])void"];
        returns: WormholeTransceiverReturns["renounce_role(byte[16])void"];
      }
    > &
    Record<
      "default_admin_role()byte[16]" | "default_admin_role",
      {
        argsObj: WormholeTransceiverArgs["obj"]["default_admin_role()byte[16]"];
        argsTuple: WormholeTransceiverArgs["tuple"]["default_admin_role()byte[16]"];
        /**
         * Empty bytes of length 16
         */
        returns: WormholeTransceiverReturns["default_admin_role()byte[16]"];
      }
    > &
    Record<
      "has_role(byte[16],address)bool" | "has_role",
      {
        argsObj: WormholeTransceiverArgs["obj"]["has_role(byte[16],address)bool"];
        argsTuple: WormholeTransceiverArgs["tuple"]["has_role(byte[16],address)bool"];
        /**
         * Whether the account has been granted a role
         */
        returns: WormholeTransceiverReturns["has_role(byte[16],address)bool"];
      }
    > &
    Record<
      "get_role_admin(byte[16])byte[16]" | "get_role_admin",
      {
        argsObj: WormholeTransceiverArgs["obj"]["get_role_admin(byte[16])byte[16]"];
        argsTuple: WormholeTransceiverArgs["tuple"]["get_role_admin(byte[16])byte[16]"];
        /**
         * The role admin
         */
        returns: WormholeTransceiverReturns["get_role_admin(byte[16])byte[16]"];
      }
    >;
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        isInitialised: bigint;
        minUpgradeDelay: MinimumUpgradeDelay;
        scheduledContractUpgrade: ScheduledContractUpgrade;
        version: bigint;
        transceiverManager: bigint;
        wormholeCore: bigint;
        chainId: number;
        emitterLsig: string;
      };
      maps: {};
    };
    box: {
      keys: {};
      maps: {
        roles: Map<Uint8Array, Uint8Array>;
        addressesRoles: Map<AddressRoleKey, boolean>;
        wormholePeers: Map<bigint | number, Uint8Array>;
        vaasConsumed: Map<Uint8Array, boolean>;
      };
    };
  };
};

/**
 * Defines the possible abi call signatures.
 */
export type WormholeTransceiverSignatures = keyof WormholeTransceiverTypes["methods"];
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type WormholeTransceiverNonVoidMethodSignatures = keyof WormholeTransceiverTypes["methods"] extends infer T
  ? T extends keyof WormholeTransceiverTypes["methods"]
    ? MethodReturn<T> extends void
      ? never
      : T
    : never
  : never;
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, "method" | "args" | "onComplete"> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
  }
>;
/**
 * Maps a method signature from the WormholeTransceiver smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends WormholeTransceiverSignatures> =
  WormholeTransceiverTypes["methods"][TSignature]["argsObj" | "argsTuple"];
/**
 * Maps a method signature from the WormholeTransceiver smart contract to the method's return type
 */
export type MethodReturn<TSignature extends WormholeTransceiverSignatures> =
  WormholeTransceiverTypes["methods"][TSignature]["returns"];

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = WormholeTransceiverTypes["state"]["global"]["keys"];

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = WormholeTransceiverTypes["state"]["box"]["keys"];

/**
 * Defines supported create method params for this smart contract
 */
export type WormholeTransceiverCreateCallParams =
  | Expand<
      CallParams<
        | WormholeTransceiverArgs["obj"]["create(uint64,uint64,uint16,uint64)void"]
        | WormholeTransceiverArgs["tuple"]["create(uint64,uint64,uint16,uint64)void"]
      > & { method: "create" } & {
        onComplete?: OnApplicationComplete.NoOpOC;
      } & CreateSchema
    >
  | Expand<
      CallParams<
        | WormholeTransceiverArgs["obj"]["create(uint64,uint64,uint16,uint64)void"]
        | WormholeTransceiverArgs["tuple"]["create(uint64,uint64,uint16,uint64)void"]
      > & { method: "create(uint64,uint64,uint16,uint64)void" } & {
        onComplete?: OnApplicationComplete.NoOpOC;
      } & CreateSchema
    >;
/**
 * Defines supported update method params for this smart contract
 */
export type WormholeTransceiverUpdateCallParams =
  | Expand<
      CallParams<
        | WormholeTransceiverArgs["obj"]["complete_contract_upgrade()void"]
        | WormholeTransceiverArgs["tuple"]["complete_contract_upgrade()void"]
      > & { method: "complete_contract_upgrade" }
    >
  | Expand<
      CallParams<
        | WormholeTransceiverArgs["obj"]["complete_contract_upgrade()void"]
        | WormholeTransceiverArgs["tuple"]["complete_contract_upgrade()void"]
      > & { method: "complete_contract_upgrade()void" }
    >;
/**
 * Defines arguments required for the deploy method.
 */
export type WormholeTransceiverDeployParams = Expand<
  Omit<AppFactoryDeployParams, "createParams" | "updateParams" | "deleteParams"> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: WormholeTransceiverCreateCallParams;
    /**
     * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    updateParams?: WormholeTransceiverUpdateCallParams;
  }
>;

/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the WormholeTransceiver smart contract
 */
export abstract class WormholeTransceiverParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<
        TParams extends WormholeTransceiverCreateCallParams & {
          method: string;
        },
      >(params: TParams) {
        switch (params.method) {
          case "create":
          case "create(uint64,uint64,uint16,uint64)void":
            return WormholeTransceiverParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },

      /**
       * Constructs create ABI call params for the WormholeTransceiver smart contract using the create(uint64,uint64,uint16,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["create(uint64,uint64,uint16,uint64)void"]
          | WormholeTransceiverArgs["tuple"]["create(uint64,uint64,uint16,uint64)void"]
        > &
          AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
          },
      ): AppClientMethodCallParams &
        AppClientCompilationParams & {
          onComplete?: OnApplicationComplete.NoOpOC;
        } {
        return {
          ...params,
          method: "create(uint64,uint64,uint16,uint64)void" as const,
          args: Array.isArray(params.args)
            ? params.args
            : [
                params.args.transceiverManager,
                params.args.wormholeCore,
                params.args.chainId,
                params.args.minUpgradeDelay,
              ],
        };
      },
    };
  }

  /**
   * Gets available update ABI call param factories
   */
  static get update() {
    return {
      _resolveByMethod<
        TParams extends WormholeTransceiverUpdateCallParams & {
          method: string;
        },
      >(params: TParams) {
        switch (params.method) {
          case "complete_contract_upgrade":
          case "complete_contract_upgrade()void":
            return WormholeTransceiverParamsFactory.update.completeContractUpgrade(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },

      /**
       * Constructs update ABI call params for the WormholeTransceiver smart contract using the complete_contract_upgrade()void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      completeContractUpgrade(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["complete_contract_upgrade()void"]
          | WormholeTransceiverArgs["tuple"]["complete_contract_upgrade()void"]
        > &
          AppClientCompilationParams,
      ): AppClientMethodCallParams & AppClientCompilationParams {
        return {
          ...params,
          method: "complete_contract_upgrade()void" as const,
          args: Array.isArray(params.args) ? params.args : [],
        };
      },
    };
  }

  /**
   * Constructs a no op call for the initialise(address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initialise(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["initialise(address)void"]
      | WormholeTransceiverArgs["tuple"]["initialise(address)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "initialise(address)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.admin],
    };
  }
  /**
   * Constructs a no op call for the get_transceiver_type()string ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getTransceiverType(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["get_transceiver_type()string"]
      | WormholeTransceiverArgs["tuple"]["get_transceiver_type()string"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_transceiver_type()string" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the set_wormhole_peer(uint16,byte[32])void ABI method
   *
   * Set the WormholeTransceiver on a peer chain, overriding if needed.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setWormholePeer(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["set_wormhole_peer(uint16,byte[32])void"]
      | WormholeTransceiverArgs["tuple"]["set_wormhole_peer(uint16,byte[32])void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "set_wormhole_peer(uint16,byte[32])void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.peerChainId, params.args.peerContractAddress],
    };
  }
  /**
   * Constructs a no op call for the receive_message(appl)void ABI method
   *
   * Receive a Wormhole message directly with manual delivery.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static receiveMessage(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["receive_message(appl)void"]
      | WormholeTransceiverArgs["tuple"]["receive_message(appl)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "receive_message(appl)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.verifyVaa],
    };
  }
  /**
   * Constructs a no op call for the manager_role()byte[16] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static managerRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["manager_role()byte[16]"]
      | WormholeTransceiverArgs["tuple"]["manager_role()byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "manager_role()byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the get_wormhole_peer(uint16)byte[32] ABI method
   *
   * Get the address of the peer WormholeTransceiver set on a given chain.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getWormholePeer(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["get_wormhole_peer(uint16)byte[32]"]
      | WormholeTransceiverArgs["tuple"]["get_wormhole_peer(uint16)byte[32]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_wormhole_peer(uint16)byte[32]" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.peerChainId],
    };
  }
  /**
   * Constructs a no op call for the quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static quoteDeliveryPrice(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
      | WormholeTransceiverArgs["tuple"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.message, params.args.transceiverInstruction],
    };
  }
  /**
   * Constructs a no op call for the send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static sendMessage(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
      | WormholeTransceiverArgs["tuple"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void" as const,
      args: Array.isArray(params.args)
        ? params.args
        : [params.args.feePayment, params.args.message, params.args.transceiverInstruction],
    };
  }
  /**
   * Constructs a no op call for the update_min_upgrade_delay(uint64,uint64)void ABI method
   *
  * Schedule a change in the minimum delay needed for an upgrade.
  Automatically comes into effect at given timestamp.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateMinUpgradeDelay(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
      | WormholeTransceiverArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "update_min_upgrade_delay(uint64,uint64)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.minUpgradeDelay, params.args.timestamp],
    };
  }
  /**
   * Constructs a no op call for the schedule_contract_upgrade(byte[32],uint64)void ABI method
   *
  * Schedule the upgrade of the contract.
  The upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static scheduleContractUpgrade(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
      | WormholeTransceiverArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "schedule_contract_upgrade(byte[32],uint64)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.programSha256, params.args.timestamp],
    };
  }
  /**
   * Constructs a no op call for the cancel_contract_upgrade()void ABI method
   *
   * Cancel the scheduled upgrade
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static cancelContractUpgrade(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["cancel_contract_upgrade()void"]
      | WormholeTransceiverArgs["tuple"]["cancel_contract_upgrade()void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "cancel_contract_upgrade()void" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the upgradable_admin_role()byte[16] ABI method
   *
   * Returns the role identifier for the upgradeable admin role
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static upgradableAdminRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["upgradable_admin_role()byte[16]"]
      | WormholeTransceiverArgs["tuple"]["upgradable_admin_role()byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "upgradable_admin_role()byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the max_for_min_upgrade_delay()uint64 ABI method
   *
  * Returns the maximum delay allowed for the minimum upgrade delay
  This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static maxForMinUpgradeDelay(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["max_for_min_upgrade_delay()uint64"]
      | WormholeTransceiverArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "max_for_min_upgrade_delay()uint64" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the get_active_min_upgrade_delay()uint64 ABI method
   *
   * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getActiveMinUpgradeDelay(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["get_active_min_upgrade_delay()uint64"]
      | WormholeTransceiverArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_active_min_upgrade_delay()uint64" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the grant_role(byte[16],address)void ABI method
   *
  * Grant a role to an account
  Increases the MBR for the contract's ledger balance.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static grantRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["grant_role(byte[16],address)void"]
      | WormholeTransceiverArgs["tuple"]["grant_role(byte[16],address)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "grant_role(byte[16],address)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.role, params.args.account],
    };
  }
  /**
   * Constructs a no op call for the revoke_role(byte[16],address)void ABI method
   *
  * Revokes a role from an account
  Reduces the MBR for the contract's ledger balance.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static revokeRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["revoke_role(byte[16],address)void"]
      | WormholeTransceiverArgs["tuple"]["revoke_role(byte[16],address)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "revoke_role(byte[16],address)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.role, params.args.account],
    };
  }
  /**
   * Constructs a no op call for the renounce_role(byte[16])void ABI method
   *
  * Revokes a role from the caller
  Reduces the MBR for the contract's ledger balance.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static renounceRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["renounce_role(byte[16])void"]
      | WormholeTransceiverArgs["tuple"]["renounce_role(byte[16])void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "renounce_role(byte[16])void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.role],
    };
  }
  /**
   * Constructs a no op call for the default_admin_role()byte[16] ABI method
   *
   * Returns the role identifier for the default admin role
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static defaultAdminRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["default_admin_role()byte[16]"]
      | WormholeTransceiverArgs["tuple"]["default_admin_role()byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "default_admin_role()byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the has_role(byte[16],address)bool ABI method
   *
   * Returns whether the account has been granted a role
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static hasRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["has_role(byte[16],address)bool"]
      | WormholeTransceiverArgs["tuple"]["has_role(byte[16],address)bool"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "has_role(byte[16],address)bool" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.role, params.args.account],
    };
  }
  /**
   * Constructs a no op call for the get_role_admin(byte[16])byte[16] ABI method
   *
   * Returns the admin role that controls a role
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getRoleAdmin(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["get_role_admin(byte[16])byte[16]"]
      | WormholeTransceiverArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_role_admin(byte[16])byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.role],
    };
  }
}

/**
 * A factory to create and deploy one or more instance of the WormholeTransceiver smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class WormholeTransceiverFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory;

  /**
   * Creates a new instance of `WormholeTransceiverFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, "appSpec">) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    });
  }

  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName;
  }

  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC;
  }

  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand;
  }

  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new WormholeTransceiverClient(this.appFactory.getAppClientById(params));
  }

  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams) {
    return new WormholeTransceiverClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }

  /**
   * Idempotently deploys the WormholeTransceiver smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: WormholeTransceiverDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method
        ? WormholeTransceiverParamsFactory.create._resolveByMethod(params.createParams)
        : params.createParams
          ? (params.createParams as WormholeTransceiverCreateCallParams & {
              args: Uint8Array[];
            })
          : undefined,
      updateParams: params.updateParams?.method
        ? WormholeTransceiverParamsFactory.update._resolveByMethod(params.updateParams)
        : params.updateParams
          ? (params.updateParams as WormholeTransceiverUpdateCallParams & {
              args: Uint8Array[];
            })
          : undefined,
    });
    return {
      result: result.result,
      appClient: new WormholeTransceiverClient(result.appClient),
    };
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the WormholeTransceiver smart contract using the create(uint64,uint64,uint16,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["create(uint64,uint64,uint16,uint64)void"]
          | WormholeTransceiverArgs["tuple"]["create(uint64,uint64,uint16,uint64)void"]
        > &
          AppClientCompilationParams &
          CreateSchema & { onComplete?: OnApplicationComplete.NoOpOC },
      ) => {
        return this.appFactory.params.create(WormholeTransceiverParamsFactory.create.create(params));
      },
    },

    /**
     * Gets available deployUpdate methods
     */
    deployUpdate: {
      /**
       * Updates an existing instance of the WormholeTransceiver smart contract using the complete_contract_upgrade()void ABI method.
       *
       * Complete the scheduled upgrade
       *
       * @param params The params for the smart contract call
       * @returns The deployUpdate params
       */
      completeContractUpgrade: (
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["complete_contract_upgrade()void"]
          | WormholeTransceiverArgs["tuple"]["complete_contract_upgrade()void"]
        > &
          AppClientCompilationParams = { args: [] },
      ) => {
        return this.appFactory.params.deployUpdate(
          WormholeTransceiverParamsFactory.update.completeContractUpgrade(params),
        );
      },
    },
  };

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the WormholeTransceiver smart contract using the create(uint64,uint64,uint16,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["create(uint64,uint64,uint16,uint64)void"]
          | WormholeTransceiverArgs["tuple"]["create(uint64,uint64,uint16,uint64)void"]
        > &
          AppClientCompilationParams &
          CreateSchema & { onComplete?: OnApplicationComplete.NoOpOC },
      ) => {
        return this.appFactory.createTransaction.create(WormholeTransceiverParamsFactory.create.create(params));
      },
    },
  };

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the WormholeTransceiver smart contract using an ABI method call using the create(uint64,uint64,uint16,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["create(uint64,uint64,uint16,uint64)void"]
          | WormholeTransceiverArgs["tuple"]["create(uint64,uint64,uint16,uint64)void"]
        > &
          AppClientCompilationParams &
          CreateSchema &
          SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
      ) => {
        const result = await this.appFactory.send.create(WormholeTransceiverParamsFactory.create.create(params));
        return {
          result: {
            ...result.result,
            return: result.result.return as unknown as
              | undefined
              | WormholeTransceiverReturns["create(uint64,uint64,uint16,uint64)void"],
          },
          appClient: new WormholeTransceiverClient(result.appClient),
        };
      },
    },
  };
}
/**
 * A client to make calls to the WormholeTransceiver smart contract
 */
export class WormholeTransceiverClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient;

  /**
   * Creates a new instance of `WormholeTransceiverClient`
   *
   * @param appClient An `AppClient` instance which has been created with the WormholeTransceiver app spec
   */
  constructor(appClient: _AppClient);
  /**
   * Creates a new instance of `WormholeTransceiverClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, "appSpec">);
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, "appSpec">) {
    this.appClient =
      appClientOrParams instanceof _AppClient
        ? appClientOrParams
        : new _AppClient({
            ...appClientOrParams,
            appSpec: APP_SPEC,
          });
  }

  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends WormholeTransceiverNonVoidMethodSignatures>(
    method: TSignature,
    returnValue: ABIReturn | undefined,
  ) {
    return returnValue !== undefined
      ? getArc56ReturnValue<MethodReturn<TSignature>>(
          returnValue,
          this.appClient.getABIMethod(method),
          APP_SPEC.structs,
        )
      : undefined;
  }

  /**
   * Returns a new `WormholeTransceiverClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(
    params: Omit<ResolveAppClientByCreatorAndName, "appSpec">,
  ): Promise<WormholeTransceiverClient> {
    return new WormholeTransceiverClient(await _AppClient.fromCreatorAndName({ ...params, appSpec: APP_SPEC }));
  }

  /**
   * Returns an `WormholeTransceiverClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params: Omit<ResolveAppClientByNetwork, "appSpec">): Promise<WormholeTransceiverClient> {
    return new WormholeTransceiverClient(await _AppClient.fromNetwork({ ...params, appSpec: APP_SPEC }));
  }

  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId;
  }

  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress;
  }

  /** The name of the app. */
  public get appName() {
    return this.appClient.appName;
  }

  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec;
  }

  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand;
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the WormholeTransceiver smart contract using the `complete_contract_upgrade()void` ABI method.
       *
       * Complete the scheduled upgrade
       *
       * @param params The params for the smart contract call
       * @returns The update params
       */
      completeContractUpgrade: (
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["complete_contract_upgrade()void"]
          | WormholeTransceiverArgs["tuple"]["complete_contract_upgrade()void"]
        > &
          AppClientCompilationParams = { args: [] },
      ) => {
        return this.appClient.params.update(WormholeTransceiverParamsFactory.update.completeContractUpgrade(params));
      },
    },

    /**
     * Makes a clear_state call to an existing instance of the WormholeTransceiver smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params);
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `initialise(address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initialise: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["initialise(address)void"]
        | WormholeTransceiverArgs["tuple"]["initialise(address)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.initialise(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_transceiver_type()string` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getTransceiverType: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_transceiver_type()string"]
        | WormholeTransceiverArgs["tuple"]["get_transceiver_type()string"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.getTransceiverType(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `set_wormhole_peer(uint16,byte[32])void` ABI method.
     *
     * Set the WormholeTransceiver on a peer chain, overriding if needed.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setWormholePeer: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["set_wormhole_peer(uint16,byte[32])void"]
        | WormholeTransceiverArgs["tuple"]["set_wormhole_peer(uint16,byte[32])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.setWormholePeer(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `receive_message(appl)void` ABI method.
     *
     * Receive a Wormhole message directly with manual delivery.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    receiveMessage: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["receive_message(appl)void"]
        | WormholeTransceiverArgs["tuple"]["receive_message(appl)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.receiveMessage(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `manager_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    managerRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["manager_role()byte[16]"]
        | WormholeTransceiverArgs["tuple"]["manager_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.managerRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_wormhole_peer(uint16)byte[32]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the address of the peer WormholeTransceiver set on a given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getWormholePeer: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_wormhole_peer(uint16)byte[32]"]
        | WormholeTransceiverArgs["tuple"]["get_wormhole_peer(uint16)byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.getWormholePeer(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    quoteDeliveryPrice: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
        | WormholeTransceiverArgs["tuple"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.quoteDeliveryPrice(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    sendMessage: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
        | WormholeTransceiverArgs["tuple"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.sendMessage(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `update_min_upgrade_delay(uint64,uint64)void` ABI method.
     *
    * Schedule a change in the minimum delay needed for an upgrade.
    Automatically comes into effect at given timestamp.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateMinUpgradeDelay: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
        | WormholeTransceiverArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.updateMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `schedule_contract_upgrade(byte[32],uint64)void` ABI method.
     *
    * Schedule the upgrade of the contract.
    The upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    scheduleContractUpgrade: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
        | WormholeTransceiverArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.scheduleContractUpgrade(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `cancel_contract_upgrade()void` ABI method.
     *
     * Cancel the scheduled upgrade
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    cancelContractUpgrade: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["cancel_contract_upgrade()void"]
        | WormholeTransceiverArgs["tuple"]["cancel_contract_upgrade()void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.cancelContractUpgrade(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `upgradable_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the upgradeable admin role
     *
     * @param params The params for the smart contract call
     * @returns The call params: Role bytes of length 16
     */
    upgradableAdminRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["upgradable_admin_role()byte[16]"]
        | WormholeTransceiverArgs["tuple"]["upgradable_admin_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.upgradableAdminRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `max_for_min_upgrade_delay()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the maximum delay allowed for the minimum upgrade delay
    This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

     *
     * @param params The params for the smart contract call
     * @returns The call params: The maximum minimum upgrade delay
     */
    maxForMinUpgradeDelay: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["max_for_min_upgrade_delay()uint64"]
        | WormholeTransceiverArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.maxForMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_active_min_upgrade_delay()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
     *
     * @param params The params for the smart contract call
     * @returns The call params: The active minimum upgrade delay
     */
    getActiveMinUpgradeDelay: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_active_min_upgrade_delay()uint64"]
        | WormholeTransceiverArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.getActiveMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `grant_role(byte[16],address)void` ABI method.
     *
    * Grant a role to an account
    Increases the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    grantRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["grant_role(byte[16],address)void"]
        | WormholeTransceiverArgs["tuple"]["grant_role(byte[16],address)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.grantRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `revoke_role(byte[16],address)void` ABI method.
     *
    * Revokes a role from an account
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    revokeRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["revoke_role(byte[16],address)void"]
        | WormholeTransceiverArgs["tuple"]["revoke_role(byte[16],address)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.revokeRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `renounce_role(byte[16])void` ABI method.
     *
    * Revokes a role from the caller
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    renounceRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["renounce_role(byte[16])void"]
        | WormholeTransceiverArgs["tuple"]["renounce_role(byte[16])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.renounceRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `default_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the default admin role
     *
     * @param params The params for the smart contract call
     * @returns The call params: Empty bytes of length 16
     */
    defaultAdminRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["default_admin_role()byte[16]"]
        | WormholeTransceiverArgs["tuple"]["default_admin_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.defaultAdminRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `has_role(byte[16],address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns whether the account has been granted a role
     *
     * @param params The params for the smart contract call
     * @returns The call params: Whether the account has been granted a role
     */
    hasRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["has_role(byte[16],address)bool"]
        | WormholeTransceiverArgs["tuple"]["has_role(byte[16],address)bool"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.hasRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_role_admin(byte[16])byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the admin role that controls a role
     *
     * @param params The params for the smart contract call
     * @returns The call params: The role admin
     */
    getRoleAdmin: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_role_admin(byte[16])byte[16]"]
        | WormholeTransceiverArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(WormholeTransceiverParamsFactory.getRoleAdmin(params));
    },
  };

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the WormholeTransceiver smart contract using the `complete_contract_upgrade()void` ABI method.
       *
       * Complete the scheduled upgrade
       *
       * @param params The params for the smart contract call
       * @returns The update transaction
       */
      completeContractUpgrade: (
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["complete_contract_upgrade()void"]
          | WormholeTransceiverArgs["tuple"]["complete_contract_upgrade()void"]
        > &
          AppClientCompilationParams = { args: [] },
      ) => {
        return this.appClient.createTransaction.update(
          WormholeTransceiverParamsFactory.update.completeContractUpgrade(params),
        );
      },
    },

    /**
     * Makes a clear_state call to an existing instance of the WormholeTransceiver smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `initialise(address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initialise: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["initialise(address)void"]
        | WormholeTransceiverArgs["tuple"]["initialise(address)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.initialise(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_transceiver_type()string` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getTransceiverType: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_transceiver_type()string"]
        | WormholeTransceiverArgs["tuple"]["get_transceiver_type()string"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.getTransceiverType(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `set_wormhole_peer(uint16,byte[32])void` ABI method.
     *
     * Set the WormholeTransceiver on a peer chain, overriding if needed.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setWormholePeer: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["set_wormhole_peer(uint16,byte[32])void"]
        | WormholeTransceiverArgs["tuple"]["set_wormhole_peer(uint16,byte[32])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.setWormholePeer(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `receive_message(appl)void` ABI method.
     *
     * Receive a Wormhole message directly with manual delivery.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    receiveMessage: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["receive_message(appl)void"]
        | WormholeTransceiverArgs["tuple"]["receive_message(appl)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.receiveMessage(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `manager_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    managerRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["manager_role()byte[16]"]
        | WormholeTransceiverArgs["tuple"]["manager_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.managerRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_wormhole_peer(uint16)byte[32]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the address of the peer WormholeTransceiver set on a given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getWormholePeer: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_wormhole_peer(uint16)byte[32]"]
        | WormholeTransceiverArgs["tuple"]["get_wormhole_peer(uint16)byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.getWormholePeer(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    quoteDeliveryPrice: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
        | WormholeTransceiverArgs["tuple"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.quoteDeliveryPrice(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    sendMessage: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
        | WormholeTransceiverArgs["tuple"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.sendMessage(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `update_min_upgrade_delay(uint64,uint64)void` ABI method.
     *
    * Schedule a change in the minimum delay needed for an upgrade.
    Automatically comes into effect at given timestamp.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateMinUpgradeDelay: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
        | WormholeTransceiverArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.updateMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `schedule_contract_upgrade(byte[32],uint64)void` ABI method.
     *
    * Schedule the upgrade of the contract.
    The upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    scheduleContractUpgrade: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
        | WormholeTransceiverArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.scheduleContractUpgrade(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `cancel_contract_upgrade()void` ABI method.
     *
     * Cancel the scheduled upgrade
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    cancelContractUpgrade: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["cancel_contract_upgrade()void"]
        | WormholeTransceiverArgs["tuple"]["cancel_contract_upgrade()void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.cancelContractUpgrade(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `upgradable_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the upgradeable admin role
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Role bytes of length 16
     */
    upgradableAdminRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["upgradable_admin_role()byte[16]"]
        | WormholeTransceiverArgs["tuple"]["upgradable_admin_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.upgradableAdminRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `max_for_min_upgrade_delay()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the maximum delay allowed for the minimum upgrade delay
    This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The maximum minimum upgrade delay
     */
    maxForMinUpgradeDelay: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["max_for_min_upgrade_delay()uint64"]
        | WormholeTransceiverArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.maxForMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_active_min_upgrade_delay()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The active minimum upgrade delay
     */
    getActiveMinUpgradeDelay: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_active_min_upgrade_delay()uint64"]
        | WormholeTransceiverArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.getActiveMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `grant_role(byte[16],address)void` ABI method.
     *
    * Grant a role to an account
    Increases the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    grantRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["grant_role(byte[16],address)void"]
        | WormholeTransceiverArgs["tuple"]["grant_role(byte[16],address)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.grantRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `revoke_role(byte[16],address)void` ABI method.
     *
    * Revokes a role from an account
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    revokeRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["revoke_role(byte[16],address)void"]
        | WormholeTransceiverArgs["tuple"]["revoke_role(byte[16],address)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.revokeRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `renounce_role(byte[16])void` ABI method.
     *
    * Revokes a role from the caller
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    renounceRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["renounce_role(byte[16])void"]
        | WormholeTransceiverArgs["tuple"]["renounce_role(byte[16])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.renounceRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `default_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the default admin role
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Empty bytes of length 16
     */
    defaultAdminRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["default_admin_role()byte[16]"]
        | WormholeTransceiverArgs["tuple"]["default_admin_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.defaultAdminRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `has_role(byte[16],address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns whether the account has been granted a role
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Whether the account has been granted a role
     */
    hasRole: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["has_role(byte[16],address)bool"]
        | WormholeTransceiverArgs["tuple"]["has_role(byte[16],address)bool"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.hasRole(params));
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_role_admin(byte[16])byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the admin role that controls a role
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The role admin
     */
    getRoleAdmin: (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_role_admin(byte[16])byte[16]"]
        | WormholeTransceiverArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(WormholeTransceiverParamsFactory.getRoleAdmin(params));
    },
  };

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the WormholeTransceiver smart contract using the `complete_contract_upgrade()void` ABI method.
       *
       * Complete the scheduled upgrade
       *
       * @param params The params for the smart contract call
       * @returns The update result
       */
      completeContractUpgrade: async (
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["complete_contract_upgrade()void"]
          | WormholeTransceiverArgs["tuple"]["complete_contract_upgrade()void"]
        > &
          AppClientCompilationParams &
          SendParams = { args: [] },
      ) => {
        const result = await this.appClient.send.update(
          WormholeTransceiverParamsFactory.update.completeContractUpgrade(params),
        );
        return {
          ...result,
          return: result.return as unknown as undefined | WormholeTransceiverReturns["complete_contract_upgrade()void"],
        };
      },
    },

    /**
     * Makes a clear_state call to an existing instance of the WormholeTransceiver smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params);
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `initialise(address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initialise: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["initialise(address)void"]
        | WormholeTransceiverArgs["tuple"]["initialise(address)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.initialise(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["initialise(address)void"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_transceiver_type()string` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getTransceiverType: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_transceiver_type()string"]
        | WormholeTransceiverArgs["tuple"]["get_transceiver_type()string"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.getTransceiverType(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["get_transceiver_type()string"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `set_wormhole_peer(uint16,byte[32])void` ABI method.
     *
     * Set the WormholeTransceiver on a peer chain, overriding if needed.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setWormholePeer: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["set_wormhole_peer(uint16,byte[32])void"]
        | WormholeTransceiverArgs["tuple"]["set_wormhole_peer(uint16,byte[32])void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.setWormholePeer(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | WormholeTransceiverReturns["set_wormhole_peer(uint16,byte[32])void"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `receive_message(appl)void` ABI method.
     *
     * Receive a Wormhole message directly with manual delivery.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    receiveMessage: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["receive_message(appl)void"]
        | WormholeTransceiverArgs["tuple"]["receive_message(appl)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.receiveMessage(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["receive_message(appl)void"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `manager_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    managerRole: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["manager_role()byte[16]"]
        | WormholeTransceiverArgs["tuple"]["manager_role()byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.managerRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["manager_role()byte[16]"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_wormhole_peer(uint16)byte[32]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the address of the peer WormholeTransceiver set on a given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getWormholePeer: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_wormhole_peer(uint16)byte[32]"]
        | WormholeTransceiverArgs["tuple"]["get_wormhole_peer(uint16)byte[32]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.getWormholePeer(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["get_wormhole_peer(uint16)byte[32]"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    quoteDeliveryPrice: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
        | WormholeTransceiverArgs["tuple"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.quoteDeliveryPrice(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | WormholeTransceiverReturns["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    sendMessage: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
        | WormholeTransceiverArgs["tuple"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.sendMessage(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | WormholeTransceiverReturns["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `update_min_upgrade_delay(uint64,uint64)void` ABI method.
     *
    * Schedule a change in the minimum delay needed for an upgrade.
    Automatically comes into effect at given timestamp.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateMinUpgradeDelay: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
        | WormholeTransceiverArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.updateMinUpgradeDelay(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | WormholeTransceiverReturns["update_min_upgrade_delay(uint64,uint64)void"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `schedule_contract_upgrade(byte[32],uint64)void` ABI method.
     *
    * Schedule the upgrade of the contract.
    The upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    scheduleContractUpgrade: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
        | WormholeTransceiverArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.scheduleContractUpgrade(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | WormholeTransceiverReturns["schedule_contract_upgrade(byte[32],uint64)void"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `cancel_contract_upgrade()void` ABI method.
     *
     * Cancel the scheduled upgrade
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    cancelContractUpgrade: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["cancel_contract_upgrade()void"]
        | WormholeTransceiverArgs["tuple"]["cancel_contract_upgrade()void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.cancelContractUpgrade(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["cancel_contract_upgrade()void"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `upgradable_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the upgradeable admin role
     *
     * @param params The params for the smart contract call
     * @returns The call result: Role bytes of length 16
     */
    upgradableAdminRole: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["upgradable_admin_role()byte[16]"]
        | WormholeTransceiverArgs["tuple"]["upgradable_admin_role()byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.upgradableAdminRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["upgradable_admin_role()byte[16]"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `max_for_min_upgrade_delay()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the maximum delay allowed for the minimum upgrade delay
    This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

     *
     * @param params The params for the smart contract call
     * @returns The call result: The maximum minimum upgrade delay
     */
    maxForMinUpgradeDelay: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["max_for_min_upgrade_delay()uint64"]
        | WormholeTransceiverArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.maxForMinUpgradeDelay(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["max_for_min_upgrade_delay()uint64"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_active_min_upgrade_delay()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
     *
     * @param params The params for the smart contract call
     * @returns The call result: The active minimum upgrade delay
     */
    getActiveMinUpgradeDelay: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_active_min_upgrade_delay()uint64"]
        | WormholeTransceiverArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.getActiveMinUpgradeDelay(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | WormholeTransceiverReturns["get_active_min_upgrade_delay()uint64"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `grant_role(byte[16],address)void` ABI method.
     *
    * Grant a role to an account
    Increases the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    grantRole: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["grant_role(byte[16],address)void"]
        | WormholeTransceiverArgs["tuple"]["grant_role(byte[16],address)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.grantRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["grant_role(byte[16],address)void"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `revoke_role(byte[16],address)void` ABI method.
     *
    * Revokes a role from an account
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    revokeRole: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["revoke_role(byte[16],address)void"]
        | WormholeTransceiverArgs["tuple"]["revoke_role(byte[16],address)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.revokeRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["revoke_role(byte[16],address)void"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `renounce_role(byte[16])void` ABI method.
     *
    * Revokes a role from the caller
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    renounceRole: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["renounce_role(byte[16])void"]
        | WormholeTransceiverArgs["tuple"]["renounce_role(byte[16])void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.renounceRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["renounce_role(byte[16])void"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `default_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the default admin role
     *
     * @param params The params for the smart contract call
     * @returns The call result: Empty bytes of length 16
     */
    defaultAdminRole: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["default_admin_role()byte[16]"]
        | WormholeTransceiverArgs["tuple"]["default_admin_role()byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.defaultAdminRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["default_admin_role()byte[16]"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `has_role(byte[16],address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns whether the account has been granted a role
     *
     * @param params The params for the smart contract call
     * @returns The call result: Whether the account has been granted a role
     */
    hasRole: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["has_role(byte[16],address)bool"]
        | WormholeTransceiverArgs["tuple"]["has_role(byte[16],address)bool"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.hasRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["has_role(byte[16],address)bool"],
      };
    },

    /**
     * Makes a call to the WormholeTransceiver smart contract using the `get_role_admin(byte[16])byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the admin role that controls a role
     *
     * @param params The params for the smart contract call
     * @returns The call result: The role admin
     */
    getRoleAdmin: async (
      params: CallParams<
        | WormholeTransceiverArgs["obj"]["get_role_admin(byte[16])byte[16]"]
        | WormholeTransceiverArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.getRoleAdmin(params));
      return {
        ...result,
        return: result.return as unknown as undefined | WormholeTransceiverReturns["get_role_admin(byte[16])byte[16]"],
      };
    },
  };

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new WormholeTransceiverClient(this.appClient.clone(params));
  }

  /**
   * Makes a readonly (simulated) call to the WormholeTransceiver smart contract using the `get_transceiver_type()string` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getTransceiverType(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["get_transceiver_type()string"]
      | WormholeTransceiverArgs["tuple"]["get_transceiver_type()string"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.getTransceiverType(params));
    return result.return as unknown as WormholeTransceiverReturns["get_transceiver_type()string"];
  }

  /**
   * Makes a readonly (simulated) call to the WormholeTransceiver smart contract using the `manager_role()byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async managerRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["manager_role()byte[16]"]
      | WormholeTransceiverArgs["tuple"]["manager_role()byte[16]"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.managerRole(params));
    return result.return as unknown as WormholeTransceiverReturns["manager_role()byte[16]"];
  }

  /**
   * Makes a readonly (simulated) call to the WormholeTransceiver smart contract using the `get_wormhole_peer(uint16)byte[32]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get the address of the peer WormholeTransceiver set on a given chain.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getWormholePeer(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["get_wormhole_peer(uint16)byte[32]"]
      | WormholeTransceiverArgs["tuple"]["get_wormhole_peer(uint16)byte[32]"]
    >,
  ) {
    const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.getWormholePeer(params));
    return result.return as unknown as WormholeTransceiverReturns["get_wormhole_peer(uint16)byte[32]"];
  }

  /**
   * Makes a readonly (simulated) call to the WormholeTransceiver smart contract using the `quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async quoteDeliveryPrice(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
      | WormholeTransceiverArgs["tuple"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
    >,
  ) {
    const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.quoteDeliveryPrice(params));
    return result.return as unknown as WormholeTransceiverReturns["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"];
  }

  /**
   * Makes a readonly (simulated) call to the WormholeTransceiver smart contract using the `upgradable_admin_role()byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the role identifier for the upgradeable admin role
   *
   * @param params The params for the smart contract call
   * @returns The call result: Role bytes of length 16
   */
  async upgradableAdminRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["upgradable_admin_role()byte[16]"]
      | WormholeTransceiverArgs["tuple"]["upgradable_admin_role()byte[16]"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.upgradableAdminRole(params));
    return result.return as unknown as WormholeTransceiverReturns["upgradable_admin_role()byte[16]"];
  }

  /**
   * Makes a readonly (simulated) call to the WormholeTransceiver smart contract using the `max_for_min_upgrade_delay()uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Returns the maximum delay allowed for the minimum upgrade delay
  This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

   *
   * @param params The params for the smart contract call
   * @returns The call result: The maximum minimum upgrade delay
   */
  async maxForMinUpgradeDelay(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["max_for_min_upgrade_delay()uint64"]
      | WormholeTransceiverArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.maxForMinUpgradeDelay(params));
    return result.return as unknown as WormholeTransceiverReturns["max_for_min_upgrade_delay()uint64"];
  }

  /**
   * Makes a readonly (simulated) call to the WormholeTransceiver smart contract using the `get_active_min_upgrade_delay()uint64` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
   *
   * @param params The params for the smart contract call
   * @returns The call result: The active minimum upgrade delay
   */
  async getActiveMinUpgradeDelay(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["get_active_min_upgrade_delay()uint64"]
      | WormholeTransceiverArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.getActiveMinUpgradeDelay(params));
    return result.return as unknown as WormholeTransceiverReturns["get_active_min_upgrade_delay()uint64"];
  }

  /**
   * Makes a readonly (simulated) call to the WormholeTransceiver smart contract using the `default_admin_role()byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the role identifier for the default admin role
   *
   * @param params The params for the smart contract call
   * @returns The call result: Empty bytes of length 16
   */
  async defaultAdminRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["default_admin_role()byte[16]"]
      | WormholeTransceiverArgs["tuple"]["default_admin_role()byte[16]"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.defaultAdminRole(params));
    return result.return as unknown as WormholeTransceiverReturns["default_admin_role()byte[16]"];
  }

  /**
   * Makes a readonly (simulated) call to the WormholeTransceiver smart contract using the `has_role(byte[16],address)bool` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns whether the account has been granted a role
   *
   * @param params The params for the smart contract call
   * @returns The call result: Whether the account has been granted a role
   */
  async hasRole(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["has_role(byte[16],address)bool"]
      | WormholeTransceiverArgs["tuple"]["has_role(byte[16],address)bool"]
    >,
  ) {
    const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.hasRole(params));
    return result.return as unknown as WormholeTransceiverReturns["has_role(byte[16],address)bool"];
  }

  /**
   * Makes a readonly (simulated) call to the WormholeTransceiver smart contract using the `get_role_admin(byte[16])byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the admin role that controls a role
   *
   * @param params The params for the smart contract call
   * @returns The call result: The role admin
   */
  async getRoleAdmin(
    params: CallParams<
      | WormholeTransceiverArgs["obj"]["get_role_admin(byte[16])byte[16]"]
      | WormholeTransceiverArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
    >,
  ) {
    const result = await this.appClient.send.call(WormholeTransceiverParamsFactory.getRoleAdmin(params));
    return result.return as unknown as WormholeTransceiverReturns["get_role_admin(byte[16])byte[16]"];
  }

  /**
   * Methods to access state for the current WormholeTransceiver app
   */
  state = {
    /**
     * Methods to access global state for the current WormholeTransceiver app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll();
        return {
          isInitialised: result.is_initialised,
          minUpgradeDelay: result.min_upgrade_delay,
          scheduledContractUpgrade: result.scheduled_contract_upgrade,
          version: result.version,
          transceiverManager: result.transceiver_manager,
          wormholeCore: result.wormhole_core,
          chainId: result.chain_id,
          emitterLsig: result.emitter_lsig,
        };
      },
      /**
       * Get the current value of the is_initialised key in global state
       */
      isInitialised: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("is_initialised")) as bigint | undefined;
      },
      /**
       * Get the current value of the min_upgrade_delay key in global state
       */
      minUpgradeDelay: async (): Promise<MinimumUpgradeDelay | undefined> => {
        return (await this.appClient.state.global.getValue("min_upgrade_delay")) as MinimumUpgradeDelay | undefined;
      },
      /**
       * Get the current value of the scheduled_contract_upgrade key in global state
       */
      scheduledContractUpgrade: async (): Promise<ScheduledContractUpgrade | undefined> => {
        return (await this.appClient.state.global.getValue("scheduled_contract_upgrade")) as
          | ScheduledContractUpgrade
          | undefined;
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("version")) as bigint | undefined;
      },
      /**
       * Get the current value of the transceiver_manager key in global state
       */
      transceiverManager: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("transceiver_manager")) as bigint | undefined;
      },
      /**
       * Get the current value of the wormhole_core key in global state
       */
      wormholeCore: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("wormhole_core")) as bigint | undefined;
      },
      /**
       * Get the current value of the chain_id key in global state
       */
      chainId: async (): Promise<number | undefined> => {
        return (await this.appClient.state.global.getValue("chain_id")) as number | undefined;
      },
      /**
       * Get the current value of the emitter_lsig key in global state
       */
      emitterLsig: async (): Promise<string | undefined> => {
        return (await this.appClient.state.global.getValue("emitter_lsig")) as string | undefined;
      },
    },
    /**
     * Methods to access box state for the current WormholeTransceiver app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll();
        return {};
      },
      /**
       * Get values from the roles map in box state
       */
      roles: {
        /**
         * Get all current values of the roles map in box state
         */
        getMap: async (): Promise<Map<Uint8Array, Uint8Array>> => {
          return (await this.appClient.state.box.getMap("roles")) as Map<Uint8Array, Uint8Array>;
        },
        /**
         * Get a current value of the roles map by key from box state
         */
        value: async (key: Uint8Array): Promise<Uint8Array | undefined> => {
          return (await this.appClient.state.box.getMapValue("roles", key)) as Uint8Array | undefined;
        },
      },
      /**
       * Get values from the addresses_roles map in box state
       */
      addressesRoles: {
        /**
         * Get all current values of the addresses_roles map in box state
         */
        getMap: async (): Promise<Map<AddressRoleKey, boolean>> => {
          return (await this.appClient.state.box.getMap("addresses_roles")) as Map<AddressRoleKey, boolean>;
        },
        /**
         * Get a current value of the addresses_roles map by key from box state
         */
        value: async (key: AddressRoleKey): Promise<boolean | undefined> => {
          return (await this.appClient.state.box.getMapValue("addresses_roles", key)) as boolean | undefined;
        },
      },
      /**
       * Get values from the wormhole_peers map in box state
       */
      wormholePeers: {
        /**
         * Get all current values of the wormhole_peers map in box state
         */
        getMap: async (): Promise<Map<number, Uint8Array>> => {
          return (await this.appClient.state.box.getMap("wormhole_peers")) as Map<number, Uint8Array>;
        },
        /**
         * Get a current value of the wormhole_peers map by key from box state
         */
        value: async (key: bigint | number): Promise<Uint8Array | undefined> => {
          return (await this.appClient.state.box.getMapValue("wormhole_peers", key)) as Uint8Array | undefined;
        },
      },
      /**
       * Get values from the vaas_consumed map in box state
       */
      vaasConsumed: {
        /**
         * Get all current values of the vaas_consumed map in box state
         */
        getMap: async (): Promise<Map<Uint8Array, boolean>> => {
          return (await this.appClient.state.box.getMap("vaas_consumed")) as Map<Uint8Array, boolean>;
        },
        /**
         * Get a current value of the vaas_consumed map by key from box state
         */
        value: async (key: Uint8Array): Promise<boolean | undefined> => {
          return (await this.appClient.state.box.getMapValue("vaas_consumed", key)) as boolean | undefined;
        },
      },
    },
  };

  public newGroup(): WormholeTransceiverComposer {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain: Promise<unknown> = Promise.resolve();
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = [];
    return {
      /**
       * Add a initialise(address)void method call against the WormholeTransceiver contract
       */
      initialise(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["initialise(address)void"]
          | WormholeTransceiverArgs["tuple"]["initialise(address)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.initialise(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a get_transceiver_type()string method call against the WormholeTransceiver contract
       */
      getTransceiverType(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["get_transceiver_type()string"]
          | WormholeTransceiverArgs["tuple"]["get_transceiver_type()string"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getTransceiverType(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_transceiver_type()string", v));
        return this;
      },
      /**
       * Add a set_wormhole_peer(uint16,byte[32])void method call against the WormholeTransceiver contract
       */
      setWormholePeer(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["set_wormhole_peer(uint16,byte[32])void"]
          | WormholeTransceiverArgs["tuple"]["set_wormhole_peer(uint16,byte[32])void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.setWormholePeer(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a receive_message(appl)void method call against the WormholeTransceiver contract
       */
      receiveMessage(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["receive_message(appl)void"]
          | WormholeTransceiverArgs["tuple"]["receive_message(appl)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.receiveMessage(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a manager_role()byte[16] method call against the WormholeTransceiver contract
       */
      managerRole(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["manager_role()byte[16]"]
          | WormholeTransceiverArgs["tuple"]["manager_role()byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.managerRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("manager_role()byte[16]", v));
        return this;
      },
      /**
       * Add a get_wormhole_peer(uint16)byte[32] method call against the WormholeTransceiver contract
       */
      getWormholePeer(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["get_wormhole_peer(uint16)byte[32]"]
          | WormholeTransceiverArgs["tuple"]["get_wormhole_peer(uint16)byte[32]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getWormholePeer(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_wormhole_peer(uint16)byte[32]", v));
        return this;
      },
      /**
       * Add a quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64 method call against the WormholeTransceiver contract
       */
      quoteDeliveryPrice(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
          | WormholeTransceiverArgs["tuple"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.quoteDeliveryPrice(params)),
        );
        resultMappers.push((v) =>
          client.decodeReturnValue(
            "quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64",
            v,
          ),
        );
        return this;
      },
      /**
       * Add a send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void method call against the WormholeTransceiver contract
       */
      sendMessage(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
          | WormholeTransceiverArgs["tuple"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.sendMessage(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a update_min_upgrade_delay(uint64,uint64)void method call against the WormholeTransceiver contract
       */
      updateMinUpgradeDelay(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
          | WormholeTransceiverArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.updateMinUpgradeDelay(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a schedule_contract_upgrade(byte[32],uint64)void method call against the WormholeTransceiver contract
       */
      scheduleContractUpgrade(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
          | WormholeTransceiverArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.scheduleContractUpgrade(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a cancel_contract_upgrade()void method call against the WormholeTransceiver contract
       */
      cancelContractUpgrade(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["cancel_contract_upgrade()void"]
          | WormholeTransceiverArgs["tuple"]["cancel_contract_upgrade()void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.cancelContractUpgrade(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a upgradable_admin_role()byte[16] method call against the WormholeTransceiver contract
       */
      upgradableAdminRole(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["upgradable_admin_role()byte[16]"]
          | WormholeTransceiverArgs["tuple"]["upgradable_admin_role()byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.upgradableAdminRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("upgradable_admin_role()byte[16]", v));
        return this;
      },
      /**
       * Add a max_for_min_upgrade_delay()uint64 method call against the WormholeTransceiver contract
       */
      maxForMinUpgradeDelay(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["max_for_min_upgrade_delay()uint64"]
          | WormholeTransceiverArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.maxForMinUpgradeDelay(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("max_for_min_upgrade_delay()uint64", v));
        return this;
      },
      /**
       * Add a get_active_min_upgrade_delay()uint64 method call against the WormholeTransceiver contract
       */
      getActiveMinUpgradeDelay(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["get_active_min_upgrade_delay()uint64"]
          | WormholeTransceiverArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getActiveMinUpgradeDelay(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_active_min_upgrade_delay()uint64", v));
        return this;
      },
      /**
       * Add a grant_role(byte[16],address)void method call against the WormholeTransceiver contract
       */
      grantRole(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["grant_role(byte[16],address)void"]
          | WormholeTransceiverArgs["tuple"]["grant_role(byte[16],address)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.grantRole(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a revoke_role(byte[16],address)void method call against the WormholeTransceiver contract
       */
      revokeRole(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["revoke_role(byte[16],address)void"]
          | WormholeTransceiverArgs["tuple"]["revoke_role(byte[16],address)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.revokeRole(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a renounce_role(byte[16])void method call against the WormholeTransceiver contract
       */
      renounceRole(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["renounce_role(byte[16])void"]
          | WormholeTransceiverArgs["tuple"]["renounce_role(byte[16])void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.renounceRole(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a default_admin_role()byte[16] method call against the WormholeTransceiver contract
       */
      defaultAdminRole(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["default_admin_role()byte[16]"]
          | WormholeTransceiverArgs["tuple"]["default_admin_role()byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.defaultAdminRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("default_admin_role()byte[16]", v));
        return this;
      },
      /**
       * Add a has_role(byte[16],address)bool method call against the WormholeTransceiver contract
       */
      hasRole(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["has_role(byte[16],address)bool"]
          | WormholeTransceiverArgs["tuple"]["has_role(byte[16],address)bool"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.hasRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("has_role(byte[16],address)bool", v));
        return this;
      },
      /**
       * Add a get_role_admin(byte[16])byte[16] method call against the WormholeTransceiver contract
       */
      getRoleAdmin(
        params: CallParams<
          | WormholeTransceiverArgs["obj"]["get_role_admin(byte[16])byte[16]"]
          | WormholeTransceiverArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getRoleAdmin(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_role_admin(byte[16])byte[16]", v));
        return this;
      },
      get update() {
        return {
          completeContractUpgrade: (
            params: CallParams<
              | WormholeTransceiverArgs["obj"]["complete_contract_upgrade()void"]
              | WormholeTransceiverArgs["tuple"]["complete_contract_upgrade()void"]
            > &
              AppClientCompilationParams,
          ) => {
            promiseChain = promiseChain.then(async () =>
              composer.addAppUpdateMethodCall(await client.params.update.completeContractUpgrade(params)),
            );
            resultMappers.push(undefined);
            return this;
          },
        };
      },
      /**
       * Add a clear state call to the WormholeTransceiver contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: result.returns?.map((val, i) =>
            resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue,
          ),
        };
      },
      async send(params?: SendParams) {
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: result.returns?.map((val, i) =>
            resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue,
          ),
        };
      },
    } as unknown as WormholeTransceiverComposer;
  }
}
export type WormholeTransceiverComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the initialise(address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  initialise(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["initialise(address)void"]
      | WormholeTransceiverArgs["tuple"]["initialise(address)void"]
    >,
  ): WormholeTransceiverComposer<[...TReturns, WormholeTransceiverReturns["initialise(address)void"] | undefined]>;

  /**
   * Calls the get_transceiver_type()string ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getTransceiverType(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["get_transceiver_type()string"]
      | WormholeTransceiverArgs["tuple"]["get_transceiver_type()string"]
    >,
  ): WormholeTransceiverComposer<[...TReturns, WormholeTransceiverReturns["get_transceiver_type()string"] | undefined]>;

  /**
   * Calls the set_wormhole_peer(uint16,byte[32])void ABI method.
   *
   * Set the WormholeTransceiver on a peer chain, overriding if needed.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setWormholePeer(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["set_wormhole_peer(uint16,byte[32])void"]
      | WormholeTransceiverArgs["tuple"]["set_wormhole_peer(uint16,byte[32])void"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["set_wormhole_peer(uint16,byte[32])void"] | undefined]
  >;

  /**
   * Calls the receive_message(appl)void ABI method.
   *
   * Receive a Wormhole message directly with manual delivery.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  receiveMessage(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["receive_message(appl)void"]
      | WormholeTransceiverArgs["tuple"]["receive_message(appl)void"]
    >,
  ): WormholeTransceiverComposer<[...TReturns, WormholeTransceiverReturns["receive_message(appl)void"] | undefined]>;

  /**
   * Calls the manager_role()byte[16] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  managerRole(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["manager_role()byte[16]"]
      | WormholeTransceiverArgs["tuple"]["manager_role()byte[16]"]
    >,
  ): WormholeTransceiverComposer<[...TReturns, WormholeTransceiverReturns["manager_role()byte[16]"] | undefined]>;

  /**
   * Calls the get_wormhole_peer(uint16)byte[32] ABI method.
   *
   * Get the address of the peer WormholeTransceiver set on a given chain.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getWormholePeer(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["get_wormhole_peer(uint16)byte[32]"]
      | WormholeTransceiverArgs["tuple"]["get_wormhole_peer(uint16)byte[32]"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["get_wormhole_peer(uint16)byte[32]"] | undefined]
  >;

  /**
   * Calls the quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  quoteDeliveryPrice(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
      | WormholeTransceiverArgs["tuple"]["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
    >,
  ): WormholeTransceiverComposer<
    [
      ...TReturns,
      (
        | WormholeTransceiverReturns["quote_delivery_price((byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])uint64"]
        | undefined
      ),
    ]
  >;

  /**
   * Calls the send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  sendMessage(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
      | WormholeTransceiverArgs["tuple"]["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
    >,
  ): WormholeTransceiverComposer<
    [
      ...TReturns,
      (
        | WormholeTransceiverReturns["send_message(pay,(byte[32],byte[32],byte[32],uint16,byte[32],byte[]),byte[])void"]
        | undefined
      ),
    ]
  >;

  /**
   * Calls the update_min_upgrade_delay(uint64,uint64)void ABI method.
   *
  * Schedule a change in the minimum delay needed for an upgrade.
  Automatically comes into effect at given timestamp.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateMinUpgradeDelay(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
      | WormholeTransceiverArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["update_min_upgrade_delay(uint64,uint64)void"] | undefined]
  >;

  /**
   * Calls the schedule_contract_upgrade(byte[32],uint64)void ABI method.
   *
  * Schedule the upgrade of the contract.
  The upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  scheduleContractUpgrade(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
      | WormholeTransceiverArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["schedule_contract_upgrade(byte[32],uint64)void"] | undefined]
  >;

  /**
   * Calls the cancel_contract_upgrade()void ABI method.
   *
   * Cancel the scheduled upgrade
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  cancelContractUpgrade(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["cancel_contract_upgrade()void"]
      | WormholeTransceiverArgs["tuple"]["cancel_contract_upgrade()void"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["cancel_contract_upgrade()void"] | undefined]
  >;

  /**
   * Calls the upgradable_admin_role()byte[16] ABI method.
   *
   * Returns the role identifier for the upgradeable admin role
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  upgradableAdminRole(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["upgradable_admin_role()byte[16]"]
      | WormholeTransceiverArgs["tuple"]["upgradable_admin_role()byte[16]"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["upgradable_admin_role()byte[16]"] | undefined]
  >;

  /**
   * Calls the max_for_min_upgrade_delay()uint64 ABI method.
   *
  * Returns the maximum delay allowed for the minimum upgrade delay
  This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  maxForMinUpgradeDelay(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["max_for_min_upgrade_delay()uint64"]
      | WormholeTransceiverArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["max_for_min_upgrade_delay()uint64"] | undefined]
  >;

  /**
   * Calls the get_active_min_upgrade_delay()uint64 ABI method.
   *
   * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getActiveMinUpgradeDelay(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["get_active_min_upgrade_delay()uint64"]
      | WormholeTransceiverArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["get_active_min_upgrade_delay()uint64"] | undefined]
  >;

  /**
   * Calls the grant_role(byte[16],address)void ABI method.
   *
  * Grant a role to an account
  Increases the MBR for the contract's ledger balance.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  grantRole(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["grant_role(byte[16],address)void"]
      | WormholeTransceiverArgs["tuple"]["grant_role(byte[16],address)void"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["grant_role(byte[16],address)void"] | undefined]
  >;

  /**
   * Calls the revoke_role(byte[16],address)void ABI method.
   *
  * Revokes a role from an account
  Reduces the MBR for the contract's ledger balance.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  revokeRole(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["revoke_role(byte[16],address)void"]
      | WormholeTransceiverArgs["tuple"]["revoke_role(byte[16],address)void"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["revoke_role(byte[16],address)void"] | undefined]
  >;

  /**
   * Calls the renounce_role(byte[16])void ABI method.
   *
  * Revokes a role from the caller
  Reduces the MBR for the contract's ledger balance.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  renounceRole(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["renounce_role(byte[16])void"]
      | WormholeTransceiverArgs["tuple"]["renounce_role(byte[16])void"]
    >,
  ): WormholeTransceiverComposer<[...TReturns, WormholeTransceiverReturns["renounce_role(byte[16])void"] | undefined]>;

  /**
   * Calls the default_admin_role()byte[16] ABI method.
   *
   * Returns the role identifier for the default admin role
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  defaultAdminRole(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["default_admin_role()byte[16]"]
      | WormholeTransceiverArgs["tuple"]["default_admin_role()byte[16]"]
    >,
  ): WormholeTransceiverComposer<[...TReturns, WormholeTransceiverReturns["default_admin_role()byte[16]"] | undefined]>;

  /**
   * Calls the has_role(byte[16],address)bool ABI method.
   *
   * Returns whether the account has been granted a role
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  hasRole(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["has_role(byte[16],address)bool"]
      | WormholeTransceiverArgs["tuple"]["has_role(byte[16],address)bool"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["has_role(byte[16],address)bool"] | undefined]
  >;

  /**
   * Calls the get_role_admin(byte[16])byte[16] ABI method.
   *
   * Returns the admin role that controls a role
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getRoleAdmin(
    params?: CallParams<
      | WormholeTransceiverArgs["obj"]["get_role_admin(byte[16])byte[16]"]
      | WormholeTransceiverArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
    >,
  ): WormholeTransceiverComposer<
    [...TReturns, WormholeTransceiverReturns["get_role_admin(byte[16])byte[16]"] | undefined]
  >;

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the WormholeTransceiver smart contract using the complete_contract_upgrade()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    completeContractUpgrade(
      params?: CallParams<
        | WormholeTransceiverArgs["obj"]["complete_contract_upgrade()void"]
        | WormholeTransceiverArgs["tuple"]["complete_contract_upgrade()void"]
      >,
    ): WormholeTransceiverComposer<
      [...TReturns, WormholeTransceiverReturns["complete_contract_upgrade()void"] | undefined]
    >;
  };

  /**
   * Makes a clear_state call to an existing instance of the WormholeTransceiver smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): WormholeTransceiverComposer<[...TReturns, undefined]>;

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): WormholeTransceiverComposer<TReturns>;
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>;
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<
    WormholeTransceiverComposerResults<TReturns> & {
      simulateResponse: modelsv2.SimulateResponse;
    }
  >;
  simulate(options: SkipSignaturesSimulateOptions): Promise<
    WormholeTransceiverComposerResults<TReturns> & {
      simulateResponse: modelsv2.SimulateResponse;
    }
  >;
  simulate(options: RawSimulateOptions): Promise<
    WormholeTransceiverComposerResults<TReturns> & {
      simulateResponse: modelsv2.SimulateResponse;
    }
  >;
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<WormholeTransceiverComposerResults<TReturns>>;
};
export type WormholeTransceiverComposerResults<TReturns extends [...any[]]> = Expand<
  SendAtomicTransactionComposerResults & {
    returns: TReturns;
  }
>;
