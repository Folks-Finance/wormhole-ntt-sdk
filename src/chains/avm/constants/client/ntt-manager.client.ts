/* eslint-disable */
// @ts-nocheck
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from "@algorandfoundation/algokit-utils/types/algorand-client";
import { ABIReturn, AppReturn, SendAppTransactionResult } from "@algorandfoundation/algokit-utils/types/app";
import {
  Arc56Contract,
  getArc56ReturnValue,
  getABIStructFromABITuple,
} from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from "@algorandfoundation/algokit-utils/types/app-client";
import {
  AppFactory as _AppFactory,
  AppFactoryAppClientParams,
  AppFactoryResolveAppClientByCreatorAndNameParams,
  AppFactoryDeployParams,
  AppFactoryParams,
  CreateSchema,
} from "@algorandfoundation/algokit-utils/types/app-factory";
import {
  TransactionComposer,
  AppCallMethodCall,
  AppMethodCallTransactionArgument,
  SimulateOptions,
  RawSimulateOptions,
  SkipSignaturesSimulateOptions,
} from "@algorandfoundation/algokit-utils/types/composer";
import {
  SendParams,
  SendSingleTransactionResult,
  SendAtomicTransactionComposerResults,
} from "@algorandfoundation/algokit-utils/types/transaction";
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from "algosdk";

export const APP_SPEC: Arc56Contract = {
  name: "NttManager",
  structs: {
    AddressRoleKey: [
      { name: "role", type: "byte[16]" },
      { name: "address", type: "address" },
    ],
    RateLimitBucket: [
      { name: "limit", type: "uint256" },
      { name: "currentCapacity", type: "uint256" },
      { name: "duration", type: "uint64" },
      { name: "lastUpdated", type: "uint64" },
    ],
    MinimumUpgradeDelay: [
      { name: "delay_0", type: "uint64" },
      { name: "delay_1", type: "uint64" },
      { name: "timestamp", type: "uint64" },
    ],
    ScheduledContractUpgrade: [
      { name: "programSha256", type: "byte[32]" },
      { name: "timestamp", type: "uint64" },
    ],
    InboundQueuedTransfer: [
      { name: "timestamp", type: "uint64" },
      { name: "amount", type: "TrimmedAmount" },
      { name: "sourceChain", type: "uint16" },
      { name: "recipient", type: "address" },
    ],
    OutboundQueuedTransfer: [
      { name: "timestamp", type: "uint64" },
      { name: "amount", type: "TrimmedAmount" },
      { name: "recipientChain", type: "uint16" },
      { name: "recipient", type: "byte[32]" },
      { name: "sender", type: "address" },
      { name: "transceiverInstructions", type: "(uint64,byte[])[]" },
    ],
    NttManagerPeer: [
      { name: "peerContract", type: "byte[32]" },
      { name: "decimals", type: "uint8" },
    ],
    MessageReceived: [
      { name: "id", type: "byte[32]" },
      { name: "userAddress", type: "byte[32]" },
      { name: "sourceChainId", type: "uint16" },
      { name: "sourceAddress", type: "byte[32]" },
      { name: "handlerAddress", type: "byte[32]" },
      { name: "payload", type: "byte[]" },
    ],
    TrimmedAmount: [
      { name: "amount", type: "uint64" },
      { name: "decimals", type: "uint8" },
    ],
  },
  methods: [
    {
      name: "create",
      args: [
        { type: "uint64", name: "ntt_token" },
        { type: "uint16", name: "chain_id" },
        { type: "uint64", name: "threshold" },
        { type: "uint64", name: "min_upgrade_delay" },
      ],
      returns: { type: "void" },
      actions: { create: ["NoOp"], call: [] },
      readonly: false,
      events: [
        {
          name: "ThresholdUpdated",
          args: [{ type: "uint64", name: "threshold" }],
        },
      ],
      recommendations: {},
    },
    {
      name: "initialise",
      args: [
        { type: "address", name: "admin" },
        { type: "uint64", name: "transceiver_manager" },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "BucketAdded",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint256", name: "limit" },
            { type: "uint64", name: "duration" },
          ],
        },
        {
          name: "RoleGranted",
          args: [
            { type: "byte[16]", name: "role" },
            { type: "address", name: "account" },
            { type: "address", name: "sender" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "pause",
      args: [],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Pause incoming and outgoing transfers in case of emergency.",
      events: [{ name: "Paused", args: [{ type: "bool", name: "is_paused" }] }],
      recommendations: {},
    },
    {
      name: "unpause",
      args: [],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Resume incoming and outgoing transfers after previous pause.",
      events: [{ name: "Paused", args: [{ type: "bool", name: "is_paused" }] }],
      recommendations: {},
    },
    {
      name: "set_transceiver_manager",
      args: [
        { type: "address", name: "admin_in_transceiver_manager" },
        { type: "uint64", name: "transceiver_manager" },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "TransceiverManagerUpdated",
          args: [{ type: "uint64", name: "transceiver_manager" }],
        },
      ],
      recommendations: {},
    },
    {
      name: "set_threshold",
      args: [{ type: "uint64", name: "new_threshold" }],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "ThresholdUpdated",
          args: [{ type: "uint64", name: "threshold" }],
        },
      ],
      recommendations: {},
    },
    {
      name: "set_ntt_manager_peer",
      args: [
        { type: "uint16", name: "peer_chain_id" },
        { type: "byte[32]", name: "peer_contract" },
        { type: "uint8", name: "peer_decimals" },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "BucketAdded",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint256", name: "limit" },
            { type: "uint64", name: "duration" },
          ],
        },
        {
          name: "NttManagerPeerSet",
          args: [
            { type: "uint16", name: "peer_chain_id" },
            { type: "byte[32]", name: "peer_contract" },
            { type: "uint8", name: "peer_decimals" },
            { type: "bool", name: "is_new" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "transfer",
      args: [
        { type: "pay", name: "fee_payment" },
        { type: "axfer", name: "send_token" },
        { type: "uint64", name: "amount" },
        { type: "uint16", name: "recipient_chain" },
        { type: "byte[32]", name: "recipient" },
      ],
      returns: { type: "byte[32]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "OutboundTransferRateLimited",
          args: [
            { type: "address", name: "sender" },
            { type: "byte[32]", name: "message_id" },
            { type: "uint256", name: "current_capacity" },
            { type: "uint64", name: "amount" },
          ],
        },
        {
          name: "BucketConsumed",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint256", name: "amount" },
          ],
        },
        {
          name: "BucketFilled",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint256", name: "requested_amount" },
            { type: "uint256", name: "actual_amount" },
          ],
        },
        {
          name: "TransferSent",
          args: [
            { type: "byte[32]", name: "message_id" },
            { type: "byte[32]", name: "recipient" },
            { type: "uint16", name: "recipient_chain" },
            { type: "uint64", name: "amount" },
            { type: "uint64", name: "fee" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "transfer_full",
      args: [
        { type: "pay", name: "fee_payment" },
        { type: "axfer", name: "send_token" },
        { type: "uint64", name: "amount" },
        { type: "uint16", name: "recipient_chain" },
        { type: "byte[32]", name: "recipient" },
        { type: "bool", name: "should_queue" },
        { type: "(uint64,byte[])[]", name: "transceiver_instructions" },
      ],
      returns: { type: "byte[32]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "OutboundTransferRateLimited",
          args: [
            { type: "address", name: "sender" },
            { type: "byte[32]", name: "message_id" },
            { type: "uint256", name: "current_capacity" },
            { type: "uint64", name: "amount" },
          ],
        },
        {
          name: "BucketConsumed",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint256", name: "amount" },
          ],
        },
        {
          name: "BucketFilled",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint256", name: "requested_amount" },
            { type: "uint256", name: "actual_amount" },
          ],
        },
        {
          name: "TransferSent",
          args: [
            { type: "byte[32]", name: "message_id" },
            { type: "byte[32]", name: "recipient" },
            { type: "uint16", name: "recipient_chain" },
            { type: "uint64", name: "amount" },
            { type: "uint64", name: "fee" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "complete_outbound_queued_transfer",
      args: [
        { type: "pay", name: "fee_payment" },
        { type: "byte[32]", name: "message_id" },
      ],
      returns: { type: "byte[32]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "OutboundTransferDeleted",
          args: [{ type: "byte[32]", name: "message_id" }],
        },
        {
          name: "TransferSent",
          args: [
            { type: "byte[32]", name: "message_id" },
            { type: "byte[32]", name: "recipient" },
            { type: "uint16", name: "recipient_chain" },
            { type: "uint64", name: "amount" },
            { type: "uint64", name: "fee" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "cancel_outbound_queued_transfer",
      args: [{ type: "byte[32]", name: "message_id" }],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "OutboundTransferDeleted",
          args: [{ type: "byte[32]", name: "message_id" }],
        },
      ],
      recommendations: {},
    },
    {
      name: "complete_inbound_queued_transfer",
      args: [{ type: "byte[32]", name: "message_digest" }],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      events: [
        {
          name: "InboundTransferDeleted",
          args: [{ type: "byte[32]", name: "message_digest" }],
        },
      ],
      recommendations: {},
    },
    {
      name: "ntt_manager_admin_role",
      args: [],
      returns: { type: "byte[16]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      events: [],
      recommendations: {},
    },
    {
      name: "pauser_role",
      args: [],
      returns: { type: "byte[16]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      events: [],
      recommendations: {},
    },
    {
      name: "unpauser_role",
      args: [],
      returns: { type: "byte[16]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      events: [],
      recommendations: {},
    },
    {
      name: "get_ntt_manager_peer",
      args: [{ type: "uint16", name: "chain_id" }],
      returns: { type: "(byte[32],uint8)", struct: "NttManagerPeer" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      events: [],
      recommendations: {},
    },
    {
      name: "execute_message",
      args: [
        {
          type: "(byte[32],byte[32],uint16,byte[32],byte[32],byte[])",
          struct: "MessageReceived",
          name: "message",
          desc: "The message to execute",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Execute a message once the threshold number of attestations has been reached.",
      events: [
        {
          name: "InboundTransferRateLimited",
          args: [
            { type: "address", name: "recipient" },
            { type: "byte[32]", name: "message_digest" },
            { type: "uint256", name: "current_capacity" },
            { type: "uint64", name: "amount" },
          ],
        },
        {
          name: "BucketConsumed",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint256", name: "amount" },
          ],
        },
        {
          name: "BucketFilled",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint256", name: "requested_amount" },
            { type: "uint256", name: "actual_amount" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "is_message_approved",
      args: [
        {
          type: "byte[32]",
          name: "message_digest",
          desc: "The message digest",
        },
      ],
      returns: { type: "bool" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns whether a message has been approved.",
      events: [],
      recommendations: {},
    },
    {
      name: "is_message_executed",
      args: [
        {
          type: "byte[32]",
          name: "message_digest",
          desc: "The message digest",
        },
      ],
      returns: { type: "bool" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns whether a message has been executed.\nNote that a message can be executed without being approved if the threshold is increased after execution.",
      events: [],
      recommendations: {},
    },
    {
      name: "set_outbound_rate_limit",
      args: [{ type: "uint256", name: "new_limit", desc: "The rate limit to set" }],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Set limit for outbound bucket.",
      events: [
        {
          name: "BucketRateLimitUpdated",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint256", name: "limit" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "set_outbound_rate_duration",
      args: [{ type: "uint64", name: "new_duration", desc: "The duration to set" }],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Set duration for outbound bucket.",
      events: [
        {
          name: "BucketRateDurationUpdated",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint64", name: "duration" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "set_inbound_rate_limit",
      args: [
        {
          type: "uint16",
          name: "chain_id",
          desc: "The chain id to set the limit for",
        },
        { type: "uint256", name: "new_limit", desc: "The limit to set" },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Set limit for inbound bucket of the given chain.",
      events: [
        {
          name: "BucketRateLimitUpdated",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint256", name: "limit" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "set_inbound_rate_duration",
      args: [
        {
          type: "uint16",
          name: "chain_id",
          desc: "The chain id to set the duration for",
        },
        { type: "uint64", name: "new_duration", desc: "The duration to set" },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Set duration for inbound bucket of the given chain.",
      events: [
        {
          name: "BucketRateDurationUpdated",
          args: [
            { type: "byte[32]", name: "bucket_id" },
            { type: "uint64", name: "duration" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "get_current_outbound_capacity",
      args: [],
      returns: { type: "uint256" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the current capacity of the outbound.",
      events: [],
      recommendations: {},
    },
    {
      name: "get_outbound_queued_transfer",
      args: [
        {
          type: "byte[32]",
          name: "message_id",
          desc: "The Ntt defined identifier for a message to send",
        },
      ],
      returns: {
        type: "(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))",
        desc: "Tuple of whether the transfer can be completed and the details of the transfer request.",
      },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Get the details of an outbound queued transfer.",
      events: [],
      recommendations: {},
    },
    {
      name: "get_current_inbound_capacity",
      args: [
        {
          type: "uint16",
          name: "chain_id",
          desc: "The chain id to get the capacity of",
        },
      ],
      returns: { type: "uint256" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the current capacity of the inbound bucket of the given chain.",
      events: [],
      recommendations: {},
    },
    {
      name: "get_inbound_queued_transfer",
      args: [
        {
          type: "byte[32]",
          name: "message_digest",
          desc: "Unique identifier of the message received.",
        },
      ],
      returns: {
        type: "(bool,(uint64,(uint64,uint8),uint16,address))",
        desc: "Tuple of whether the transfer can be completed and the details of the transfer request.",
      },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Get the details of an inbound queued transfer.",
      events: [],
      recommendations: {},
    },
    {
      name: "inbound_bucket_id",
      args: [{ type: "uint16", name: "chain_id" }],
      returns: { type: "byte[32]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      events: [],
      recommendations: {},
    },
    {
      name: "outbound_bucket_id",
      args: [],
      returns: { type: "byte[32]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      events: [],
      recommendations: {},
    },
    {
      name: "rate_limiter_manager_role",
      args: [],
      returns: { type: "byte[16]" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      events: [],
      recommendations: {},
    },
    {
      name: "get_current_capacity",
      args: [
        {
          type: "byte[32]",
          name: "bucket_id",
          desc: "The bucket to get the current capacity for.",
        },
      ],
      returns: { type: "uint256" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the current capacity of the bucket were it to be updated.\nIf you call this method (as opposed to simulate) then the capacity will be updated on chain.\nYou should NOT use this method to determine if there is sufficient capacity because a `duration` of zero is interpreted as an infinite bucket regardless of the `current_capacity. Instead, use `has_capacity()`.",
      events: [],
      recommendations: {},
    },
    {
      name: "has_capacity",
      args: [
        {
          type: "byte[32]",
          name: "bucket_id",
          desc: "The bucket to consume from.",
        },
        { type: "uint256", name: "amount", desc: "The amount to consume." },
      ],
      returns: { type: "bool" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns whether there's sufficient capacity inside bucket for amount.\nIf you call this method (as opposed to simulate) then the capacity will be updated on chain.",
      events: [],
      recommendations: {},
    },
    {
      name: "get_rate_limit",
      args: [
        {
          type: "byte[32]",
          name: "bucket_id",
          desc: "The bucket to get the rate limit of",
        },
      ],
      returns: { type: "uint256" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the rate limit of the bucket",
      events: [],
      recommendations: {},
    },
    {
      name: "get_rate_duration",
      args: [
        {
          type: "byte[32]",
          name: "bucket_id",
          desc: "The bucket to get the rate duration of",
        },
      ],
      returns: { type: "uint64" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the rate duration of the bucket",
      events: [],
      recommendations: {},
    },
    {
      name: "update_min_upgrade_delay",
      args: [
        { type: "uint64", name: "min_upgrade_delay", desc: "The new delay" },
        {
          type: "uint64",
          name: "timestamp",
          desc: "The timestamp to schedule the change",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Schedule a change in the minimum delay needed for an upgrade.\nAutomatically comes into effect at given timestamp.",
      events: [
        {
          name: "MinimumUpgradeDelayChange",
          args: [
            { type: "uint64", name: "delay" },
            { type: "uint64", name: "timestamp" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "schedule_contract_upgrade",
      args: [
        {
          type: "byte[32]",
          name: "program_sha256",
          desc: "The SHA256 of the new program",
        },
        {
          type: "uint64",
          name: "timestamp",
          desc: "The timestamp to schedule the upgrade",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Schedule the upgrade of the contract.\nThe upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.",
      events: [
        {
          name: "UpgradeScheduled",
          args: [
            { type: "byte[32]", name: "program_sha256" },
            { type: "uint64", name: "timestamp" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "cancel_contract_upgrade",
      args: [],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Cancel the scheduled upgrade",
      events: [
        {
          name: "UpgradeCancelled",
          args: [
            { type: "byte[32]", name: "program_sha256" },
            { type: "uint64", name: "timestamp" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "complete_contract_upgrade",
      args: [],
      returns: { type: "void" },
      actions: { create: [], call: ["UpdateApplication"] },
      readonly: false,
      desc: "Complete the scheduled upgrade",
      events: [
        {
          name: "UpgradeCompleted",
          args: [
            { type: "byte[32]", name: "program_sha256" },
            { type: "uint64", name: "version" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "upgradable_admin_role",
      args: [],
      returns: { type: "byte[16]", desc: "Role bytes of length 16" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the role identifier for the upgradeable admin role",
      events: [],
      recommendations: {},
    },
    {
      name: "max_for_min_upgrade_delay",
      args: [],
      returns: { type: "uint64", desc: "The maximum minimum upgrade delay" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the maximum delay allowed for the minimum upgrade delay\nThis is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.",
      events: [],
      recommendations: {},
    },
    {
      name: "get_active_min_upgrade_delay",
      args: [],
      returns: { type: "uint64", desc: "The active minimum upgrade delay" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Clarifies the active minimum upgrade delay in cases where there was a scheduled update.",
      events: [],
      recommendations: {},
    },
    {
      name: "grant_role",
      args: [
        { type: "byte[16]", name: "role", desc: "The role to grant" },
        {
          type: "address",
          name: "account",
          desc: "The account to grant the role to",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Grant a role to an account\nIncreases the MBR for the contract's ledger balance.",
      events: [
        {
          name: "RoleGranted",
          args: [
            { type: "byte[16]", name: "role" },
            { type: "address", name: "account" },
            { type: "address", name: "sender" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "revoke_role",
      args: [
        { type: "byte[16]", name: "role", desc: "The role to revoke" },
        {
          type: "address",
          name: "account",
          desc: "The account to revoke the role from",
        },
      ],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Revokes a role from an account\nReduces the MBR for the contract's ledger balance.",
      events: [
        {
          name: "RoleRevoked",
          args: [
            { type: "byte[16]", name: "role" },
            { type: "address", name: "account" },
            { type: "address", name: "sender" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "renounce_role",
      args: [{ type: "byte[16]", name: "role", desc: "The role to renounce" }],
      returns: { type: "void" },
      actions: { create: [], call: ["NoOp"] },
      readonly: false,
      desc: "Revokes a role from the caller\nReduces the MBR for the contract's ledger balance.",
      events: [
        {
          name: "RoleRevoked",
          args: [
            { type: "byte[16]", name: "role" },
            { type: "address", name: "account" },
            { type: "address", name: "sender" },
          ],
        },
      ],
      recommendations: {},
    },
    {
      name: "default_admin_role",
      args: [],
      returns: { type: "byte[16]", desc: "Empty bytes of length 16" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the role identifier for the default admin role",
      events: [],
      recommendations: {},
    },
    {
      name: "has_role",
      args: [
        { type: "byte[16]", name: "role", desc: "The role to check" },
        { type: "address", name: "account", desc: "The account to check" },
      ],
      returns: {
        type: "bool",
        desc: "Whether the account has been granted a role",
      },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns whether the account has been granted a role",
      events: [],
      recommendations: {},
    },
    {
      name: "get_role_admin",
      args: [
        {
          type: "byte[16]",
          name: "role",
          desc: "The role to get its admin of",
        },
      ],
      returns: { type: "byte[16]", desc: "The role admin" },
      actions: { create: [], call: ["NoOp"] },
      readonly: true,
      desc: "Returns the admin role that controls a role",
      events: [],
      recommendations: {},
    },
  ],
  arcs: [22, 28],
  networks: {},
  state: {
    schema: { global: { ints: 8, bytes: 3 }, local: { ints: 0, bytes: 0 } },
    keys: {
      global: {
        is_initialised: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "aXNfaW5pdGlhbGlzZWQ=",
        },
        min_upgrade_delay: {
          keyType: "AVMString",
          valueType: "MinimumUpgradeDelay",
          key: "bWluX3VwZ3JhZGVfZGVsYXk=",
        },
        scheduled_contract_upgrade: {
          keyType: "AVMString",
          valueType: "ScheduledContractUpgrade",
          key: "c2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGU=",
        },
        version: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "dmVyc2lvbg==",
        },
        transceiver_manager: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "dHJhbnNjZWl2ZXJfbWFuYWdlcg==",
        },
        threshold: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "dGhyZXNob2xk",
        },
        is_paused: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "aXNfcGF1c2Vk",
        },
        asset_id: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "YXNzZXRfaWQ=",
        },
        ntt_token: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "bnR0X3Rva2Vu",
        },
        message_sequence: {
          keyType: "AVMString",
          valueType: "AVMUint64",
          key: "bWVzc2FnZV9zZXF1ZW5jZQ==",
        },
        chain_id: {
          keyType: "AVMString",
          valueType: "uint16",
          key: "Y2hhaW5faWQ=",
        },
      },
      local: {},
      box: {},
    },
    maps: {
      global: {},
      local: {},
      box: {
        roles: {
          keyType: "byte[16]",
          valueType: "byte[16]",
          prefix: "cm9sZV8=",
        },
        addresses_roles: {
          keyType: "AddressRoleKey",
          valueType: "bool",
          prefix: "YWRkcmVzc19yb2xlc18=",
        },
        rate_limit_buckets: {
          keyType: "byte[32]",
          valueType: "RateLimitBucket",
          prefix: "cmF0ZV9saW1pdF9idWNrZXRzXw==",
        },
        outbound_queued_transfers: {
          keyType: "byte[32]",
          valueType: "OutboundQueuedTransfer",
          prefix: "b3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyc18=",
        },
        inbound_queued_transfers: {
          keyType: "byte[32]",
          valueType: "InboundQueuedTransfer",
          prefix: "aW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXJzXw==",
        },
        messages_executed: {
          keyType: "byte[32]",
          valueType: "bool",
          prefix: "bWVzc2FnZXNfZXhlY3V0ZWRf",
        },
        ntt_manager_peers: {
          keyType: "uint16",
          valueType: "NttManagerPeer",
          prefix: "bnR0X21hbmFnZXJfcGVlcl8=",
        },
      },
    },
  },
  bareActions: { create: [], call: [] },
  sourceInfo: {
    approval: {
      sourceInfo: [
        { pc: [5270], errorMessage: "Access control unauthorised account" },
        { pc: [1847], errorMessage: "Address length is 32 bytes" },
        { pc: [4590], errorMessage: "Bucket already exists" },
        { pc: [2864], errorMessage: "Caller must be the contract creator" },
        { pc: [2156], errorMessage: "Canceller is not original sender" },
        { pc: [2607], errorMessage: "Cannot set itself as peer chain" },
        { pc: [3941], errorMessage: "Cannot set zero threshold" },
        { pc: [3362], errorMessage: "Cannot transfer zero amount" },
        { pc: [2870], errorMessage: "Contract already initialised" },
        { pc: [2783], errorMessage: "Contract is not paused" },
        { pc: [3306], errorMessage: "Contract is paused" },
        { pc: [1150, 2986], errorMessage: "Delay exceeds maximum allowed" },
        { pc: [2046], errorMessage: "Inbound queued transfer is still queued" },
        { pc: [3359], errorMessage: "Incorrect asset amount" },
        { pc: [1815], errorMessage: "Incorrect prefix" },
        {
          pc: [4222],
          errorMessage: "Insufficient capacity for outbound queued transfer",
        },
        { pc: [4853], errorMessage: "Insufficient capacity to consume" },
        { pc: [3645], errorMessage: "Insufficient fee payment amount" },
        { pc: [2609], errorMessage: "Invalid peer decimals" },
        { pc: [3195], errorMessage: "Invalid program SHA256" },
        { pc: [3368], errorMessage: "Invalid recipient address" },
        { pc: [1861], errorMessage: "Invalid target chain" },
        { pc: [1778], errorMessage: "Message already executed" },
        { pc: [1764], errorMessage: "Message handler address mismatch" },
        { pc: [1771], errorMessage: "Message not approved" },
        {
          pc: [5174],
          errorMessage: "Must schedule at least min upgrade delay time in future",
        },
        { pc: [3334], errorMessage: "NttToken address unknown" },
        { pc: [487], errorMessage: "OnCompletion must be NoOp" },
        {
          pc: [3061],
          errorMessage: "OnCompletion must be UpdateApplication && can only call when not creating",
        },
        {
          pc: [2249],
          errorMessage: "Outbound queued transfer is still queued",
        },
        { pc: [3091], errorMessage: "Schedule complete ts not met" },
        { pc: [4048], errorMessage: "TransceiverManager address unknown" },
        { pc: [3434], errorMessage: "Transfer amount has dust" },
        {
          pc: [
            1029, 1084, 1139, 1498, 1539, 1572, 1600, 1791, 2035, 2137, 2238, 2592, 2693, 2727, 2755, 2802, 3066, 3315,
          ],
          errorMessage: "Uninitialised contract",
        },
        { pc: [3345, 3730], errorMessage: "Unknown asset" },
        { pc: [3351], errorMessage: "Unknown asset receiver" },
        { pc: [1253, 4569, 5126], errorMessage: "Unknown bucket" },
        { pc: [3326, 3636], errorMessage: "Unknown fee payment receiver" },
        { pc: [2056, 4154], errorMessage: "Unknown inbound queued transfer" },
        { pc: [4113, 4472], errorMessage: "Unknown outbound queued transfer" },
        { pc: [1806], errorMessage: "Unknown peer address" },
        { pc: [3296], errorMessage: "Unknown peer chain" },
        { pc: [1756], errorMessage: "Unsafe conversion of bytes32 to uint64" },
        { pc: [1040, 3083], errorMessage: "Upgrade not scheduled" },
        { pc: [3745, 3750], errorMessage: "account funded" },
        {
          pc: [1746, 3036, 3815, 3934, 4042],
          errorMessage: "application log value is not the result of an ABI return",
        },
        { pc: [5215], errorMessage: "check self.addresses_roles entry exists" },
        { pc: [3343, 3566, 3727], errorMessage: "check self.asset_id exists" },
        { pc: [1857, 2603], errorMessage: "check self.chain_id exists" },
        {
          pc: [
            1028, 1083, 1138, 1497, 1538, 1571, 1599, 1790, 2034, 2136, 2237, 2591, 2692, 2726, 2754, 2801, 2868, 3065,
            3314,
          ],
          errorMessage: "check self.is_initialised exists",
        },
        { pc: [2782, 3304], errorMessage: "check self.is_paused exists" },
        { pc: [3439], errorMessage: "check self.message_sequence exists" },
        {
          pc: [3882],
          errorMessage: "check self.messages_executed entry exists",
        },
        {
          pc: [1158, 1173, 1188, 5140],
          errorMessage: "check self.min_upgrade_delay exists",
        },
        {
          pc: [1907, 2100, 2191, 3331],
          errorMessage: "check self.ntt_token exists",
        },
        {
          pc: [4503],
          errorMessage: "check self.rate_limit_buckets entry exists",
        },
        { pc: [5250], errorMessage: "check self.roles entry exists" },
        { pc: [3825], errorMessage: "check self.threshold exists" },
        {
          pc: [1706, 3775, 3993],
          errorMessage: "check self.transceiver_manager exists",
        },
        { pc: [3203, 3217], errorMessage: "check self.version exists" },
        { pc: [2416], errorMessage: "invalid array encoding" },
        { pc: [1677, 2376, 2443], errorMessage: "invalid array length header" },
        {
          pc: [2367, 3928],
          errorMessage: "invalid number of bytes for arc4.bool",
        },
        {
          pc: [2465],
          errorMessage: "invalid number of bytes for arc4.dynamic_array<ntt_contracts.types.TransceiverInstruction>",
        },
        {
          pc: [824, 843, 895, 913, 947],
          errorMessage: "invalid number of bytes for arc4.static_array<arc4.uint8, 16>",
        },
        {
          pc: [
            851, 921, 955, 1069, 1226, 1245, 1272, 1298, 1402, 1445, 1623, 1641, 1739, 2030, 2132, 2233, 2357, 2538,
            2576, 2712, 2849,
          ],
          errorMessage: "invalid number of bytes for arc4.static_array<arc4.uint8, 32>",
        },
        {
          pc: [1383, 1422, 1484, 1526, 1938, 2347, 2530, 2566, 2958],
          errorMessage: "invalid number of bytes for arc4.uint16",
        },
        {
          pc: [1280, 1534, 1595],
          errorMessage: "invalid number of bytes for arc4.uint256",
        },
        {
          pc: [1077, 1121, 1133, 1492, 1566, 2333, 2520, 2687, 2720, 2857, 2948, 2966, 2975, 3029, 3808, 4035],
          errorMessage: "invalid number of bytes for arc4.uint64",
        },
        { pc: [2587], errorMessage: "invalid number of bytes for arc4.uint8" },
        {
          pc: [1685],
          errorMessage: "invalid number of bytes for ntt_contracts.types.MessageReceived",
        },
        {
          pc: [2439],
          errorMessage: "invalid tail pointer at index 1 of (uint64,(len+uint8[]))",
        },
        {
          pc: [1668],
          errorMessage:
            "invalid tail pointer at index 5 of (uint8[32],uint8[32],uint16,uint8[32],uint8[32],(len+uint8[]))",
        },
        {
          pc: [2424],
          errorMessage: "invalid tail pointer for (len+(uint64,(len+uint8[]))[])",
        },
        { pc: [1662, 2434], errorMessage: "invalid tuple encoding" },
        {
          pc: [1826, 3736, 4687, 4861, 4953, 4971, 5108],
          errorMessage: "overflow",
        },
        { pc: [2325, 2512], errorMessage: "transaction type is axfer" },
        { pc: [2225, 2312, 2501], errorMessage: "transaction type is pay" },
      ],
      pcOffsetMethod: "none",
    },
    clear: { sourceInfo: [], pcOffsetMethod: "none" },
  },
  source: {
    approval:
      "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMzIgOCAxMjA5NjAwCiAgICBieXRlY2Jsb2NrIDB4MDAgMHgxNTFmN2M3NSAiaXNfaW5pdGlhbGlzZWQiIDB4NzI2MTc0NjU1ZjZjNjk2ZDY5NzQ1ZjYyNzU2MzZiNjU3NDczNWYgMHhkNDZlYzNiOGJkNTQ0ZmJkZDJhMWFhYjBkZGU3ZjMwNzhhNjY2ODhmMzg1MmVkMDUwYmRkNzlhZDZiYWQ2MzliIDB4NDk0ZTQyNGY1NTRlNDQ1ZiAibWluX3VwZ3JhZGVfZGVsYXkiIDB4ODAgImlzX3BhdXNlZCIgMHhjZjhjZDMyN2I4YTJlOGUwNTEyYTM5NmRiYTlmMDA3YiAic2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUiIDB4YmFmYzZjZTkyZDQ2NDMzZmM1YjgyYTk3MzcxOWU5ODYgIm50dF90b2tlbiIgInZlcnNpb24iICJ0cmFuc2NlaXZlcl9tYW5hZ2VyIiAweDZhNjczODA1YmFhNWRkOTU5MmVhYzM4ZWMzOTliODI4ICJhc3NldF9pZCIgIm1lc3NhZ2Vfc2VxdWVuY2UiICJjaGFpbl9pZCIgMHg0ODIwYjQ3OCAweDY5NmU2MjZmNzU2ZTY0NWY3MTc1NjU3NTY1NjQ1Zjc0NzI2MTZlNzM2NjY1NzI3MzVmIDB4NmY3NTc0NjI2Zjc1NmU2NDVmNzE3NTY1NzU2NTY0NWY3NDcyNjE2ZTczNjY2NTcyNzM1ZiAweDYxNjQ2NDcyNjU3MzczNWY3MjZmNmM2NTczNWYgMHg2ZDY1NzM3MzYxNjc2NTczNWY2NTc4NjU2Mzc1NzQ2NTY0NWYgMHg5OTRlNTQ1NCAweDZlNzQ3NDVmNmQ2MTZlNjE2NzY1NzI1ZjcwNjU2NTcyNWYgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIDB4MDAwMDAwMDAwMDAwMDAwMCAidGhyZXNob2xkIgogICAgaW50Y18wIC8vIDAKICAgIGR1cG4gMTMKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAxMAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0luaXRpYWxpc2FibGUucHk6NDQKICAgIC8vIHNlbGYuaXNfaW5pdGlhbGlzZWQgPSBGYWxzZQogICAgYnl0ZWNfMiAvLyAiaXNfaW5pdGlhbGlzZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weTo3MAogICAgLy8gc2VsZi52ZXJzaW9uID0gVUludDY0KDEpCiAgICBieXRlYyAxMyAvLyAidmVyc2lvbiIKICAgIGludGNfMSAvLyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjU4CiAgICAvLyBzZWxmLmlzX3BhdXNlZCA9IEZhbHNlCiAgICBieXRlYyA4IC8vICJpc19wYXVzZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo2NC02NQogICAgLy8gIyBmb3IgbWVzc2FnZXMKICAgIC8vIHNlbGYubWVzc2FnZV9zZXF1ZW5jZSA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgMTcgLy8gIm1lc3NhZ2Vfc2VxdWVuY2UiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKCm1haW5fYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjUyCiAgICAvLyBjbGFzcyBOdHRNYW5hZ2VyKElOdHRNYW5hZ2VyLCBNZXNzYWdlSGFuZGxlciwgTnR0UmF0ZUxpbWl0ZXIsIFVwZ3JhZGVhYmxlKToKICAgIHB1c2hieXRlcyAweDhmYTM4ODhiIC8vIG1ldGhvZCAiY29tcGxldGVfY29udHJhY3RfdXBncmFkZSgpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fY29tcGxldGVfY29udHJhY3RfdXBncmFkZV9yb3V0ZUA0CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJ6IG1haW5fY3JlYXRlX05vT3BANTMKICAgIHB1c2hieXRlc3MgMHg1YWYwZjYxZiAweDAxNzhmOTRiIDB4MWI1MjlkZTggMHhkMmUwNWY0OSAweGNmYTRhOWI0IDB4ZDBjM2RhNDUgMHhhYzNmM2E4NCAweGJlYzVhZDAyIDB4ZDJiOTFmNzUgMHhiNmFkOGIxNyAweDVmZTAwMGZlIDB4ZTcyNjExMGMgMHg2YmFhZGExNyAweDQ2YTE3ODc1IDB4OGJmMDY1Y2MgMHg5NGU5MzA2NyAweDNlMWM5MDM3IDB4ZDhiNGU2OTQgMHhlYjMzZGU4YiAweGI2Yjg5NTI3IDB4YzY5YmQ4NmUgMHhmNGZlYzFlMyAweDkzZmM0NzQ3IDB4MTQyYTM0NzMgMHgyYTExOWMxMiAweDJkODAyNzdjIDB4ODhlNzY1ZTkgMHhiOGYxNDgzNCAweGYxMDliMWI0IDB4OTdhYzVhZTIgMHhiOGE1NmMyMSAweGI1MGQ2OWE0IDB4ZGNiOTcyYTggMHhlMDM0ZTk2YiAweDU2MzMxOTVlIDB4MTA4YjY4OTcgMHhmZmI4OTE0OCAweGQ5N2NlMzEwIDB4N2RlZGJjZDIgMHhkNzNiYTI0NCAweDcyYmEzMGVlIDB4MGU5NGRiZmMgMHg2N2JkNTIzNyAweGZkNjFhOGJlIDB4NTU1Nzc3ZjYgLy8gbWV0aG9kICJpbml0aWFsaXNlKGFkZHJlc3MsdWludDY0KXZvaWQiLCBtZXRob2QgInBhdXNlKCl2b2lkIiwgbWV0aG9kICJ1bnBhdXNlKCl2b2lkIiwgbWV0aG9kICJzZXRfdHJhbnNjZWl2ZXJfbWFuYWdlcihhZGRyZXNzLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJzZXRfdGhyZXNob2xkKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJzZXRfbnR0X21hbmFnZXJfcGVlcih1aW50MTYsYnl0ZVszMl0sdWludDgpdm9pZCIsIG1ldGhvZCAidHJhbnNmZXIocGF5LGF4ZmVyLHVpbnQ2NCx1aW50MTYsYnl0ZVszMl0pYnl0ZVszMl0iLCBtZXRob2QgInRyYW5zZmVyX2Z1bGwocGF5LGF4ZmVyLHVpbnQ2NCx1aW50MTYsYnl0ZVszMl0sYm9vbCwodWludDY0LGJ5dGVbXSlbXSlieXRlWzMyXSIsIG1ldGhvZCAiY29tcGxldGVfb3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyKHBheSxieXRlWzMyXSlieXRlWzMyXSIsIG1ldGhvZCAiY2FuY2VsX291dGJvdW5kX3F1ZXVlZF90cmFuc2ZlcihieXRlWzMyXSl2b2lkIiwgbWV0aG9kICJjb21wbGV0ZV9pbmJvdW5kX3F1ZXVlZF90cmFuc2ZlcihieXRlWzMyXSl2b2lkIiwgbWV0aG9kICJudHRfbWFuYWdlcl9hZG1pbl9yb2xlKClieXRlWzE2XSIsIG1ldGhvZCAicGF1c2VyX3JvbGUoKWJ5dGVbMTZdIiwgbWV0aG9kICJ1bnBhdXNlcl9yb2xlKClieXRlWzE2XSIsIG1ldGhvZCAiZ2V0X250dF9tYW5hZ2VyX3BlZXIodWludDE2KShieXRlWzMyXSx1aW50OCkiLCBtZXRob2QgImV4ZWN1dGVfbWVzc2FnZSgoYnl0ZVszMl0sYnl0ZVszMl0sdWludDE2LGJ5dGVbMzJdLGJ5dGVbMzJdLGJ5dGVbXSkpdm9pZCIsIG1ldGhvZCAiaXNfbWVzc2FnZV9hcHByb3ZlZChieXRlWzMyXSlib29sIiwgbWV0aG9kICJpc19tZXNzYWdlX2V4ZWN1dGVkKGJ5dGVbMzJdKWJvb2wiLCBtZXRob2QgInNldF9vdXRib3VuZF9yYXRlX2xpbWl0KHVpbnQyNTYpdm9pZCIsIG1ldGhvZCAic2V0X291dGJvdW5kX3JhdGVfZHVyYXRpb24odWludDY0KXZvaWQiLCBtZXRob2QgInNldF9pbmJvdW5kX3JhdGVfbGltaXQodWludDE2LHVpbnQyNTYpdm9pZCIsIG1ldGhvZCAic2V0X2luYm91bmRfcmF0ZV9kdXJhdGlvbih1aW50MTYsdWludDY0KXZvaWQiLCBtZXRob2QgImdldF9jdXJyZW50X291dGJvdW5kX2NhcGFjaXR5KCl1aW50MjU2IiwgbWV0aG9kICJnZXRfb3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyKGJ5dGVbMzJdKShib29sLCh1aW50NjQsKHVpbnQ2NCx1aW50OCksdWludDE2LGJ5dGVbMzJdLGFkZHJlc3MsKHVpbnQ2NCxieXRlW10pW10pKSIsIG1ldGhvZCAiZ2V0X2N1cnJlbnRfaW5ib3VuZF9jYXBhY2l0eSh1aW50MTYpdWludDI1NiIsIG1ldGhvZCAiZ2V0X2luYm91bmRfcXVldWVkX3RyYW5zZmVyKGJ5dGVbMzJdKShib29sLCh1aW50NjQsKHVpbnQ2NCx1aW50OCksdWludDE2LGFkZHJlc3MpKSIsIG1ldGhvZCAiaW5ib3VuZF9idWNrZXRfaWQodWludDE2KWJ5dGVbMzJdIiwgbWV0aG9kICJvdXRib3VuZF9idWNrZXRfaWQoKWJ5dGVbMzJdIiwgbWV0aG9kICJyYXRlX2xpbWl0ZXJfbWFuYWdlcl9yb2xlKClieXRlWzE2XSIsIG1ldGhvZCAiZ2V0X2N1cnJlbnRfY2FwYWNpdHkoYnl0ZVszMl0pdWludDI1NiIsIG1ldGhvZCAiaGFzX2NhcGFjaXR5KGJ5dGVbMzJdLHVpbnQyNTYpYm9vbCIsIG1ldGhvZCAiZ2V0X3JhdGVfbGltaXQoYnl0ZVszMl0pdWludDI1NiIsIG1ldGhvZCAiZ2V0X3JhdGVfZHVyYXRpb24oYnl0ZVszMl0pdWludDY0IiwgbWV0aG9kICJ1cGRhdGVfbWluX3VwZ3JhZGVfZGVsYXkodWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJzY2hlZHVsZV9jb250cmFjdF91cGdyYWRlKGJ5dGVbMzJdLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJjYW5jZWxfY29udHJhY3RfdXBncmFkZSgpdm9pZCIsIG1ldGhvZCAidXBncmFkYWJsZV9hZG1pbl9yb2xlKClieXRlWzE2XSIsIG1ldGhvZCAibWF4X2Zvcl9taW5fdXBncmFkZV9kZWxheSgpdWludDY0IiwgbWV0aG9kICJnZXRfYWN0aXZlX21pbl91cGdyYWRlX2RlbGF5KCl1aW50NjQiLCBtZXRob2QgImdyYW50X3JvbGUoYnl0ZVsxNl0sYWRkcmVzcyl2b2lkIiwgbWV0aG9kICJyZXZva2Vfcm9sZShieXRlWzE2XSxhZGRyZXNzKXZvaWQiLCBtZXRob2QgInJlbm91bmNlX3JvbGUoYnl0ZVsxNl0pdm9pZCIsIG1ldGhvZCAiZGVmYXVsdF9hZG1pbl9yb2xlKClieXRlWzE2XSIsIG1ldGhvZCAiaGFzX3JvbGUoYnl0ZVsxNl0sYWRkcmVzcylib29sIiwgbWV0aG9kICJnZXRfcm9sZV9hZG1pbihieXRlWzE2XSlieXRlWzE2XSIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5faW5pdGlhbGlzZV9yb3V0ZUA3IG1haW5fcGF1c2Vfcm91dGVAOCBtYWluX3VucGF1c2Vfcm91dGVAOSBtYWluX3NldF90cmFuc2NlaXZlcl9tYW5hZ2VyX3JvdXRlQDEwIG1haW5fc2V0X3RocmVzaG9sZF9yb3V0ZUAxMSBtYWluX3NldF9udHRfbWFuYWdlcl9wZWVyX3JvdXRlQDEyIG1haW5fdHJhbnNmZXJfcm91dGVAMTMgbWFpbl90cmFuc2Zlcl9mdWxsX3JvdXRlQDE0IG1haW5fY29tcGxldGVfb3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyX3JvdXRlQDE1IG1haW5fY2FuY2VsX291dGJvdW5kX3F1ZXVlZF90cmFuc2Zlcl9yb3V0ZUAxNiBtYWluX2NvbXBsZXRlX2luYm91bmRfcXVldWVkX3RyYW5zZmVyX3JvdXRlQDE3IG1haW5fbnR0X21hbmFnZXJfYWRtaW5fcm9sZV9yb3V0ZUAxOCBtYWluX3BhdXNlcl9yb2xlX3JvdXRlQDE5IG1haW5fdW5wYXVzZXJfcm9sZV9yb3V0ZUAyMCBtYWluX2dldF9udHRfbWFuYWdlcl9wZWVyX3JvdXRlQDIxIG1haW5fZXhlY3V0ZV9tZXNzYWdlX3JvdXRlQDIyIG1haW5faXNfbWVzc2FnZV9hcHByb3ZlZF9yb3V0ZUAyMyBtYWluX2lzX21lc3NhZ2VfZXhlY3V0ZWRfcm91dGVAMjQgbWFpbl9zZXRfb3V0Ym91bmRfcmF0ZV9saW1pdF9yb3V0ZUAyNSBtYWluX3NldF9vdXRib3VuZF9yYXRlX2R1cmF0aW9uX3JvdXRlQDI2IG1haW5fc2V0X2luYm91bmRfcmF0ZV9saW1pdF9yb3V0ZUAyNyBtYWluX3NldF9pbmJvdW5kX3JhdGVfZHVyYXRpb25fcm91dGVAMjggbWFpbl9nZXRfY3VycmVudF9vdXRib3VuZF9jYXBhY2l0eV9yb3V0ZUAyOSBtYWluX2dldF9vdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXJfcm91dGVAMzAgbWFpbl9nZXRfY3VycmVudF9pbmJvdW5kX2NhcGFjaXR5X3JvdXRlQDMxIG1haW5fZ2V0X2luYm91bmRfcXVldWVkX3RyYW5zZmVyX3JvdXRlQDMyIG1haW5faW5ib3VuZF9idWNrZXRfaWRfcm91dGVAMzMgbWFpbl9vdXRib3VuZF9idWNrZXRfaWRfcm91dGVAMzQgbWFpbl9yYXRlX2xpbWl0ZXJfbWFuYWdlcl9yb2xlX3JvdXRlQDM1IG1haW5fZ2V0X2N1cnJlbnRfY2FwYWNpdHlfcm91dGVAMzYgbWFpbl9oYXNfY2FwYWNpdHlfcm91dGVAMzcgbWFpbl9nZXRfcmF0ZV9saW1pdF9yb3V0ZUAzOCBtYWluX2dldF9yYXRlX2R1cmF0aW9uX3JvdXRlQDM5IG1haW5fdXBkYXRlX21pbl91cGdyYWRlX2RlbGF5X3JvdXRlQDQwIG1haW5fc2NoZWR1bGVfY29udHJhY3RfdXBncmFkZV9yb3V0ZUA0MSBtYWluX2NhbmNlbF9jb250cmFjdF91cGdyYWRlX3JvdXRlQDQyIG1haW5fdXBncmFkYWJsZV9hZG1pbl9yb2xlX3JvdXRlQDQzIG1haW5fbWF4X2Zvcl9taW5fdXBncmFkZV9kZWxheV9yb3V0ZUA0NCBtYWluX2dldF9hY3RpdmVfbWluX3VwZ3JhZGVfZGVsYXlfcm91dGVANDUgbWFpbl9ncmFudF9yb2xlX3JvdXRlQDQ2IG1haW5fcmV2b2tlX3JvbGVfcm91dGVANDcgbWFpbl9yZW5vdW5jZV9yb2xlX3JvdXRlQDQ4IG1haW5fZGVmYXVsdF9hZG1pbl9yb2xlX3JvdXRlQDQ5IG1haW5faGFzX3JvbGVfcm91dGVANTAgbWFpbl9nZXRfcm9sZV9hZG1pbl9yb3V0ZUA1MQogICAgZXJyCgptYWluX2dldF9yb2xlX2FkbWluX3JvdXRlQDUxOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTI1CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAxNiAvLyAxNgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMTY+CiAgICBjYWxsc3ViIGdldF9yb2xlX2FkbWluCiAgICBwb3AKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faGFzX3JvbGVfcm91dGVANTA6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxMTEKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAxNj4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgY2FsbHN1YiBoYXNfcm9sZQogICAgcG9wCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2RlZmF1bHRfYWRtaW5fcm9sZV9yb3V0ZUA0OToKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjEwMgogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3Jlbm91bmNlX3JvbGVfcm91dGVANDg6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weTo5MQogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDE2PgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTAwCiAgICAvLyBzZWxmLl9yZXZva2Vfcm9sZShyb2xlLCBBZGRyZXNzKFR4bi5zZW5kZXIpKQogICAgdHhuIFNlbmRlcgogICAgY2FsbHN1YiBfcmV2b2tlX3JvbGUKICAgIHBvcG4gMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6OTEKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcmV2b2tlX3JvbGVfcm91dGVANDc6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weTo3NQogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDE2PgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weTo4OAogICAgLy8gc2VsZi5fY2hlY2tfc2VuZGVyX3JvbGUoc2VsZi5nZXRfcm9sZV9hZG1pbihyb2xlKSkKICAgIHN3YXAKICAgIGNhbGxzdWIgZ2V0X3JvbGVfYWRtaW4KICAgIHN3YXAKICAgIGNhbGxzdWIgX2NoZWNrX3NlbmRlcl9yb2xlCiAgICBwb3AKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5Ojg5CiAgICAvLyBzZWxmLl9yZXZva2Vfcm9sZShyb2xlLCBhY2NvdW50KQogICAgc3dhcAogICAgY2FsbHN1YiBfcmV2b2tlX3JvbGUKICAgIHBvcG4gMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6NzUKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ3JhbnRfcm9sZV9yb3V0ZUA0NjoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjU5CiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAxNiAvLyAxNgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMTY+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjcyCiAgICAvLyBzZWxmLl9jaGVja19zZW5kZXJfcm9sZShzZWxmLmdldF9yb2xlX2FkbWluKHJvbGUpKQogICAgc3dhcAogICAgY2FsbHN1YiBnZXRfcm9sZV9hZG1pbgogICAgc3dhcAogICAgY2FsbHN1YiBfY2hlY2tfc2VuZGVyX3JvbGUKICAgIHBvcAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6NzMKICAgIC8vIHNlbGYuX2dyYW50X3JvbGUocm9sZSwgYWNjb3VudCkKICAgIHN3YXAKICAgIGNhbGxzdWIgX2dyYW50X3JvbGUKICAgIHBvcG4gMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6NTkKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0X2FjdGl2ZV9taW5fdXBncmFkZV9kZWxheV9yb3V0ZUA0NToKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMTMKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGNhbGxzdWIgZ2V0X2FjdGl2ZV9taW5fdXBncmFkZV9kZWxheQogICAgaXRvYgogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9tYXhfZm9yX21pbl91cGdyYWRlX2RlbGF5X3JvdXRlQDQ0OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIwMQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzUwMDAwMDAwMDAwMTI3NTAwCiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fdXBncmFkYWJsZV9hZG1pbl9yb2xlX3JvdXRlQDQzOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE5MgogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzVjZjhjZDMyN2I4YTJlOGUwNTEyYTM5NmRiYTlmMDA3YgogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NhbmNlbF9jb250cmFjdF91cGdyYWRlX3JvdXRlQDQyOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0luaXRpYWxpc2FibGUucHk6NjMKICAgIC8vIGFzc2VydCBzZWxmLmlzX2luaXRpYWxpc2VkLCAiVW5pbml0aWFsaXNlZCBjb250cmFjdCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19pbml0aWFsaXNlZCBleGlzdHMKICAgIGFzc2VydCAvLyBVbmluaXRpYWxpc2VkIGNvbnRyYWN0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTk5CiAgICAvLyByZXR1cm4gQnl0ZXMxNi5mcm9tX2J5dGVzKG9wLmV4dHJhY3Qob3Aua2VjY2FrMjU2KGIiVVBHUkFERUFCTEVfQURNSU4iKSwgMCwgY29uc3QuQllURVMxNl9MRU5HVEgpKQogICAgYnl0ZWMgOSAvLyAweGNmOGNkMzI3YjhhMmU4ZTA1MTJhMzk2ZGJhOWYwMDdiCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTQ4CiAgICAvLyBzZWxmLl9jaGVja19zZW5kZXJfcm9sZShzZWxmLnVwZ3JhZGFibGVfYWRtaW5fcm9sZSgpKQogICAgY2FsbHN1YiBfY2hlY2tfc2VuZGVyX3JvbGUKICAgIHBvcAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIzOAogICAgLy8gZXhpc3RzID0gc2VsZi5zY2hlZHVsZWRfY29udHJhY3RfdXBncmFkZS5tYXliZSgpWzFdCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTAgLy8gInNjaGVkdWxlZF9jb250cmFjdF91cGdyYWRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMzkKICAgIC8vIGFzc2VydCBleGlzdHMsICJVcGdyYWRlIG5vdCBzY2hlZHVsZWQiCiAgICBhc3NlcnQgLy8gVXBncmFkZSBub3Qgc2NoZWR1bGVkCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTUyCiAgICAvLyBwcm9ncmFtX3NoYTI1NiA9IHNlbGYuc2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUudmFsdWUucHJvZ3JhbV9zaGEyNTYuY29weSgpCiAgICBleHRyYWN0IDAgMzIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxNTMKICAgIC8vIGRlbCBzZWxmLnNjaGVkdWxlZF9jb250cmFjdF91cGdyYWRlLnZhbHVlCiAgICBieXRlYyAxMCAvLyAic2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUiCiAgICBhcHBfZ2xvYmFsX2RlbAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE1NQogICAgLy8gZW1pdChVcGdyYWRlQ2FuY2VsbGVkKHByb2dyYW1fc2hhMjU2LCBBUkM0VUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSkpCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDAwYTZjOGYxIC8vIG1ldGhvZCAiVXBncmFkZUNhbmNlbGxlZChieXRlWzMyXSx1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMzgKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc2NoZWR1bGVfY29udHJhY3RfdXBncmFkZV9yb3V0ZUA0MToKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMTEKICAgIC8vIEBhYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgZHVwCiAgICBidG9pCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxOTkKICAgIC8vIHJldHVybiBCeXRlczE2LmZyb21fYnl0ZXMob3AuZXh0cmFjdChvcC5rZWNjYWsyNTYoYiJVUEdSQURFQUJMRV9BRE1JTiIpLCAwLCBjb25zdC5CWVRFUzE2X0xFTkdUSCkpCiAgICBieXRlYyA5IC8vIDB4Y2Y4Y2QzMjdiOGEyZThlMDUxMmEzOTZkYmE5ZjAwN2IKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMjgKICAgIC8vIHNlbGYuX2NoZWNrX3NlbmRlcl9yb2xlKHNlbGYudXBncmFkYWJsZV9hZG1pbl9yb2xlKCkpCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTMwLTEzMQogICAgLy8gIyBlbnN1cmUgdGltZXN0YW1wIGlzIHN1ZmZpY2llbnRseSBpbiB0aGUgZnV0dXJlCiAgICAvLyBzZWxmLl9jaGVja19zY2hlZHVsZV90aW1lc3RhbXAodGltZXN0YW1wKQogICAgY2FsbHN1YiBfY2hlY2tfc2NoZWR1bGVfdGltZXN0YW1wCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTMzLTEzNAogICAgLy8gIyBzY2hlZHVsZSBjb250cmFjdCB1cGdyYWRlLCBwb3NzaWJseSBvdmVycmlkaW5nIGV4aXN0aW5nIHNjaGVkdWxlZCB1cGdyYWRlCiAgICAvLyBzZWxmLnNjaGVkdWxlZF9jb250cmFjdF91cGdyYWRlLnZhbHVlID0gU2NoZWR1bGVkQ29udHJhY3RVcGdyYWRlKHByb2dyYW1fc2hhMjU2LmNvcHkoKSwgQVJDNFVJbnQ2NCh0aW1lc3RhbXApKQogICAgY29uY2F0CiAgICBieXRlYyAxMCAvLyAic2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUiCiAgICBkaWcgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMzYKICAgIC8vIGVtaXQoVXBncmFkZVNjaGVkdWxlZChwcm9ncmFtX3NoYTI1NiwgQVJDNFVJbnQ2NCh0aW1lc3RhbXApKSkKICAgIHB1c2hieXRlcyAweDkwOGJjNTUxIC8vIG1ldGhvZCAiVXBncmFkZVNjaGVkdWxlZChieXRlWzMyXSx1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMTEKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fdXBkYXRlX21pbl91cGdyYWRlX2RlbGF5X3JvdXRlQDQwOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5Ojc4CiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGJ1cnkgMTUKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgYnVyeSAxNQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0luaXRpYWxpc2FibGUucHk6NjMKICAgIC8vIGFzc2VydCBzZWxmLmlzX2luaXRpYWxpc2VkLCAiVW5pbml0aWFsaXNlZCBjb250cmFjdCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19pbml0aWFsaXNlZCBleGlzdHMKICAgIGFzc2VydCAvLyBVbmluaXRpYWxpc2VkIGNvbnRyYWN0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTk5CiAgICAvLyByZXR1cm4gQnl0ZXMxNi5mcm9tX2J5dGVzKG9wLmV4dHJhY3Qob3Aua2VjY2FrMjU2KGIiVVBHUkFERUFCTEVfQURNSU4iKSwgMCwgY29uc3QuQllURVMxNl9MRU5HVEgpKQogICAgYnl0ZWMgOSAvLyAweGNmOGNkMzI3YjhhMmU4ZTA1MTJhMzk2ZGJhOWYwMDdiCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6OTMKICAgIC8vIHNlbGYuX2NoZWNrX3NlbmRlcl9yb2xlKHNlbGYudXBncmFkYWJsZV9hZG1pbl9yb2xlKCkpCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjI4CiAgICAvLyBhc3NlcnQgbWluX3VwZ3JhZGVfZGVsYXkgPD0gc2VsZi5tYXhfZm9yX21pbl91cGdyYWRlX2RlbGF5KCksICJEZWxheSBleGNlZWRzIG1heGltdW0gYWxsb3dlZCIKICAgIHN3YXAKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMTEKICAgIC8vIHJldHVybiBVSW50NjQoVFdPX1dFRUtTX0lOX1NFQ09ORFMpCiAgICBpbnRjIDQgLy8gMTIwOTYwMAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIyOAogICAgLy8gYXNzZXJ0IG1pbl91cGdyYWRlX2RlbGF5IDw9IHNlbGYubWF4X2Zvcl9taW5fdXBncmFkZV9kZWxheSgpLCAiRGVsYXkgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQiCiAgICA8PQogICAgYXNzZXJ0IC8vIERlbGF5IGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6OTgtOTkKICAgIC8vICMgZW5zdXJlIHRpbWVzdGFtcCBpcyBzdWZmaWNpZW50bHkgaW4gdGhlIGZ1dHVyZQogICAgLy8gc2VsZi5fY2hlY2tfc2NoZWR1bGVfdGltZXN0YW1wKHRpbWVzdGFtcCkKICAgIGNhbGxzdWIgX2NoZWNrX3NjaGVkdWxlX3RpbWVzdGFtcAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjEwMS0xMDIKICAgIC8vICMgaWYgaXQncyBhY3RpdmUsIGZyZWUgdXAgZGVsYXlfMSB0byB3cml0ZSB0byBpdAogICAgLy8gaWYgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgPj0gc2VsZi5taW5fdXBncmFkZV9kZWxheS52YWx1ZS50aW1lc3RhbXA6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNiAvLyAibWluX3VwZ3JhZGVfZGVsYXkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubWluX3VwZ3JhZGVfZGVsYXkgZXhpc3RzCiAgICBleHRyYWN0IDE2IDgKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIGI8PQogICAgYnogbWFpbl9hZnRlcl9pZl9lbHNlQDgzCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTAzCiAgICAvLyBzZWxmLm1pbl91cGdyYWRlX2RlbGF5LnZhbHVlLmRlbGF5XzAgPSBzZWxmLm1pbl91cGdyYWRlX2RlbGF5LnZhbHVlLmRlbGF5XzEKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJtaW5fdXBncmFkZV9kZWxheSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5taW5fdXBncmFkZV9kZWxheSBleGlzdHMKICAgIGR1cAogICAgZXh0cmFjdCA4IDgKICAgIHJlcGxhY2UyIDAKICAgIGJ5dGVjIDYgLy8gIm1pbl91cGdyYWRlX2RlbGF5IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKCm1haW5fYWZ0ZXJfaWZfZWxzZUA4MzoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMDUtMTA2CiAgICAvLyAjIHNjaGVkdWxlIGRlbGF5IGNoYW5nZSwgcG9zc2libHkgb3ZlcnJpZGluZyBleGlzdGluZyBzY2hlZHVsZWQgZGVsYXkgY2hhbmdlCiAgICAvLyBzZWxmLm1pbl91cGdyYWRlX2RlbGF5LnZhbHVlLmRlbGF5XzEgPSBBUkM0VUludDY0KG1pbl91cGdyYWRlX2RlbGF5KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gIm1pbl91cGdyYWRlX2RlbGF5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm1pbl91cGdyYWRlX2RlbGF5IGV4aXN0cwogICAgZGlnIDE0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHJlcGxhY2UyIDgKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMDcKICAgIC8vIHNlbGYubWluX3VwZ3JhZGVfZGVsYXkudmFsdWUudGltZXN0YW1wID0gQVJDNFVJbnQ2NCh0aW1lc3RhbXApCiAgICBkaWcgMTQKICAgIGR1cAogICAgY292ZXIgMgogICAgcmVwbGFjZTIgMTYKICAgIGJ5dGVjIDYgLy8gIm1pbl91cGdyYWRlX2RlbGF5IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxMDkKICAgIC8vIGVtaXQoTWluaW11bVVwZ3JhZGVEZWxheUNoYW5nZShBUkM0VUludDY0KG1pbl91cGdyYWRlX2RlbGF5KSwgQVJDNFVJbnQ2NCh0aW1lc3RhbXApKSkKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4NDU3ZGY5ZjcgLy8gbWV0aG9kICJNaW5pbXVtVXBncmFkZURlbGF5Q2hhbmdlKHVpbnQ2NCx1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weTo3OAogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRfcmF0ZV9kdXJhdGlvbl9yb3V0ZUAzOToKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToxMTIKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgY2FsbHN1YiBnZXRfcmF0ZV9kdXJhdGlvbgogICAgcG9wCiAgICBpdG9iCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF9yYXRlX2xpbWl0X3JvdXRlQDM4OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5Ojk5CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyOTcKICAgIC8vIGFzc2VydCBidWNrZXRfaWQgaW4gc2VsZi5yYXRlX2xpbWl0X2J1Y2tldHMsICJVbmtub3duIGJ1Y2tldCIKICAgIGJ5dGVjXzMgLy8gMHg3MjYxNzQ2NTVmNmM2OTZkNjk3NDVmNjI3NTYzNmI2NTc0NzM1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIFVua25vd24gYnVja2V0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MTEwCiAgICAvLyByZXR1cm4gc2VsZi5yYXRlX2xpbWl0X2J1Y2tldHNbYnVja2V0X2lkXS5saW1pdAogICAgYm94X2dldAogICAgcG9wCiAgICBleHRyYWN0IDAgMzIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weTo5OQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9oYXNfY2FwYWNpdHlfcm91dGVAMzc6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6NzUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MjU2CiAgICBjYWxsc3ViIGhhc19jYXBhY2l0eQogICAgcG9wCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF9jdXJyZW50X2NhcGFjaXR5X3JvdXRlQDM2OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjU0CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIGNhbGxzdWIgZ2V0X2N1cnJlbnRfY2FwYWNpdHkKICAgIHBvcAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9yYXRlX2xpbWl0ZXJfbWFuYWdlcl9yb2xlX3JvdXRlQDM1OgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxOTUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHB1c2hieXRlcyAweDE1MWY3Yzc1YmFmYzZjZTkyZDQ2NDMzZmM1YjgyYTk3MzcxOWU5ODYKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9vdXRib3VuZF9idWNrZXRfaWRfcm91dGVAMzQ6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE5MQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzVkNDZlYzNiOGJkNTQ0ZmJkZDJhMWFhYjBkZGU3ZjMwNzhhNjY2ODhmMzg1MmVkMDUwYmRkNzlhZDZiYWQ2MzliCiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faW5ib3VuZF9idWNrZXRfaWRfcm91dGVAMzM6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE4NwogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMiAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxODkKICAgIC8vIHJldHVybiBCeXRlczMyLmZyb21fYnl0ZXMob3Aua2VjY2FrMjU2KGIiSU5CT1VORF8iICsgY2hhaW5faWQuYnl0ZXMpKQogICAgYnl0ZWMgNSAvLyAweDQ5NGU0MjRmNTU0ZTQ0NWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAga2VjY2FrMjU2CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE4NwogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRfaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXJfcm91dGVAMzI6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE2NwogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICBjYWxsc3ViIGdldF9pbmJvdW5kX3F1ZXVlZF90cmFuc2ZlcgogICAgcG9wCiAgICBjb25jYXQKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0X2N1cnJlbnRfaW5ib3VuZF9jYXBhY2l0eV9yb3V0ZUAzMToKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTU4CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAyIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE4OQogICAgLy8gcmV0dXJuIEJ5dGVzMzIuZnJvbV9ieXRlcyhvcC5rZWNjYWsyNTYoYiJJTkJPVU5EXyIgKyBjaGFpbl9pZC5ieXRlcykpCiAgICBieXRlYyA1IC8vIDB4NDk0ZTQyNGY1NTRlNDQ1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBrZWNjYWsyNTYKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTY1CiAgICAvLyByZXR1cm4gc2VsZi5nZXRfY3VycmVudF9jYXBhY2l0eShzZWxmLmluYm91bmRfYnVja2V0X2lkKGNoYWluX2lkKSkKICAgIGNhbGxzdWIgZ2V0X2N1cnJlbnRfY2FwYWNpdHkKICAgIHBvcAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxNTgKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0X291dGJvdW5kX3F1ZXVlZF90cmFuc2Zlcl9yb3V0ZUAzMDoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTM4CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIGNhbGxzdWIgZ2V0X291dGJvdW5kX3F1ZXVlZF90cmFuc2ZlcgogICAgcG9wCiAgICBzd2FwCiAgICBwdXNoYnl0ZXMgMHgwMDAzCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRfY3VycmVudF9vdXRib3VuZF9jYXBhY2l0eV9yb3V0ZUAyOToKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTkzCiAgICAvLyByZXR1cm4gQnl0ZXMzMi5mcm9tX2J5dGVzKG9wLmtlY2NhazI1NihiIk9VVEJPVU5EIikpCiAgICBieXRlYyA0IC8vIDB4ZDQ2ZWMzYjhiZDU0NGZiZGQyYTFhYWIwZGRlN2YzMDc4YTY2Njg4ZjM4NTJlZDA1MGJkZDc5YWQ2YmFkNjM5YgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxMzYKICAgIC8vIHJldHVybiBzZWxmLmdldF9jdXJyZW50X2NhcGFjaXR5KHNlbGYub3V0Ym91bmRfYnVja2V0X2lkKCkpCiAgICBjYWxsc3ViIGdldF9jdXJyZW50X2NhcGFjaXR5CiAgICBwb3AKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTMzCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3NldF9pbmJvdW5kX3JhdGVfZHVyYXRpb25fcm91dGVAMjg6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjExOQogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMiAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0luaXRpYWxpc2FibGUucHk6NjMKICAgIC8vIGFzc2VydCBzZWxmLmlzX2luaXRpYWxpc2VkLCAiVW5pbml0aWFsaXNlZCBjb250cmFjdCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19pbml0aWFsaXNlZCBleGlzdHMKICAgIGFzc2VydCAvLyBVbmluaXRpYWxpc2VkIGNvbnRyYWN0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE5NwogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5leHRyYWN0KG9wLmtlY2NhazI1NihiIlJBVEVfTElNSVRFUl9NQU5BR0VSIiksIDAsIGNvbnN0LkJZVEVTMTZfTEVOR1RIKSkKICAgIGJ5dGVjIDExIC8vIDB4YmFmYzZjZTkyZDQ2NDMzZmM1YjgyYTk3MzcxOWU5ODYKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTI4CiAgICAvLyBzZWxmLl9jaGVja19zZW5kZXJfcm9sZShzZWxmLnJhdGVfbGltaXRlcl9tYW5hZ2VyX3JvbGUoKSkKICAgIGNhbGxzdWIgX2NoZWNrX3NlbmRlcl9yb2xlCiAgICBwb3AKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTg5CiAgICAvLyByZXR1cm4gQnl0ZXMzMi5mcm9tX2J5dGVzKG9wLmtlY2NhazI1NihiIklOQk9VTkRfIiArIGNoYWluX2lkLmJ5dGVzKSkKICAgIGJ5dGVjIDUgLy8gMHg0OTRlNDI0ZjU1NGU0NDVmCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAga2VjY2FrMjU2CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjEzMC0xMzEKICAgIC8vICMgZmFpbHMgaWYgYnVja2V0IGlzIHVua25vd24gaS5lLiBjaGFpbiBub3QgYWRkZWQKICAgIC8vIHNlbGYuX3VwZGF0ZV9yYXRlX2R1cmF0aW9uKHNlbGYuaW5ib3VuZF9idWNrZXRfaWQoY2hhaW5faWQpLCBuZXdfZHVyYXRpb24pCiAgICBzd2FwCiAgICBjYWxsc3ViIF91cGRhdGVfcmF0ZV9kdXJhdGlvbgogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjExOQogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9zZXRfaW5ib3VuZF9yYXRlX2xpbWl0X3JvdXRlQDI3OgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxMDUKICAgIC8vIEBhYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDIgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MTYKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDI1NgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0luaXRpYWxpc2FibGUucHk6NjMKICAgIC8vIGFzc2VydCBzZWxmLmlzX2luaXRpYWxpc2VkLCAiVW5pbml0aWFsaXNlZCBjb250cmFjdCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19pbml0aWFsaXNlZCBleGlzdHMKICAgIGFzc2VydCAvLyBVbmluaXRpYWxpc2VkIGNvbnRyYWN0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE5NwogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5leHRyYWN0KG9wLmtlY2NhazI1NihiIlJBVEVfTElNSVRFUl9NQU5BR0VSIiksIDAsIGNvbnN0LkJZVEVTMTZfTEVOR1RIKSkKICAgIGJ5dGVjIDExIC8vIDB4YmFmYzZjZTkyZDQ2NDMzZmM1YjgyYTk3MzcxOWU5ODYKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTE0CiAgICAvLyBzZWxmLl9jaGVja19zZW5kZXJfcm9sZShzZWxmLnJhdGVfbGltaXRlcl9tYW5hZ2VyX3JvbGUoKSkKICAgIGNhbGxzdWIgX2NoZWNrX3NlbmRlcl9yb2xlCiAgICBwb3AKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTg5CiAgICAvLyByZXR1cm4gQnl0ZXMzMi5mcm9tX2J5dGVzKG9wLmtlY2NhazI1NihiIklOQk9VTkRfIiArIGNoYWluX2lkLmJ5dGVzKSkKICAgIGJ5dGVjIDUgLy8gMHg0OTRlNDI0ZjU1NGU0NDVmCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAga2VjY2FrMjU2CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjExNi0xMTcKICAgIC8vICMgZmFpbHMgaWYgYnVja2V0IGlzIHVua25vd24gaS5lLiBjaGFpbiBub3QgYWRkZWQKICAgIC8vIHNlbGYuX3VwZGF0ZV9yYXRlX2xpbWl0KHNlbGYuaW5ib3VuZF9idWNrZXRfaWQoY2hhaW5faWQpLCBuZXdfbGltaXQpCiAgICBzd2FwCiAgICBjYWxsc3ViIF91cGRhdGVfcmF0ZV9saW1pdAogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjEwNQogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9zZXRfb3V0Ym91bmRfcmF0ZV9kdXJhdGlvbl9yb3V0ZUAyNjoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6OTMKICAgIC8vIEBhYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9Jbml0aWFsaXNhYmxlLnB5OjYzCiAgICAvLyBhc3NlcnQgc2VsZi5pc19pbml0aWFsaXNlZCwgIlVuaW5pdGlhbGlzZWQgY29udHJhY3QiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiaXNfaW5pdGlhbGlzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfaW5pdGlhbGlzZWQgZXhpc3RzCiAgICBhc3NlcnQgLy8gVW5pbml0aWFsaXNlZCBjb250cmFjdAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxOTcKICAgIC8vIHJldHVybiBCeXRlczE2LmZyb21fYnl0ZXMob3AuZXh0cmFjdChvcC5rZWNjYWsyNTYoYiJSQVRFX0xJTUlURVJfTUFOQUdFUiIpLCAwLCBjb25zdC5CWVRFUzE2X0xFTkdUSCkpCiAgICBieXRlYyAxMSAvLyAweGJhZmM2Y2U5MmQ0NjQzM2ZjNWI4MmE5NzM3MTllOTg2CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjEwMQogICAgLy8gc2VsZi5fY2hlY2tfc2VuZGVyX3JvbGUoc2VsZi5yYXRlX2xpbWl0ZXJfbWFuYWdlcl9yb2xlKCkpCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE5MwogICAgLy8gcmV0dXJuIEJ5dGVzMzIuZnJvbV9ieXRlcyhvcC5rZWNjYWsyNTYoYiJPVVRCT1VORCIpKQogICAgYnl0ZWMgNCAvLyAweGQ0NmVjM2I4YmQ1NDRmYmRkMmExYWFiMGRkZTdmMzA3OGE2NjY4OGYzODUyZWQwNTBiZGQ3OWFkNmJhZDYzOWIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTAzCiAgICAvLyBzZWxmLl91cGRhdGVfcmF0ZV9kdXJhdGlvbihzZWxmLm91dGJvdW5kX2J1Y2tldF9pZCgpLCBuZXdfZHVyYXRpb24pCiAgICBzd2FwCiAgICBjYWxsc3ViIF91cGRhdGVfcmF0ZV9kdXJhdGlvbgogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjkzCiAgICAvLyBAYWJpbWV0aG9kCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3NldF9vdXRib3VuZF9yYXRlX2xpbWl0X3JvdXRlQDI1OgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weTo4MQogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50MjU2CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTk3CiAgICAvLyByZXR1cm4gQnl0ZXMxNi5mcm9tX2J5dGVzKG9wLmV4dHJhY3Qob3Aua2VjY2FrMjU2KGIiUkFURV9MSU1JVEVSX01BTkFHRVIiKSwgMCwgY29uc3QuQllURVMxNl9MRU5HVEgpKQogICAgYnl0ZWMgMTEgLy8gMHhiYWZjNmNlOTJkNDY0MzNmYzViODJhOTczNzE5ZTk4NgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weTo4OQogICAgLy8gc2VsZi5fY2hlY2tfc2VuZGVyX3JvbGUoc2VsZi5yYXRlX2xpbWl0ZXJfbWFuYWdlcl9yb2xlKCkpCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE5MwogICAgLy8gcmV0dXJuIEJ5dGVzMzIuZnJvbV9ieXRlcyhvcC5rZWNjYWsyNTYoYiJPVVRCT1VORCIpKQogICAgYnl0ZWMgNCAvLyAweGQ0NmVjM2I4YmQ1NDRmYmRkMmExYWFiMGRkZTdmMzA3OGE2NjY4OGYzODUyZWQwNTBiZGQ3OWFkNmJhZDYzOWIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6OTEKICAgIC8vIHNlbGYuX3VwZGF0ZV9yYXRlX2xpbWl0KHNlbGYub3V0Ym91bmRfYnVja2V0X2lkKCksIG5ld19saW1pdCkKICAgIHN3YXAKICAgIGNhbGxzdWIgX3VwZGF0ZV9yYXRlX2xpbWl0CiAgICBwb3AKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6ODEKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faXNfbWVzc2FnZV9leGVjdXRlZF9yb3V0ZUAyNDoKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6ODQKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgY2FsbHN1YiBpc19tZXNzYWdlX2V4ZWN1dGVkCiAgICBwb3AKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faXNfbWVzc2FnZV9hcHByb3ZlZF9yb3V0ZUAyMzoKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6NjkKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgY2FsbHN1YiBpc19tZXNzYWdlX2FwcHJvdmVkCiAgICBwb3AKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZXhlY3V0ZV9tZXNzYWdlX3JvdXRlQDIyOgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weTozNgogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGRpZyAxCiAgICBwdXNoaW50IDEzMCAvLyAxMzAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIHR1cGxlIGVuY29kaW5nCiAgICBkdXAKICAgIHB1c2hpbnQgMTMyIC8vIDEzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIHRhaWwgcG9pbnRlciBhdCBpbmRleCA1IG9mICh1aW50OFszMl0sdWludDhbMzJdLHVpbnQxNix1aW50OFszMl0sdWludDhbMzJdLChsZW4rdWludDhbXSkpCiAgICBkaWcgMgogICAgc3dhcAogICAgZGlnIDIKICAgIHN1YnN0cmluZzMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIHB1c2hpbnQgMTM0IC8vIDEzNAogICAgKwogICAgdW5jb3ZlciAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBudHRfY29udHJhY3RzLnR5cGVzLk1lc3NhZ2VSZWNlaXZlZAogICAgZGlnIDEKICAgIGV4dHJhY3QgNjQgMgogICAgZGlnIDIKICAgIGV4dHJhY3QgNjYgMzIKICAgIGRpZyAzCiAgICBleHRyYWN0IDk4IDMyCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjQ3LTUzCiAgICAvLyAjIGNhbGN1bGF0ZSB1bmlxdWUgaWQgZm9yIG1lc3NhZ2UgdG8gY2hlY2sgZm9yIHJlcGxheSBhdHRhY2tzCiAgICAvLyBtZXNzYWdlX2RpZ2VzdCwgdHhuID0gYWJpX2NhbGwoCiAgICAvLyAgICAgSVRyYW5zY2VpdmVyTWFuYWdlci5jYWxjdWxhdGVfbWVzc2FnZV9kaWdlc3QsCiAgICAvLyAgICAgbWVzc2FnZSwKICAgIC8vICAgICBhcHBfaWQ9c2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyLnZhbHVlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weTo1MQogICAgLy8gYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNCAvLyAidHJhbnNjZWl2ZXJfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyIGV4aXN0cwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjQ3LTUzCiAgICAvLyAjIGNhbGN1bGF0ZSB1bmlxdWUgaWQgZm9yIG1lc3NhZ2UgdG8gY2hlY2sgZm9yIHJlcGxheSBhdHRhY2tzCiAgICAvLyBtZXNzYWdlX2RpZ2VzdCwgdHhuID0gYWJpX2NhbGwoCiAgICAvLyAgICAgSVRyYW5zY2VpdmVyTWFuYWdlci5jYWxjdWxhdGVfbWVzc2FnZV9kaWdlc3QsCiAgICAvLyAgICAgbWVzc2FnZSwKICAgIC8vICAgICBhcHBfaWQ9c2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyLnZhbHVlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4MzdiYzcxYTkgLy8gbWV0aG9kICJjYWxjdWxhdGVfbWVzc2FnZV9kaWdlc3QoKGJ5dGVbMzJdLGJ5dGVbMzJdLHVpbnQxNixieXRlWzMyXSxieXRlWzMyXSxieXRlW10pKWJ5dGVbMzJdIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjUyCiAgICAvLyBmZWU9MCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weTo0Ny01MwogICAgLy8gIyBjYWxjdWxhdGUgdW5pcXVlIGlkIGZvciBtZXNzYWdlIHRvIGNoZWNrIGZvciByZXBsYXkgYXR0YWNrcwogICAgLy8gbWVzc2FnZV9kaWdlc3QsIHR4biA9IGFiaV9jYWxsKAogICAgLy8gICAgIElUcmFuc2NlaXZlck1hbmFnZXIuY2FsY3VsYXRlX21lc3NhZ2VfZGlnZXN0LAogICAgLy8gICAgIG1lc3NhZ2UsCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBsb2cgdmFsdWUgaXMgbm90IHRoZSByZXN1bHQgb2YgYW4gQUJJIHJldHVybgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0J5dGVzVXRpbHMucHk6MTQKICAgIC8vIGFzc2VydCBvcC5zdWJzdHJpbmcoYS5ieXRlcywgMCwgY29uc3QuQllURVMyNF9MRU5HVEgpID09IG9wLmJ6ZXJvKGNvbnN0LkJZVEVTMjRfTEVOR1RIKSwgIlVuc2FmZSBjb252ZXJzaW9uIG9mIGJ5dGVzMzIgdG8gdWludDY0IgogICAgZGlnIDEKICAgIHN1YnN0cmluZyAwIDI0CiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICBiemVybwogICAgPT0KICAgIGFzc2VydCAvLyBVbnNhZmUgY29udmVyc2lvbiBvZiBieXRlczMyIHRvIHVpbnQ2NAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0J5dGVzVXRpbHMucHk6MTUKICAgIC8vIHJldHVybiBvcC5leHRyYWN0X3VpbnQ2NChhLmJ5dGVzLCBjb25zdC5CWVRFUzI0X0xFTkdUSCkKICAgIHN3YXAKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjU3CiAgICAvLyA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9pZC5pZCksIGVyci5NRVNTQUdFX0hBTkRMRVJfQUREUkVTU19NSVNNQVRDSAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjU1LTU3CiAgICAvLyAjIGNoZWNrIGlmIGhhbmRsZXIgaXMgY29ycmVjdAogICAgLy8gYXNzZXJ0IChCeXRlc1V0aWxzLnNhZmVfY29udmVydF9ieXRlczMyX3RvX3VpbnQ2NChtZXNzYWdlLmhhbmRsZXJfYWRkcmVzcy5jb3B5KCkpCiAgICAvLyAgICAgICAgID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkKSwgZXJyLk1FU1NBR0VfSEFORExFUl9BRERSRVNTX01JU01BVENICiAgICA9PQogICAgYXNzZXJ0IC8vIE1lc3NhZ2UgaGFuZGxlciBhZGRyZXNzIG1pc21hdGNoCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjU5LTYwCiAgICAvLyAjIGNoZWNrIGlmIHJlcXVpcmVkIGF0dGVzdGF0aW9ucyBoYXZlIGJlZW4gbWV0CiAgICAvLyBhc3NlcnQgc2VsZi5pc19tZXNzYWdlX2FwcHJvdmVkKG1lc3NhZ2VfZGlnZXN0KSwgZXJyLk1FU1NBR0VfTk9UX0FQUFJPVkVECiAgICBjYWxsc3ViIGlzX21lc3NhZ2VfYXBwcm92ZWQKICAgIHN3YXAKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgIT0KICAgIGFzc2VydCAvLyBNZXNzYWdlIG5vdCBhcHByb3ZlZAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weTo2Mi02MwogICAgLy8gIyBwcm90ZWN0IGFnYWluc3QgcmVwbGF5IGF0dGFja3MKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5pc19tZXNzYWdlX2V4ZWN1dGVkKG1lc3NhZ2VfZGlnZXN0KSwgZXJyLk1FU1NBR0VfQUxSRUFEWV9FWEVDVVRFRAogICAgY2FsbHN1YiBpc19tZXNzYWdlX2V4ZWN1dGVkCiAgICBzd2FwCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjU5LTYwCiAgICAvLyAjIGNoZWNrIGlmIHJlcXVpcmVkIGF0dGVzdGF0aW9ucyBoYXZlIGJlZW4gbWV0CiAgICAvLyBhc3NlcnQgc2VsZi5pc19tZXNzYWdlX2FwcHJvdmVkKG1lc3NhZ2VfZGlnZXN0KSwgZXJyLk1FU1NBR0VfTk9UX0FQUFJPVkVECiAgICBieXRlY18wIC8vIDB4MDAKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6NjItNjMKICAgIC8vICMgcHJvdGVjdCBhZ2FpbnN0IHJlcGxheSBhdHRhY2tzCiAgICAvLyBhc3NlcnQgbm90IHNlbGYuaXNfbWVzc2FnZV9leGVjdXRlZChtZXNzYWdlX2RpZ2VzdCksIGVyci5NRVNTQUdFX0FMUkVBRFlfRVhFQ1VURUQKICAgID09CiAgICBhc3NlcnQgLy8gTWVzc2FnZSBhbHJlYWR5IGV4ZWN1dGVkCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjY0CiAgICAvLyBzZWxmLm1lc3NhZ2VzX2V4ZWN1dGVkW21lc3NhZ2VfZGlnZXN0XSA9IEJvb2woVHJ1ZSkKICAgIGJ5dGVjIDIzIC8vIDB4NmQ2NTczNzM2MTY3NjU3MzVmNjU3ODY1NjM3NTc0NjU2NDVmCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBieXRlYyA3IC8vIDB4ODAKICAgIGJveF9wdXQKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9Jbml0aWFsaXNhYmxlLnB5OjYzCiAgICAvLyBhc3NlcnQgc2VsZi5pc19pbml0aWFsaXNlZCwgIlVuaW5pdGlhbGlzZWQgY29udHJhY3QiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiaXNfaW5pdGlhbGlzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfaW5pdGlhbGlzZWQgZXhpc3RzCiAgICBhc3NlcnQgLy8gVW5pbml0aWFsaXNlZCBjb250cmFjdAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjQxNwogICAgLy8gc2VsZi5fY2hlY2tfaXNfbm90X3BhdXNlZCgpCiAgICBjYWxsc3ViIF9jaGVja19pc19ub3RfcGF1c2VkCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDE5LTQyMAogICAgLy8gIyB2ZXJpZnkgcGVlcgogICAgLy8gbnR0X21hbmFnZXJfcGVlciA9IHNlbGYuZ2V0X250dF9tYW5hZ2VyX3BlZXIobWVzc2FnZS5zb3VyY2VfY2hhaW5faWQpCiAgICBkaWcgMgogICAgY2FsbHN1YiBnZXRfbnR0X21hbmFnZXJfcGVlcgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjQyMQogICAgLy8gYXNzZXJ0IG1lc3NhZ2Uuc291cmNlX2FkZHJlc3MgPT0gbnR0X21hbmFnZXJfcGVlci5wZWVyX2NvbnRyYWN0LCBlcnIuUEVFUl9BRERSRVNTX1VOS05PV04KICAgIGV4dHJhY3QgMCAzMgogICAgdW5jb3ZlciAyCiAgICA9PQogICAgYXNzZXJ0IC8vIFVua25vd24gcGVlciBhZGRyZXNzCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDI2CiAgICAvLyBhc3NlcnQgQnl0ZXMuZnJvbV9oZXgoTlRUX1BBWUxPQURfUFJFRklYKSA9PSBvcC5leHRyYWN0KHBheWxvYWQsIGluZGV4LCBjb25zdC5CWVRFUzRfTEVOR1RIKSwgZXJyLlBSRUZJWF9JTkNPUlJFQ1QKICAgIGRpZyAyCiAgICBleHRyYWN0IDIgNAogICAgYnl0ZWMgMjQgLy8gMHg5OTRlNTQ1NAogICAgPT0KICAgIGFzc2VydCAvLyBJbmNvcnJlY3QgcHJlZml4CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDI4CiAgICAvLyBmcm9tX2RlY2ltYWxzID0gQVJDNFVJbnQ4KG9wLmJ0b2kob3AuZXh0cmFjdChwYXlsb2FkLCBpbmRleCwgY29uc3QuVUlOVDhfTEVOR1RIKSkpCiAgICBkaWcgMgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjQyNwogICAgLy8gaW5kZXggKz0gY29uc3QuQllURVM0X0xFTkdUSAogICAgcHVzaGludCA2IC8vIDYKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo0MjgKICAgIC8vIGZyb21fZGVjaW1hbHMgPSBBUkM0VUludDgob3AuYnRvaShvcC5leHRyYWN0KHBheWxvYWQsIGluZGV4LCBjb25zdC5VSU5UOF9MRU5HVEgpKSkKICAgIGdldGJ5dGUKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzMgLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA3IDEKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo0MzAKICAgIC8vIGZyb21fYW1vdW50ID0gQVJDNFVJbnQ2NChvcC5leHRyYWN0X3VpbnQ2NChwYXlsb2FkLCBpbmRleCkpCiAgICBkaWcgMwogICAgZXh0cmFjdCA3IDgKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo0MzIKICAgIC8vIHJlY2lwaWVudCA9IEFkZHJlc3Mob3AuZXh0cmFjdChwYXlsb2FkLCBpbmRleCwgY29uc3QuQllURVMzMl9MRU5HVEgpKQogICAgZGlnIDQKICAgIGV4dHJhY3QgNDcgMzIKICAgIGR1cAogICAgYnVyeSAyNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjQzNAogICAgLy8gcmVjaXBpZW50X2NoYWluID0gb3AuZXh0cmFjdF91aW50MTYocGF5bG9hZCwgaW5kZXgpCiAgICB1bmNvdmVyIDUKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo0MzMKICAgIC8vIGluZGV4ICs9IGNvbnN0LkJZVEVTMzJfTEVOR1RICiAgICBwdXNoaW50IDc5IC8vIDc5CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDM0CiAgICAvLyByZWNpcGllbnRfY2hhaW4gPSBvcC5leHRyYWN0X3VpbnQxNihwYXlsb2FkLCBpbmRleCkKICAgIGV4dHJhY3RfdWludDE2CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDM3LTQzOAogICAgLy8gIyB2ZXJpZnkgdGhhdCB0aGUgZGVzdGluYXRpb24gY2hhaW4gaXMgdmFsaWQKICAgIC8vIGFzc2VydCByZWNpcGllbnRfY2hhaW4gPT0gc2VsZi5jaGFpbl9pZC52YWx1ZSwgZXJyLlRBUkdFVF9DSEFJTl9JTlZBTElECiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTggLy8gImNoYWluX2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNoYWluX2lkIGV4aXN0cwogICAgc3dhcAogICAgaXRvYgogICAgYj09CiAgICBhc3NlcnQgLy8gSW52YWxpZCB0YXJnZXQgY2hhaW4KICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo0NDAtNDQxCiAgICAvLyAjIGNhbGN1bGF0ZSBwcm9wZXIgYW1vdW50IG9mIHRva2VucyB0byB1bmxvY2svbWludCB0byByZWNpcGllbnQKICAgIC8vIHRyaW1tZWRfYW1vdW50ID0gVHJpbW1lZEFtb3VudChmcm9tX2Ftb3VudCwgZnJvbV9kZWNpbWFscykKICAgIHN3YXAKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDczCiAgICAvLyB0b19kZWNpbWFscyA9IHNlbGYuX2dldF9hc3NldF9kZWNpbWFscygpCiAgICBjYWxsc3ViIF9nZXRfYXNzZXRfZGVjaW1hbHMKICAgIC8vIG50dF9jb250cmFjdHMvbGlicmFyeS9UcmltbWVkQW1vdW50TGliLnB5OjUzCiAgICAvLyByZXR1cm4gc2NhbGUoYW10LmFtb3VudC5hc191aW50NjQoKSwgYW10LmRlY2ltYWxzLCB0b19kZWNpbWFscykKICAgIGRpZyAxCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAyCiAgICBleHRyYWN0IDggMQogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIHNjYWxlCiAgICBkdXAKICAgIGJ1cnkgNgogICAgY292ZXIgNAogICAgc3dhcAogICAgdW5jb3ZlciAyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDQ0LTQ1MQogICAgLy8gIyBjaGVjayBpZiByYXRlIGxpbWl0ZWQgYW5kIGVpdGhlciBlbnF1ZXVlIG9yIGNhcnJ5IG91dCB0cmFuc2ZlcgogICAgLy8gaXNfZW5xdWV1ZWQgPSBzZWxmLl9lbnF1ZXVlX29yX2NvbnN1bWVfaW5ib3VuZF90cmFuc2ZlcigKICAgIC8vICAgICB1bnRyaW1tZWRfYW1vdW50LAogICAgLy8gICAgIG1lc3NhZ2Uuc291cmNlX2NoYWluX2lkLAogICAgLy8gICAgIHRyaW1tZWRfYW1vdW50LAogICAgLy8gICAgIHJlY2lwaWVudCwKICAgIC8vICAgICBtZXNzYWdlX2RpZ2VzdAogICAgLy8gKQogICAgY2FsbHN1YiBfZW5xdWV1ZV9vcl9jb25zdW1lX2luYm91bmRfdHJhbnNmZXIKICAgIHBvcAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weTo1OS02MAogICAgLy8gIyBjaGVjayBpZiByZXF1aXJlZCBhdHRlc3RhdGlvbnMgaGF2ZSBiZWVuIG1ldAogICAgLy8gYXNzZXJ0IHNlbGYuaXNfbWVzc2FnZV9hcHByb3ZlZChtZXNzYWdlX2RpZ2VzdCksIGVyci5NRVNTQUdFX05PVF9BUFBST1ZFRAogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDUyCiAgICAvLyBpZiBub3QgaXNfZW5xdWV1ZWQ6CiAgICA9PQogICAgYnogbWFpbl9hZnRlcl9pZl9lbHNlQDE4OQogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjQ1MwogICAgLy8gYWJpX2NhbGwoSU50dFRva2VuLm1pbnQsIHJlY2lwaWVudCwgdW50cmltbWVkX2Ftb3VudCwgYXBwX2lkPXNlbGYubnR0X3Rva2VuLnZhbHVlLCBmZWU9MCkKICAgIGl0eG5fYmVnaW4KICAgIGR1cAogICAgaXRvYgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEyIC8vICJudHRfdG9rZW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubnR0X3Rva2VuIGV4aXN0cwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBieXRlYyAxOSAvLyBtZXRob2QgIm1pbnQoYWRkcmVzcyx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCm1haW5fYWZ0ZXJfaWZfZWxzZUAxODk6CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjM2CiAgICAvLyBAYWJpbWV0aG9kCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF9udHRfbWFuYWdlcl9wZWVyX3JvdXRlQDIxOgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI4MwogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMiAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgY2FsbHN1YiBnZXRfbnR0X21hbmFnZXJfcGVlcgogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl91bnBhdXNlcl9yb2xlX3JvdXRlQDIwOgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI3OQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzU4MmIzMmQ5YWI1MTAwZGIwOGFlYjlhMGUwOGI0MjJkMQogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3BhdXNlcl9yb2xlX3JvdXRlQDE5OgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI3NQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzU1Mzk0NDA4MjAwMzBjNDk5NGRiNGUzMWI2YjgwMGRlYQogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX250dF9tYW5hZ2VyX2FkbWluX3JvbGVfcm91dGVAMTg6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MjcxCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NTZhNjczODA1YmFhNWRkOTU5MmVhYzM4ZWMzOTliODI4CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY29tcGxldGVfaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXJfcm91dGVAMTc6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MjUyCiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9Jbml0aWFsaXNhYmxlLnB5OjYzCiAgICAvLyBhc3NlcnQgc2VsZi5pc19pbml0aWFsaXNlZCwgIlVuaW5pdGlhbGlzZWQgY29udHJhY3QiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiaXNfaW5pdGlhbGlzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfaW5pdGlhbGlzZWQgZXhpc3RzCiAgICBhc3NlcnQgLy8gVW5pbml0aWFsaXNlZCBjb250cmFjdAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI1NQogICAgLy8gc2VsZi5fY2hlY2tfaXNfbm90X3BhdXNlZCgpCiAgICBjYWxsc3ViIF9jaGVja19pc19ub3RfcGF1c2VkCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MjU3LTI1OAogICAgLy8gIyBmaW5kIHRoZSBtZXNzYWdlIGluIHRoZSBxdWV1ZSBhbmQgZW5zdXJlIHRoYXQgc3VmZmljaWVudCB0aW1lIGhhcyBlbGFwc2VkCiAgICAvLyBjYW5fY29tcGxldGUsIGluYm91bmRfcXVldWVkX3RyYW5zZmVyID0gc2VsZi5nZXRfaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXIobWVzc2FnZV9kaWdlc3QpCiAgICBjYWxsc3ViIGdldF9pbmJvdW5kX3F1ZXVlZF90cmFuc2ZlcgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI1OQogICAgLy8gYXNzZXJ0IGNhbl9jb21wbGV0ZSwgZXJyLklOQk9VTkRfUVVFVUVEX1RSQU5TRkVSX1NUSUxMX1FVRVVFRAogICAgdW5jb3ZlciAyCiAgICBieXRlY18wIC8vIDB4MDAKICAgICE9CiAgICBhc3NlcnQgLy8gSW5ib3VuZCBxdWV1ZWQgdHJhbnNmZXIgaXMgc3RpbGwgcXVldWVkCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjMzNAogICAgLy8gYXNzZXJ0IG1lc3NhZ2VfZGlnZXN0IGluIHNlbGYuaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXJzLCBlcnIuSU5CT1VORF9RVUVVRURfVFJBTlNGRVJfVU5LTk9XTgogICAgYnl0ZWMgMjAgLy8gMHg2OTZlNjI2Zjc1NmU2NDVmNzE3NTY1NzU2NTY0NWY3NDcyNjE2ZTczNjY2NTcyNzM1ZgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBVbmtub3duIGluYm91bmQgcXVldWVkIHRyYW5zZmVyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjMyNQogICAgLy8gZGVsIHNlbGYuaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXJzW21lc3NhZ2VfZGlnZXN0XQogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjMyNgogICAgLy8gZW1pdChJbmJvdW5kVHJhbnNmZXJEZWxldGVkKG1lc3NhZ2VfZGlnZXN0KSkKICAgIHB1c2hieXRlcyAweGM2ZWY3MzNhIC8vIG1ldGhvZCAiSW5ib3VuZFRyYW5zZmVyRGVsZXRlZChieXRlWzMyXSkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI2NC0yNjUKICAgIC8vICMgY2Fycnkgb3V0IHRyYW5zZmVyCiAgICAvLyB1bnRyaW1tZWRfYW1vdW50ID0gc2VsZi5fdW50cmltX3RyYW5zZmVyX2Ftb3VudChpbmJvdW5kX3F1ZXVlZF90cmFuc2Zlci5hbW91bnQpCiAgICBkdXAKICAgIGV4dHJhY3QgOCA5CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDczCiAgICAvLyB0b19kZWNpbWFscyA9IHNlbGYuX2dldF9hc3NldF9kZWNpbWFscygpCiAgICBjYWxsc3ViIF9nZXRfYXNzZXRfZGVjaW1hbHMKICAgIC8vIG50dF9jb250cmFjdHMvbGlicmFyeS9UcmltbWVkQW1vdW50TGliLnB5OjUzCiAgICAvLyByZXR1cm4gc2NhbGUoYW10LmFtb3VudC5hc191aW50NjQoKSwgYW10LmRlY2ltYWxzLCB0b19kZWNpbWFscykKICAgIGRpZyAxCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIHVuY292ZXIgMgogICAgZXh0cmFjdCA4IDEKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBzY2FsZQogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI2NgogICAgLy8gYWJpX2NhbGwoSU50dFRva2VuLm1pbnQsaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXIucmVjaXBpZW50LCB1bnRyaW1tZWRfYW1vdW50LCBhcHBfaWQ9c2VsZi5udHRfdG9rZW4udmFsdWUsIGZlZT0wKQogICAgaXR4bl9iZWdpbgogICAgc3dhcAogICAgZXh0cmFjdCAxOSAzMgogICAgc3dhcAogICAgaXRvYgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEyIC8vICJudHRfdG9rZW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubnR0X3Rva2VuIGV4aXN0cwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBieXRlYyAxOSAvLyBtZXRob2QgIm1pbnQoYWRkcmVzcyx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MjY4LTI2OQogICAgLy8gIyByZWZ1bmQgYm94IHN0b3JhZ2UKICAgIC8vIHNlbGYuX3JlZnVuZF9taW5fYmFsYW5jZV90b19jYWxsZXIoKQogICAgY2FsbHN1YiBfcmVmdW5kX21pbl9iYWxhbmNlX3RvX2NhbGxlcgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI1MgogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jYW5jZWxfb3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyX3JvdXRlQDE2OgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjIzMQogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyMzQKICAgIC8vIHNlbGYuX2NoZWNrX2lzX25vdF9wYXVzZWQoKQogICAgY2FsbHN1YiBfY2hlY2tfaXNfbm90X3BhdXNlZAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjIzNi0yMzcKICAgIC8vICMgZmluZCB0aGUgbWVzc2FnZSBpbiB0aGUgcXVldWUKICAgIC8vIG91dGJvdW5kX3F1ZXVlZF90cmFuc2ZlciA9IHNlbGYuZ2V0X291dGJvdW5kX3F1ZXVlZF90cmFuc2ZlcihtZXNzYWdlX2lkKVsxXQogICAgY2FsbHN1YiBnZXRfb3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyCiAgICBjb3ZlciAyCiAgICBidXJ5IDEKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyMzktMjQwCiAgICAvLyAjIGNoZWNrIHNlbmRlciBpbml0aWF0ZWQgdGhlIHRyYW5zZmVyCiAgICAvLyBhc3NlcnQgQWRkcmVzcyhUeG4uc2VuZGVyKSA9PSBvdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXIuc2VuZGVyLCBlcnIuT05MWV9PUklHSU5BTF9TRU5ERVJfQ0FOX0NBTkNFTAogICAgdHhuIFNlbmRlcgogICAgZGlnIDEKICAgIGV4dHJhY3QgNTEgMzIKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuY2VsbGVyIGlzIG5vdCBvcmlnaW5hbCBzZW5kZXIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyNDItMjQzCiAgICAvLyAjIHJlbW92ZSB0cmFuc2ZlciBmcm9tIHRoZSBxdWV1ZQogICAgLy8gc2VsZi5fZGVsZXRlX291dGJvdW5kX3RyYW5zZmVyKG1lc3NhZ2VfaWQpCiAgICBzd2FwCiAgICBjYWxsc3ViIF9kZWxldGVfb3V0Ym91bmRfdHJhbnNmZXIKICAgIHBvcAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI0NS0yNDYKICAgIC8vICMgcmV0dXJuIHRoZSBxdWV1ZWQgZnVuZHMgdG8gdGhlIHVzZXIKICAgIC8vIHVudHJpbW1lZF9hbW91bnQgPSBzZWxmLl91bnRyaW1fdHJhbnNmZXJfYW1vdW50KG91dGJvdW5kX3F1ZXVlZF90cmFuc2Zlci5hbW91bnQpCiAgICBleHRyYWN0IDggOQogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjQ3MwogICAgLy8gdG9fZGVjaW1hbHMgPSBzZWxmLl9nZXRfYXNzZXRfZGVjaW1hbHMoKQogICAgY2FsbHN1YiBfZ2V0X2Fzc2V0X2RlY2ltYWxzCiAgICAvLyBudHRfY29udHJhY3RzL2xpYnJhcnkvVHJpbW1lZEFtb3VudExpYi5weTo1MwogICAgLy8gcmV0dXJuIHNjYWxlKGFtdC5hbW91bnQuYXNfdWludDY0KCksIGFtdC5kZWNpbWFscywgdG9fZGVjaW1hbHMpCiAgICBkaWcgMQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIGV4dHJhY3QgOCAxCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgc2NhbGUKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyNDcKICAgIC8vIGFiaV9jYWxsKElOdHRUb2tlbi5taW50LEFkZHJlc3MoVHhuLnNlbmRlciksIHVudHJpbW1lZF9hbW91bnQsIGFwcF9pZD1zZWxmLm50dF90b2tlbi52YWx1ZSwgZmVlPTApCiAgICBpdHhuX2JlZ2luCiAgICB0eG4gU2VuZGVyCiAgICBzd2FwCiAgICBpdG9iCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTIgLy8gIm50dF90b2tlbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5udHRfdG9rZW4gZXhpc3RzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGJ5dGVjIDE5IC8vIG1ldGhvZCAibWludChhZGRyZXNzLHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyNDktMjUwCiAgICAvLyAjIHJlZnVuZCBib3ggc3RvcmFnZQogICAgLy8gc2VsZi5fcmVmdW5kX21pbl9iYWxhbmNlX3RvX2NhbGxlcigpCiAgICBjYWxsc3ViIF9yZWZ1bmRfbWluX2JhbGFuY2VfdG9fY2FsbGVyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MjMxCiAgICAvLyBAYWJpbWV0aG9kCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NvbXBsZXRlX291dGJvdW5kX3F1ZXVlZF90cmFuc2Zlcl9yb3V0ZUAxNToKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxOTkKICAgIC8vIEBhYmltZXRob2QKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyMDYKICAgIC8vIHNlbGYuX2NoZWNrX2lzX25vdF9wYXVzZWQoKQogICAgY2FsbHN1YiBfY2hlY2tfaXNfbm90X3BhdXNlZAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjIwOC0yMDkKICAgIC8vICMgZmluZCB0aGUgbWVzc2FnZSBpbiB0aGUgcXVldWUgYW5kIGVuc3VyZSB0aGF0IHN1ZmZpY2llbnQgdGltZSBoYXMgZWxhcHNlZAogICAgLy8gY2FuX2NvbXBsZXRlLCBvdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXIgPSBzZWxmLmdldF9vdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXIobWVzc2FnZV9pZCkKICAgIGNhbGxzdWIgZ2V0X291dGJvdW5kX3F1ZXVlZF90cmFuc2ZlcgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjIxMAogICAgLy8gYXNzZXJ0IGNhbl9jb21wbGV0ZSwgZXJyLk9VVEJPVU5EX1FVRVVFRF9UUkFOU0ZFUl9TVElMTF9RVUVVRUQKICAgIHVuY292ZXIgMgogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAhPQogICAgYXNzZXJ0IC8vIE91dGJvdW5kIHF1ZXVlZCB0cmFuc2ZlciBpcyBzdGlsbCBxdWV1ZWQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyMTItMjEzCiAgICAvLyAjIHJlbW92ZSB0cmFuc2ZlciBmcm9tIHRoZSBxdWV1ZQogICAgLy8gc2VsZi5fZGVsZXRlX291dGJvdW5kX3RyYW5zZmVyKG1lc3NhZ2VfaWQpCiAgICBjYWxsc3ViIF9kZWxldGVfb3V0Ym91bmRfdHJhbnNmZXIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyMTkKICAgIC8vIG91dGJvdW5kX3F1ZXVlZF90cmFuc2Zlci5hbW91bnQsCiAgICBkaWcgMQogICAgZXh0cmFjdCA4IDkKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyMjAKICAgIC8vIG91dGJvdW5kX3F1ZXVlZF90cmFuc2Zlci5yZWNpcGllbnRfY2hhaW4sCiAgICBkaWcgMgogICAgZXh0cmFjdCAxNyAyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MjIxCiAgICAvLyBvdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXIucmVjaXBpZW50LmNvcHkoKSwKICAgIGRpZyAzCiAgICBleHRyYWN0IDE5IDMyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MjIyCiAgICAvLyBvdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXIuc2VuZGVyLAogICAgZGlnIDQKICAgIGV4dHJhY3QgNTEgMzIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyMjMKICAgIC8vIG91dGJvdW5kX3F1ZXVlZF90cmFuc2Zlci50cmFuc2NlaXZlcl9pbnN0cnVjdGlvbnMuY29weSgpLAogICAgZGlnIDUKICAgIHB1c2hpbnQgODMgLy8gODMKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgNgogICAgbGVuCiAgICB1bmNvdmVyIDcKICAgIGNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyMTUtMjI0CiAgICAvLyAjIHNraXAgcmF0ZSBsaW1pdCBsb2dpYyBhbmQgY2Fycnkgb3V0IHRyYW5zZmVyLCBhbHNvIGNoZWNrcyBmZWUgcGF5bWVudAogICAgLy8gc2VsZi5fdHJhbnNmZXIoCiAgICAvLyAgICAgZmVlX3BheW1lbnQsCiAgICAvLyAgICAgbWVzc2FnZV9pZCwKICAgIC8vICAgICBvdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXIuYW1vdW50LAogICAgLy8gICAgIG91dGJvdW5kX3F1ZXVlZF90cmFuc2Zlci5yZWNpcGllbnRfY2hhaW4sCiAgICAvLyAgICAgb3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyLnJlY2lwaWVudC5jb3B5KCksCiAgICAvLyAgICAgb3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyLnNlbmRlciwKICAgIC8vICAgICBvdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXIudHJhbnNjZWl2ZXJfaW5zdHJ1Y3Rpb25zLmNvcHkoKSwKICAgIC8vICkKICAgIGNhbGxzdWIgX3RyYW5zZmVyCiAgICBwb3BuIDIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyMjYtMjI3CiAgICAvLyAjIHJlZnVuZCBib3ggc3RvcmFnZQogICAgLy8gc2VsZi5fcmVmdW5kX21pbl9iYWxhbmNlX3RvX2NhbGxlcigpCiAgICBjYWxsc3ViIF9yZWZ1bmRfbWluX2JhbGFuY2VfdG9fY2FsbGVyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MTk5CiAgICAvLyBAYWJpbWV0aG9kCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3RyYW5zZmVyX2Z1bGxfcm91dGVAMTQ6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MTc4CiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG4gR3JvdXBJbmRleAogICAgcHVzaGludCAyIC8vIDIKICAgIC0KICAgIGR1cAogICAgYnVyeSAxMAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBidXJ5IDYKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBwdXNoaW50IDQgLy8gYXhmZXIKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBheGZlcgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgYnVyeSAxMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBidXJ5IDE4CiAgICBsZW4KICAgIHB1c2hpbnQgMiAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBidXJ5IDE5CiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGJ1cnkgMTYKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuYm9vbAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBidXJ5IDEzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBkdXAKICAgIGJ1cnkgMTMKICAgIHB1c2hpbnQgMiAvLyAyCiAgICAqCiAgICBidXJ5IDgKICAgIGR1cAogICAgbGVuCiAgICBidXJ5IDMKICAgIGV4dHJhY3QgMiAwCiAgICBidXJ5IDI1CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSA4CgptYWluX2Zvcl9oZWFkZXJAMTM2OgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjE3OAogICAgLy8gQGFiaW1ldGhvZAogICAgZGlnIDcKICAgIGRpZyAxMQogICAgPAogICAgYnogbWFpbl9hZnRlcl9mb3JAMTM4CiAgICBkaWcgNwogICAgZHVwCiAgICBwdXNoaW50IDIgLy8gMgogICAgKgogICAgZGlnIDI2CiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgZW5jb2RpbmcKICAgIGR1cAogICAgZGlnIDEwCiAgICBkdXAKICAgIGNvdmVyIDQKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCB0YWlsIHBvaW50ZXIgZm9yIChsZW4rKHVpbnQ2NCwobGVuK3VpbnQ4W10pKVtdKQogICAgZGlnIDEKICAgIGxlbgogICAgc3Vic3RyaW5nMwogICAgZHVwCiAgICBsZW4KICAgIGRpZyAxCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgdHVwbGUgZW5jb2RpbmcKICAgIGR1cAogICAgcHVzaGludCAxMCAvLyAxMAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIHRhaWwgcG9pbnRlciBhdCBpbmRleCAxIG9mICh1aW50NjQsKGxlbit1aW50OFtdKSkKICAgIHN3YXAKICAgIHN1YnN0cmluZzMKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBwdXNoaW50IDEyIC8vIDEyCiAgICArCiAgICArCiAgICBidXJ5IDgKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDgKICAgIGIgbWFpbl9mb3JfaGVhZGVyQDEzNgoKbWFpbl9hZnRlcl9mb3JAMTM4OgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjE3OAogICAgLy8gQGFiaW1ldGhvZAogICAgZGlnIDYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PG50dF9jb250cmFjdHMudHlwZXMuVHJhbnNjZWl2ZXJJbnN0cnVjdGlvbj4KICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxODktMTk3CiAgICAvLyByZXR1cm4gc2VsZi5fdHJhbnNmZXJfZW50cnlfcG9pbnQoCiAgICAvLyAgICAgZmVlX3BheW1lbnQsCiAgICAvLyAgICAgc2VuZF90b2tlbiwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgcmVjaXBpZW50X2NoYWluLAogICAgLy8gICAgIHJlY2lwaWVudCwKICAgIC8vICAgICBzaG91bGRfcXVldWUsCiAgICAvLyAgICAgdHJhbnNjZWl2ZXJfaW5zdHJ1Y3Rpb25zCiAgICAvLyApCiAgICBkaWcgOAogICAgZGlnIDUKICAgIGRpZyAxMQogICAgZGlnIDE5CiAgICBkaWcgMjEKICAgIGRpZyAxOQogICAgZGlnIDE3CiAgICBjYWxsc3ViIF90cmFuc2Zlcl9lbnRyeV9wb2ludAogICAgcG9wbiAyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MTc4CiAgICAvLyBAYWJpbWV0aG9kCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3RyYW5zZmVyX3JvdXRlQDEzOgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjE1OQogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuIEdyb3VwSW5kZXgKICAgIHB1c2hpbnQgMiAvLyAyCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIHB1c2hpbnQgNCAvLyBheGZlcgogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIGF4ZmVyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAyIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxNzQKICAgIC8vIEJvb2woRmFsc2UpLAogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MTc1CiAgICAvLyBUcmFuc2NlaXZlckluc3RydWN0aW9ucygpCiAgICBwdXNoYnl0ZXMgMHgwMDAwCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MTY4LTE3NgogICAgLy8gcmV0dXJuIHNlbGYuX3RyYW5zZmVyX2VudHJ5X3BvaW50KAogICAgLy8gICAgIGZlZV9wYXltZW50LAogICAgLy8gICAgIHNlbmRfdG9rZW4sCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICAgIHJlY2lwaWVudF9jaGFpbiwKICAgIC8vICAgICByZWNpcGllbnQsCiAgICAvLyAgICAgQm9vbChGYWxzZSksCiAgICAvLyAgICAgVHJhbnNjZWl2ZXJJbnN0cnVjdGlvbnMoKQogICAgLy8gKQogICAgY2FsbHN1YiBfdHJhbnNmZXJfZW50cnlfcG9pbnQKICAgIHBvcG4gMgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjE1OQogICAgLy8gQGFiaW1ldGhvZAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9zZXRfbnR0X21hbmFnZXJfcGVlcl9yb3V0ZUAxMjoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxMzYKICAgIC8vIEBhYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgYnVyeSAyMwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMiAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQxNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBidXJ5IDIzCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGJ1cnkgMjIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50OAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0luaXRpYWxpc2FibGUucHk6NjMKICAgIC8vIGFzc2VydCBzZWxmLmlzX2luaXRpYWxpc2VkLCAiVW5pbml0aWFsaXNlZCBjb250cmFjdCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19pbml0aWFsaXNlZCBleGlzdHMKICAgIGFzc2VydCAvLyBVbmluaXRpYWxpc2VkIGNvbnRyYWN0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MjczCiAgICAvLyByZXR1cm4gQnl0ZXMxNi5mcm9tX2J5dGVzKG9wLmV4dHJhY3Qob3Aua2VjY2FrMjU2KGIiTlRUX01BTkFHRVJfQURNSU4iKSwgMCwgY29uc3QuQllURVMxNl9MRU5HVEgpKQogICAgYnl0ZWMgMTUgLy8gMHg2YTY3MzgwNWJhYTVkZDk1OTJlYWMzOGVjMzk5YjgyOAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjE0NAogICAgLy8gc2VsZi5fY2hlY2tfc2VuZGVyX3JvbGUoc2VsZi5udHRfbWFuYWdlcl9hZG1pbl9yb2xlKCkpCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MTQ2LTE0NwogICAgLy8gIyBjaGVjayBwZWVyIGNoYWluIGlzIHZhbGlkCiAgICAvLyBhc3NlcnQgcGVlcl9jaGFpbl9pZCAhPSBzZWxmLmNoYWluX2lkLnZhbHVlLCBlcnIuUEVFUl9DQU5OT1RfQkVfSVRTRUxGCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTggLy8gImNoYWluX2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNoYWluX2lkIGV4aXN0cwogICAgZGlnIDIKICAgIGIhPQogICAgYXNzZXJ0IC8vIENhbm5vdCBzZXQgaXRzZWxmIGFzIHBlZXIgY2hhaW4KICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxNDgKICAgIC8vIGFzc2VydCBwZWVyX2RlY2ltYWxzLmFzX3VpbnQ2NCgpLCBlcnIuUEVFUl9ERUNJTUFMU19JTlZBTElECiAgICBidG9pCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwZWVyIGRlY2ltYWxzCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MTUwLTE1MQogICAgLy8gIyBpZiBuZXcgY2hhaW4sIGNyZWF0ZSB1bmxpbWl0ZWQgaW5ib3VuZCBidWNrZXQKICAgIC8vIGlzX25ldyA9IEJvb2wocGVlcl9jaGFpbl9pZCBub3QgaW4gc2VsZi5udHRfbWFuYWdlcl9wZWVycykKICAgIGJ5dGVjIDI1IC8vIDB4NmU3NDc0NWY2ZDYxNmU2MTY3NjU3MjVmNzA2NTY1NzI1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJ1cnkgMjUKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgIQogICAgYnl0ZWNfMCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGR1cAogICAgYnVyeSAyNAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjE1MgogICAgLy8gaWYgaXNfbmV3OgogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAhPQogICAgYnogbWFpbl9hZnRlcl9pZl9lbHNlQDE0NAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxODkKICAgIC8vIHJldHVybiBCeXRlczMyLmZyb21fYnl0ZXMob3Aua2VjY2FrMjU2KGIiSU5CT1VORF8iICsgY2hhaW5faWQuYnl0ZXMpKQogICAgYnl0ZWMgNSAvLyAweDQ5NGU0MjRmNTU0ZTQ0NWYKICAgIGRpZyAyMgogICAgY29uY2F0CiAgICBrZWNjYWsyNTYKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxNTMKICAgIC8vIHNlbGYuX2FkZF9idWNrZXQoc2VsZi5pbmJvdW5kX2J1Y2tldF9pZChwZWVyX2NoYWluX2lkKSwgVUludDI1NigwKSwgVUludDY0KDApKQogICAgYnl0ZWMgMjYgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICBpbnRjXzAgLy8gMAogICAgY2FsbHN1YiBfYWRkX2J1Y2tldAogICAgcG9wCgptYWluX2FmdGVyX2lmX2Vsc2VAMTQ0OgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjE1NS0xNTYKICAgIC8vICMgc2V0IHBlZXIgKG92ZXJyaWRpbmcgaWYgbmVlZGVkKQogICAgLy8gc2VsZi5udHRfbWFuYWdlcl9wZWVyc1twZWVyX2NoYWluX2lkXSA9IE50dE1hbmFnZXJQZWVyKHBlZXJfY29udHJhY3QuY29weSgpLCBwZWVyX2RlY2ltYWxzKQogICAgZGlnIDIwCiAgICBkdXAKICAgIGRpZyAyMQogICAgZHVwCiAgICBjb3ZlciAzCiAgICBjb25jYXQKICAgIGRpZyAyNgogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjE1NwogICAgLy8gZW1pdChOdHRNYW5hZ2VyUGVlclNldChwZWVyX2NoYWluX2lkLCBwZWVyX2NvbnRyYWN0LCBwZWVyX2RlY2ltYWxzLCBpc19uZXcpKQogICAgZGlnIDIzCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZGlnIDIzCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDRjYmViNGY4IC8vIG1ldGhvZCAiTnR0TWFuYWdlclBlZXJTZXQodWludDE2LGJ5dGVbMzJdLHVpbnQ4LGJvb2wpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxMzYKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc2V0X3RocmVzaG9sZF9yb3V0ZUAxMToKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxMjgKICAgIC8vIEBhYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9Jbml0aWFsaXNhYmxlLnB5OjYzCiAgICAvLyBhc3NlcnQgc2VsZi5pc19pbml0aWFsaXNlZCwgIlVuaW5pdGlhbGlzZWQgY29udHJhY3QiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiaXNfaW5pdGlhbGlzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfaW5pdGlhbGlzZWQgZXhpc3RzCiAgICBhc3NlcnQgLy8gVW5pbml0aWFsaXNlZCBjb250cmFjdAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI3MwogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5leHRyYWN0KG9wLmtlY2NhazI1NihiIk5UVF9NQU5BR0VSX0FETUlOIiksIDAsIGNvbnN0LkJZVEVTMTZfTEVOR1RIKSkKICAgIGJ5dGVjIDE1IC8vIDB4NmE2NzM4MDViYWE1ZGQ5NTkyZWFjMzhlYzM5OWI4MjgKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxMzEKICAgIC8vIHNlbGYuX2NoZWNrX3NlbmRlcl9yb2xlKHNlbGYubnR0X21hbmFnZXJfYWRtaW5fcm9sZSgpKQogICAgY2FsbHN1YiBfY2hlY2tfc2VuZGVyX3JvbGUKICAgIHBvcAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjEzMy0xMzQKICAgIC8vICMgc2V0IHRocmVzaG9sZAogICAgLy8gc2VsZi5fc2V0X3RocmVzaG9sZChuZXdfdGhyZXNob2xkKQogICAgY2FsbHN1YiBfc2V0X3RocmVzaG9sZAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjEyOAogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9zZXRfdHJhbnNjZWl2ZXJfbWFuYWdlcl9yb3V0ZUAxMDoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxMTkKICAgIC8vIEBhYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgZHVwCiAgICBidG9pCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyNzMKICAgIC8vIHJldHVybiBCeXRlczE2LmZyb21fYnl0ZXMob3AuZXh0cmFjdChvcC5rZWNjYWsyNTYoYiJOVFRfTUFOQUdFUl9BRE1JTiIpLCAwLCBjb25zdC5CWVRFUzE2X0xFTkdUSCkpCiAgICBieXRlYyAxNSAvLyAweDZhNjczODA1YmFhNWRkOTU5MmVhYzM4ZWMzOTliODI4CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MTIyCiAgICAvLyBzZWxmLl9jaGVja19zZW5kZXJfcm9sZShzZWxmLm50dF9tYW5hZ2VyX2FkbWluX3JvbGUoKSkKICAgIGNhbGxzdWIgX2NoZWNrX3NlbmRlcl9yb2xlCiAgICBwb3AKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxMjQtMTI1CiAgICAvLyAjIHNldCB0cmFuc2NlaXZlciBtYW5hZ2VyCiAgICAvLyBzZWxmLl9zZXRfdHJhbnNjZWl2ZXJfbWFuYWdlcihhZG1pbl9pbl90cmFuc2NlaXZlcl9tYW5hZ2VyLCB0cmFuc2NlaXZlcl9tYW5hZ2VyKQogICAgdW5jb3ZlciAyCiAgICBzd2FwCiAgICBjYWxsc3ViIF9zZXRfdHJhbnNjZWl2ZXJfbWFuYWdlcgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjEyNgogICAgLy8gZW1pdChUcmFuc2NlaXZlck1hbmFnZXJVcGRhdGVkKEFSQzRVSW50NjQodHJhbnNjZWl2ZXJfbWFuYWdlcikpKQogICAgcHVzaGJ5dGVzIDB4MGEzYjZmOWUgLy8gbWV0aG9kICJUcmFuc2NlaXZlck1hbmFnZXJVcGRhdGVkKHVpbnQ2NCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjExOQogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl91bnBhdXNlX3JvdXRlQDk6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyODEKICAgIC8vIHJldHVybiBCeXRlczE2LmZyb21fYnl0ZXMob3AuZXh0cmFjdChvcC5rZWNjYWsyNTYoYiJVTlBBVVNFUiIpLCAwLCBjb25zdC5CWVRFUzE2X0xFTkdUSCkpCiAgICBwdXNoYnl0ZXMgMHg4MmIzMmQ5YWI1MTAwZGIwOGFlYjlhMGUwOGI0MjJkMQogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjExMQogICAgLy8gc2VsZi5fY2hlY2tfc2VuZGVyX3JvbGUoc2VsZi51bnBhdXNlcl9yb2xlKCkpCiAgICBjYWxsc3ViIF9jaGVja19zZW5kZXJfcm9sZQogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6Mjk0CiAgICAvLyBhc3NlcnQgc2VsZi5pc19wYXVzZWQsIGVyci5DT05UUkFDVF9OT1RfUEFVU0VECiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOCAvLyAiaXNfcGF1c2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX3BhdXNlZCBleGlzdHMKICAgIGFzc2VydCAvLyBDb250cmFjdCBpcyBub3QgcGF1c2VkCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MTE1LTExNgogICAgLy8gIyBzZXQgd2hldGhlciBwYXVzZWQgb3Igbm90CiAgICAvLyBzZWxmLmlzX3BhdXNlZCA9IEZhbHNlCiAgICBieXRlYyA4IC8vICJpc19wYXVzZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxMTcKICAgIC8vIGVtaXQoUGF1c2VkKEJvb2woRmFsc2UpKSkKICAgIHB1c2hieXRlcyAweDdkYWJmNzdlMDAKICAgIGxvZwogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjEwNwogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9wYXVzZV9yb3V0ZUA4OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0luaXRpYWxpc2FibGUucHk6NjMKICAgIC8vIGFzc2VydCBzZWxmLmlzX2luaXRpYWxpc2VkLCAiVW5pbml0aWFsaXNlZCBjb250cmFjdCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19pbml0aWFsaXNlZCBleGlzdHMKICAgIGFzc2VydCAvLyBVbmluaXRpYWxpc2VkIGNvbnRyYWN0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6Mjc3CiAgICAvLyByZXR1cm4gQnl0ZXMxNi5mcm9tX2J5dGVzKG9wLmV4dHJhY3Qob3Aua2VjY2FrMjU2KGIiUEFVU0VSIiksIDAsIGNvbnN0LkJZVEVTMTZfTEVOR1RIKSkKICAgIHB1c2hieXRlcyAweDUzOTQ0MDgyMDAzMGM0OTk0ZGI0ZTMxYjZiODAwZGVhCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6OTkKICAgIC8vIHNlbGYuX2NoZWNrX3NlbmRlcl9yb2xlKHNlbGYucGF1c2VyX3JvbGUoKSkKICAgIGNhbGxzdWIgX2NoZWNrX3NlbmRlcl9yb2xlCiAgICBwb3AKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxMDEKICAgIC8vIHNlbGYuX2NoZWNrX2lzX25vdF9wYXVzZWQoKQogICAgY2FsbHN1YiBfY2hlY2tfaXNfbm90X3BhdXNlZAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjEwMy0xMDQKICAgIC8vICMgc2V0IHdoZXRoZXIgcGF1c2VkIG9yIG5vdAogICAgLy8gc2VsZi5pc19wYXVzZWQgPSBUcnVlCiAgICBieXRlYyA4IC8vICJpc19wYXVzZWQiCiAgICBpbnRjXzEgLy8gMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToxMDUKICAgIC8vIGVtaXQoUGF1c2VkKEJvb2woVHJ1ZSkpKQogICAgcHVzaGJ5dGVzIDB4N2RhYmY3N2U4MAogICAgbG9nCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6OTUKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faW5pdGlhbGlzZV9yb3V0ZUA3OgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5Ojg0CiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9leHRlbnNpb25zL0luaXRpYWxpc2FibGVXaXRoQ3JlYXRvci5weToyNQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgIkNhbGxlciBtdXN0IGJlIHRoZSBjb250cmFjdCBjcmVhdG9yIgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbGxlciBtdXN0IGJlIHRoZSBjb250cmFjdCBjcmVhdG9yCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo1NwogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX2luaXRpYWxpc2VkLCAiQ29udHJhY3QgYWxyZWFkeSBpbml0aWFsaXNlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19pbml0aWFsaXNlZCBleGlzdHMKICAgICEKICAgIGFzc2VydCAvLyBDb250cmFjdCBhbHJlYWR5IGluaXRpYWxpc2VkCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo1OQogICAgLy8gc2VsZi5pc19pbml0aWFsaXNlZCA9IFRydWUKICAgIGJ5dGVjXzIgLy8gImlzX2luaXRpYWxpc2VkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE5MwogICAgLy8gcmV0dXJuIEJ5dGVzMzIuZnJvbV9ieXRlcyhvcC5rZWNjYWsyNTYoYiJPVVRCT1VORCIpKQogICAgYnl0ZWMgNCAvLyAweGQ0NmVjM2I4YmQ1NDRmYmRkMmExYWFiMGRkZTdmMzA3OGE2NjY4OGYzODUyZWQwNTBiZGQ3OWFkNmJhZDYzOWIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6NzUtNzYKICAgIC8vICMgY3JlYXRlIHVubGltaXRlZCBvdXRib3VuZCBidWNrZXQKICAgIC8vIHNlbGYuX2FkZF9idWNrZXQoc2VsZi5vdXRib3VuZF9idWNrZXRfaWQoKSwgVUludDI1NigwKSwgVUludDY0KDApKQogICAgYnl0ZWMgMjYgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICBpbnRjXzAgLy8gMAogICAgY2FsbHN1YiBfYWRkX2J1Y2tldAogICAgcG9wCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxMDkKICAgIC8vIHJldHVybiBCeXRlczE2LmZyb21fYnl0ZXMob3AuYnplcm8oY29uc3QuQllURVMxNl9MRU5HVEgpKQogICAgcHVzaGludCAxNiAvLyAxNgogICAgYnplcm8KICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6NzgKICAgIC8vIHNlbGYuX2dyYW50X3JvbGUoc2VsZi5kZWZhdWx0X2FkbWluX3JvbGUoKSwgYWRtaW4pCiAgICBkaWcgMgogICAgY2FsbHN1YiBfZ3JhbnRfcm9sZQogICAgcG9wbiAyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE5NwogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5leHRyYWN0KG9wLmtlY2NhazI1NihiIlJBVEVfTElNSVRFUl9NQU5BR0VSIiksIDAsIGNvbnN0LkJZVEVTMTZfTEVOR1RIKSkKICAgIGJ5dGVjIDExIC8vIDB4YmFmYzZjZTkyZDQ2NDMzZmM1YjgyYTk3MzcxOWU5ODYKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6NzkKICAgIC8vIHNlbGYuX2dyYW50X3JvbGUoc2VsZi5yYXRlX2xpbWl0ZXJfbWFuYWdlcl9yb2xlKCksIGFkbWluKQogICAgZGlnIDIKICAgIGNhbGxzdWIgX2dyYW50X3JvbGUKICAgIHBvcG4gMgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjkwCiAgICAvLyBzZWxmLl9zZXRfdHJhbnNjZWl2ZXJfbWFuYWdlcihhZG1pbiwgdHJhbnNjZWl2ZXJfbWFuYWdlcikKICAgIGRpZyAxCiAgICBzd2FwCiAgICBjYWxsc3ViIF9zZXRfdHJhbnNjZWl2ZXJfbWFuYWdlcgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE5OQogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5leHRyYWN0KG9wLmtlY2NhazI1NihiIlVQR1JBREVBQkxFX0FETUlOIiksIDAsIGNvbnN0LkJZVEVTMTZfTEVOR1RIKSkKICAgIGJ5dGVjIDkgLy8gMHhjZjhjZDMyN2I4YTJlOGUwNTEyYTM5NmRiYTlmMDA3YgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjkyCiAgICAvLyBzZWxmLl9ncmFudF9yb2xlKHNlbGYudXBncmFkYWJsZV9hZG1pbl9yb2xlKCksIGFkbWluKQogICAgZGlnIDEKICAgIGNhbGxzdWIgX2dyYW50X3JvbGUKICAgIHBvcG4gMgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI3MwogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5leHRyYWN0KG9wLmtlY2NhazI1NihiIk5UVF9NQU5BR0VSX0FETUlOIiksIDAsIGNvbnN0LkJZVEVTMTZfTEVOR1RIKSkKICAgIGJ5dGVjIDE1IC8vIDB4NmE2NzM4MDViYWE1ZGQ5NTkyZWFjMzhlYzM5OWI4MjgKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo5MwogICAgLy8gc2VsZi5fZ3JhbnRfcm9sZShzZWxmLm50dF9tYW5hZ2VyX2FkbWluX3JvbGUoKSwgYWRtaW4pCiAgICBzd2FwCiAgICBjYWxsc3ViIF9ncmFudF9yb2xlCiAgICBwb3BuIDIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo4NAogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfTm9PcEA1MzoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo1MgogICAgLy8gY2xhc3MgTnR0TWFuYWdlcihJTnR0TWFuYWdlciwgTWVzc2FnZUhhbmRsZXIsIE50dFJhdGVMaW1pdGVyLCBVcGdyYWRlYWJsZSk6CiAgICBwdXNoYnl0ZXMgMHhiN2E2OWE2MSAvLyBtZXRob2QgImNyZWF0ZSh1aW50NjQsdWludDE2LHVpbnQ2NCx1aW50NjQpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fY3JlYXRlX3JvdXRlQDU0CiAgICBlcnIKCm1haW5fY3JlYXRlX3JvdXRlQDU0OgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjcxCiAgICAvLyBAYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAyIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDE2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBkdXAKICAgIGJ0b2kKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MzQKICAgIC8vIHNlbGYuX3NldF90aHJlc2hvbGQodGhyZXNob2xkKQogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIF9zZXRfdGhyZXNob2xkCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjExCiAgICAvLyByZXR1cm4gVUludDY0KFRXT19XRUVLU19JTl9TRUNPTkRTKQogICAgaW50YyA0IC8vIDEyMDk2MDAKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMjgKICAgIC8vIGFzc2VydCBtaW5fdXBncmFkZV9kZWxheSA8PSBzZWxmLm1heF9mb3JfbWluX3VwZ3JhZGVfZGVsYXkoKSwgIkRlbGF5IGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIgogICAgPD0KICAgIGFzc2VydCAvLyBEZWxheSBleGNlZWRzIG1heGltdW0gYWxsb3dlZAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5Ojc2CiAgICAvLyBzZWxmLm1pbl91cGdyYWRlX2RlbGF5LnZhbHVlID0gTWluaW11bVVwZ3JhZGVEZWxheShBUkM0VUludDY0KDApLCBBUkM0VUludDY0KG1pbl91cGdyYWRlX2RlbGF5KSwgQVJDNFVJbnQ2NCgwKSkKICAgIGJ5dGVjIDI3IC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlYyAyNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAKICAgIGNvbmNhdAogICAgYnl0ZWMgNiAvLyAibWluX3VwZ3JhZGVfZGVsYXkiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5Ojc2LTc3CiAgICAvLyAjIHRva2VuCiAgICAvLyBhc3NldF9pZCwgdHhuID0gYWJpX2NhbGwoSU50dFRva2VuLmdldF9hc3NldF9pZCwgYXBwX2lkPW50dF90b2tlbiwgZmVlPTApCiAgICBpdHhuX2JlZ2luCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHg1YmEyMmE4NCAvLyBtZXRob2QgImdldF9hc3NldF9pZCgpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gbG9nIHZhbHVlIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGFuIEFCSSByZXR1cm4KICAgIGJ0b2kKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo3OAogICAgLy8gc2VsZi5hc3NldF9pZC52YWx1ZSA9IGFzc2V0X2lkCiAgICBieXRlYyAxNiAvLyAiYXNzZXRfaWQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5Ojc5CiAgICAvLyBzZWxmLm50dF90b2tlbi52YWx1ZSA9IG50dF90b2tlbgogICAgYnl0ZWMgMTIgLy8gIm50dF90b2tlbiIKICAgIHVuY292ZXIgMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo4MS04MgogICAgLy8gIyB0aGlzIGNoYWluCiAgICAvLyBzZWxmLmNoYWluX2lkLnZhbHVlID0gY2hhaW5faWQKICAgIGJ5dGVjIDE4IC8vICJjaGFpbl9pZCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NzEKICAgIC8vIEBhYmltZXRob2QoY3JlYXRlPSJyZXF1aXJlIikKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY29tcGxldGVfY29udHJhY3RfdXBncmFkZV9yb3V0ZUA0OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE1NwogICAgLy8gQGFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiVXBkYXRlQXBwbGljYXRpb24iXSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIHB1c2hpbnQgNCAvLyBVcGRhdGVBcHBsaWNhdGlvbgogICAgPT0KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAmJgogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIFVwZGF0ZUFwcGxpY2F0aW9uICYmIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9Jbml0aWFsaXNhYmxlLnB5OjYzCiAgICAvLyBhc3NlcnQgc2VsZi5pc19pbml0aWFsaXNlZCwgIlVuaW5pdGlhbGlzZWQgY29udHJhY3QiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiaXNfaW5pdGlhbGlzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfaW5pdGlhbGlzZWQgZXhpc3RzCiAgICBhc3NlcnQgLy8gVW5pbml0aWFsaXNlZCBjb250cmFjdAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE5OQogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5leHRyYWN0KG9wLmtlY2NhazI1NihiIlVQR1JBREVBQkxFX0FETUlOIiksIDAsIGNvbnN0LkJZVEVTMTZfTEVOR1RIKSkKICAgIGJ5dGVjIDkgLy8gMHhjZjhjZDMyN2I4YTJlOGUwNTEyYTM5NmRiYTlmMDA3YgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE2OAogICAgLy8gc2VsZi5fY2hlY2tfc2VuZGVyX3JvbGUoc2VsZi51cGdyYWRhYmxlX2FkbWluX3JvbGUoKSkKICAgIGNhbGxzdWIgX2NoZWNrX3NlbmRlcl9yb2xlCiAgICBwb3AKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMzgKICAgIC8vIGV4aXN0cyA9IHNlbGYuc2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUubWF5YmUoKVsxXQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEwIC8vICJzY2hlZHVsZWRfY29udHJhY3RfdXBncmFkZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgMTgKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMzkKICAgIC8vIGFzc2VydCBleGlzdHMsICJVcGdyYWRlIG5vdCBzY2hlZHVsZWQiCiAgICBhc3NlcnQgLy8gVXBncmFkZSBub3Qgc2NoZWR1bGVkCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTczCiAgICAvLyBhc3NlcnQgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgPj0gc2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUudGltZXN0YW1wLCAiU2NoZWR1bGUgY29tcGxldGUgdHMgbm90IG1ldCIKICAgIGV4dHJhY3QgMzIgOAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgYjw9CiAgICBhc3NlcnQgLy8gU2NoZWR1bGUgY29tcGxldGUgdHMgbm90IG1ldAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE3NS0xNzYKICAgIC8vICMgY2hlY2sgd2UgYXJlIHVwZ3JhZGluZyB0byBzYW1lIGNvbnRyYWN0CiAgICAvLyBwcm9ncmFtID0gQnl0ZXMoYiJhcHByb3ZhbCIpCiAgICBwdXNoYnl0ZXMgMHg2MTcwNzA3MjZmNzY2MTZjCiAgICBidXJ5IDE5CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTc3CiAgICAvLyBmb3IgcGFnZV9pbmRleCBpbiB1cmFuZ2UoVHhuLm51bV9hcHByb3ZhbF9wcm9ncmFtX3BhZ2VzKToKICAgIHR4biBOdW1BcHByb3ZhbFByb2dyYW1QYWdlcwogICAgYnVyeSA0CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSA2CgptYWluX2Zvcl9oZWFkZXJAMTU3OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE3NwogICAgLy8gZm9yIHBhZ2VfaW5kZXggaW4gdXJhbmdlKFR4bi5udW1fYXBwcm92YWxfcHJvZ3JhbV9wYWdlcyk6CiAgICBkaWcgNQogICAgZGlnIDQKICAgIDwKICAgIGJ6IG1haW5fYWZ0ZXJfZm9yQDE1OQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE3OAogICAgLy8gcHJvZ3JhbSArPSBvcC5zaGEyNTYoVHhuLmFwcHJvdmFsX3Byb2dyYW1fcGFnZXMocGFnZV9pbmRleCkpCiAgICBkaWcgNQogICAgZHVwCiAgICB0eG5hcyBBcHByb3ZhbFByb2dyYW1QYWdlcwogICAgc2hhMjU2CiAgICBkaWcgMjAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnVyeSAyMAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE3NwogICAgLy8gZm9yIHBhZ2VfaW5kZXggaW4gdXJhbmdlKFR4bi5udW1fYXBwcm92YWxfcHJvZ3JhbV9wYWdlcyk6CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSA2CiAgICBiIG1haW5fZm9yX2hlYWRlckAxNTcKCm1haW5fYWZ0ZXJfZm9yQDE1OToKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxNzkKICAgIC8vIHByb2dyYW0gKz0gQnl0ZXMoYiJjbGVhciIpCiAgICBkaWcgMTgKICAgIHB1c2hieXRlcyAweDYzNmM2NTYxNzIKICAgIGNvbmNhdAogICAgYnVyeSAxOQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE4MAogICAgLy8gZm9yIHBhZ2VfaW5kZXggaW4gdXJhbmdlKFR4bi5udW1fY2xlYXJfc3RhdGVfcHJvZ3JhbV9wYWdlcyk6CiAgICB0eG4gTnVtQ2xlYXJTdGF0ZVByb2dyYW1QYWdlcwogICAgYnVyeSAzCiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSA2CgptYWluX2Zvcl9oZWFkZXJAMTYwOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE4MAogICAgLy8gZm9yIHBhZ2VfaW5kZXggaW4gdXJhbmdlKFR4bi5udW1fY2xlYXJfc3RhdGVfcHJvZ3JhbV9wYWdlcyk6CiAgICBkaWcgNQogICAgZGlnIDMKICAgIDwKICAgIGJ6IG1haW5fYWZ0ZXJfZm9yQDE2MgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE4MQogICAgLy8gcHJvZ3JhbSArPSBvcC5zaGEyNTYoVHhuLmNsZWFyX3N0YXRlX3Byb2dyYW1fcGFnZXMocGFnZV9pbmRleCkpCiAgICBkaWcgNQogICAgZHVwCiAgICB0eG5hcyBDbGVhclN0YXRlUHJvZ3JhbVBhZ2VzCiAgICBzaGEyNTYKICAgIGRpZyAyMAogICAgc3dhcAogICAgY29uY2F0CiAgICBidXJ5IDIwCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MTgwCiAgICAvLyBmb3IgcGFnZV9pbmRleCBpbiB1cmFuZ2UoVHhuLm51bV9jbGVhcl9zdGF0ZV9wcm9ncmFtX3BhZ2VzKToKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDYKICAgIGIgbWFpbl9mb3JfaGVhZGVyQDE2MAoKbWFpbl9hZnRlcl9mb3JAMTYyOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE4MgogICAgLy8gcHJvZ3JhbV9zaGEyNTYgPSBCeXRlczMyLmZyb21fYnl0ZXMob3Auc2hhMjU2KHByb2dyYW0pKQogICAgZGlnIDE4CiAgICBzaGEyNTYKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxODMKICAgIC8vIGFzc2VydCBzY2hlZHVsZWRfY29udHJhY3RfdXBncmFkZS5wcm9ncmFtX3NoYTI1NiA9PSBwcm9ncmFtX3NoYTI1NiwgIkludmFsaWQgcHJvZ3JhbSBTSEEyNTYiCiAgICBkaWcgMTYKICAgIGV4dHJhY3QgMCAzMgogICAgZGlnIDEKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwcm9ncmFtIFNIQTI1NgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE4NS0xODYKICAgIC8vICMgcmVzZXQgdG8gbmV3IGNvbnRyYWN0IHZlcnNpb24KICAgIC8vIGRlbCBzZWxmLnNjaGVkdWxlZF9jb250cmFjdF91cGdyYWRlLnZhbHVlCiAgICBieXRlYyAxMCAvLyAic2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUiCiAgICBhcHBfZ2xvYmFsX2RlbAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE4NwogICAgLy8gc2VsZi52ZXJzaW9uICs9IFVJbnQ2NCgxKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEzIC8vICJ2ZXJzaW9uIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZlcnNpb24gZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWMgMTMgLy8gInZlcnNpb24iCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE4OAogICAgLy8gc2VsZi5pc19pbml0aWFsaXNlZCA9IEZhbHNlCiAgICBieXRlY18yIC8vICJpc19pbml0aWFsaXNlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjE5MAogICAgLy8gZW1pdChVcGdyYWRlQ29tcGxldGVkKHByb2dyYW1fc2hhMjU2LCBBUkM0VUludDY0KHNlbGYudmVyc2lvbikpKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEzIC8vICJ2ZXJzaW9uIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZlcnNpb24gZXhpc3RzCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDkyNDJkYWYxIC8vIG1ldGhvZCAiVXBncmFkZUNvbXBsZXRlZChieXRlWzMyXSx1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToxNTcKICAgIC8vIEBhYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIlVwZGF0ZUFwcGxpY2F0aW9uIl0pCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gbnR0X2NvbnRyYWN0cy5saWJyYXJ5LlRyaW1tZWRBbW91bnRMaWIuc2NhbGUoYW10OiB1aW50NjQsIGZyb21fZGVjaW1hbHM6IGJ5dGVzLCB0b19kZWNpbWFsczogYnl0ZXMpIC0+IHVpbnQ2NDoKc2NhbGU6CiAgICAvLyBudHRfY29udHJhY3RzL2xpYnJhcnkvVHJpbW1lZEFtb3VudExpYi5weToxOS0yMAogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBzY2FsZShhbXQ6IFVJbnQ2NCwgZnJvbV9kZWNpbWFsczogVUludDgsIHRvX2RlY2ltYWxzOiBVSW50OCkgLT4gVUludDY0OgogICAgcHJvdG8gMyAxCiAgICAvLyBudHRfY29udHJhY3RzL2xpYnJhcnkvVHJpbW1lZEFtb3VudExpYi5weToyMQogICAgLy8gaWYgZnJvbV9kZWNpbWFscyA9PSB0b19kZWNpbWFsczoKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBiPT0KICAgIGJ6IHNjYWxlX2Vsc2VfYm9keUAyCiAgICAvLyBudHRfY29udHJhY3RzL2xpYnJhcnkvVHJpbW1lZEFtb3VudExpYi5weToyMgogICAgLy8gcmV0dXJuIGFtdAogICAgZnJhbWVfZGlnIC0zCiAgICByZXRzdWIKCnNjYWxlX2Vsc2VfYm9keUAyOgogICAgLy8gbnR0X2NvbnRyYWN0cy9saWJyYXJ5L1RyaW1tZWRBbW91bnRMaWIucHk6MjMKICAgIC8vIGVsaWYgZnJvbV9kZWNpbWFscyA+IHRvX2RlY2ltYWxzOgogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGI+CiAgICBieiBzY2FsZV9lbHNlX2JvZHlANAogICAgLy8gbnR0X2NvbnRyYWN0cy9saWJyYXJ5L1RyaW1tZWRBbW91bnRMaWIucHk6MjQKICAgIC8vIHJldHVybiBhbXQgLy8gKDEwICoqIChmcm9tX2RlY2ltYWxzLmFzX3VpbnQ2NCgpIC0gdG9fZGVjaW1hbHMuYXNfdWludDY0KCkpKQogICAgZnJhbWVfZGlnIC0yCiAgICBidG9pCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ0b2kKICAgIC0KICAgIHB1c2hpbnQgMTAgLy8gMTAKICAgIHN3YXAKICAgIGV4cAogICAgZnJhbWVfZGlnIC0zCiAgICBzd2FwCiAgICAvCiAgICByZXRzdWIKCnNjYWxlX2Vsc2VfYm9keUA0OgogICAgLy8gbnR0X2NvbnRyYWN0cy9saWJyYXJ5L1RyaW1tZWRBbW91bnRMaWIucHk6MjYKICAgIC8vIHJldHVybiBhbXQgKiAoMTAgKiogKHRvX2RlY2ltYWxzLmFzX3VpbnQ2NCgpIC0gZnJvbV9kZWNpbWFscy5hc191aW50NjQoKSkpCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtMgogICAgYnRvaQogICAgLQogICAgcHVzaGludCAxMCAvLyAxMAogICAgc3dhcAogICAgZXhwCiAgICBmcmFtZV9kaWcgLTMKICAgICoKICAgIHJldHN1YgoKCi8vIG50dF9jb250cmFjdHMubnR0X21hbmFnZXIuTnR0TWFuYWdlci5OdHRNYW5hZ2VyLmdldF9udHRfbWFuYWdlcl9wZWVyKGNoYWluX2lkOiBieXRlcykgLT4gYnl0ZXM6CmdldF9udHRfbWFuYWdlcl9wZWVyOgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI4My0yODQKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfbnR0X21hbmFnZXJfcGVlcihzZWxmLCBjaGFpbl9pZDogVUludDE2KSAtPiBOdHRNYW5hZ2VyUGVlcjoKICAgIHByb3RvIDEgMQogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjI4NQogICAgLy8gYXNzZXJ0IGNoYWluX2lkIGluIHNlbGYubnR0X21hbmFnZXJfcGVlcnMsIGVyci5QRUVSX0NIQUlOX1VOS05PV04KICAgIGJ5dGVjIDI1IC8vIDB4NmU3NDc0NWY2ZDYxNmU2MTY3NjU3MjVmNzA2NTY1NzI1ZgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gVW5rbm93biBwZWVyIGNoYWluCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6Mjg2CiAgICAvLyByZXR1cm4gc2VsZi5udHRfbWFuYWdlcl9wZWVyc1tjaGFpbl9pZF0KICAgIGJveF9nZXQKICAgIHBvcAogICAgcmV0c3ViCgoKLy8gbnR0X2NvbnRyYWN0cy5udHRfbWFuYWdlci5OdHRNYW5hZ2VyLk50dE1hbmFnZXIuX2NoZWNrX2lzX25vdF9wYXVzZWQoKSAtPiB2b2lkOgpfY2hlY2tfaXNfbm90X3BhdXNlZDoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyOTAKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5pc19wYXVzZWQsIGVyci5DT05UUkFDVF9QQVVTRUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA4IC8vICJpc19wYXVzZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfcGF1c2VkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIENvbnRyYWN0IGlzIHBhdXNlZAogICAgcmV0c3ViCgoKLy8gbnR0X2NvbnRyYWN0cy5udHRfbWFuYWdlci5OdHRNYW5hZ2VyLk50dE1hbmFnZXIuX3RyYW5zZmVyX2VudHJ5X3BvaW50KGZlZV9wYXltZW50OiB1aW50NjQsIHNlbmRfdG9rZW46IHVpbnQ2NCwgYW1vdW50OiB1aW50NjQsIHJlY2lwaWVudF9jaGFpbjogYnl0ZXMsIHJlY2lwaWVudDogYnl0ZXMsIHNob3VsZF9xdWV1ZTogYnl0ZXMsIHRyYW5zY2VpdmVyX2luc3RydWN0aW9uczogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlcywgYnl0ZXM6Cl90cmFuc2Zlcl9lbnRyeV9wb2ludDoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozMDEtMzExCiAgICAvLyBAc3Vicm91dGluZShpbmxpbmU9RmFsc2UpCiAgICAvLyBkZWYgX3RyYW5zZmVyX2VudHJ5X3BvaW50KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZmVlX3BheW1lbnQ6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIHNlbmRfdG9rZW46IGd0eG4uQXNzZXRUcmFuc2ZlclRyYW5zYWN0aW9uLAogICAgLy8gICAgIGFtb3VudDogVUludDY0LAogICAgLy8gICAgIHJlY2lwaWVudF9jaGFpbjogVUludDE2LAogICAgLy8gICAgIHJlY2lwaWVudDogVW5pdmVyc2FsQWRkcmVzcywKICAgIC8vICAgICBzaG91bGRfcXVldWU6IEJvb2wsCiAgICAvLyAgICAgdHJhbnNjZWl2ZXJfaW5zdHJ1Y3Rpb25zOiBUcmFuc2NlaXZlckluc3RydWN0aW9ucywKICAgIC8vICkgLT4gTWVzc2FnZUlkOgogICAgcHJvdG8gNyAzCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvSW5pdGlhbGlzYWJsZS5weTo2MwogICAgLy8gYXNzZXJ0IHNlbGYuaXNfaW5pdGlhbGlzZWQsICJVbmluaXRpYWxpc2VkIGNvbnRyYWN0IgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImlzX2luaXRpYWxpc2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2luaXRpYWxpc2VkIGV4aXN0cwogICAgYXNzZXJ0IC8vIFVuaW5pdGlhbGlzZWQgY29udHJhY3QKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozMTMKICAgIC8vIHNlbGYuX2NoZWNrX2lzX25vdF9wYXVzZWQoKQogICAgY2FsbHN1YiBfY2hlY2tfaXNfbm90X3BhdXNlZAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjMxNS0zMTYKICAgIC8vICMgY2hlY2sgcGF5bWVudCAtIGFtb3VudCBpcyBjaGVja2VkIGluIF90cmFuc2ZlciBzdWJyb3V0aW5lCiAgICAvLyBhc3NlcnQgZmVlX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywgZXJyLkZFRV9QQVlNRU5UX1JFQ0VJVkVSX1VOS05PV04KICAgIGZyYW1lX2RpZyAtNwogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFVua25vd24gZmVlIHBheW1lbnQgcmVjZWl2ZXIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozMTgtMzE5CiAgICAvLyAjIGNoZWNrIGFzc2V0IHRyYW5zZmVyCiAgICAvLyBudHRfdG9rZW5fYWRkcmVzcywgZXhpc3RzID0gb3AuQXBwUGFyYW1zR2V0LmFwcF9hZGRyZXNzKHNlbGYubnR0X3Rva2VuLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEyIC8vICJudHRfdG9rZW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubnR0X3Rva2VuIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjMyMAogICAgLy8gYXNzZXJ0IGV4aXN0cywgZXJyLk5UVF9UT0tFTl9BRERSRVNTX1VOS05PV04KICAgIGFzc2VydCAvLyBOdHRUb2tlbiBhZGRyZXNzIHVua25vd24KICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozMjEKICAgIC8vIGFzc2VydCBzZW5kX3Rva2VuLnhmZXJfYXNzZXQuaWQgPT0gc2VsZi5hc3NldF9pZC52YWx1ZSwgZXJyLkFTU0VUX1VOS05PV04KICAgIGZyYW1lX2RpZyAtNgogICAgZ3R4bnMgWGZlckFzc2V0CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTYgLy8gImFzc2V0X2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFzc2V0X2lkIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBVbmtub3duIGFzc2V0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzIyCiAgICAvLyBhc3NlcnQgc2VuZF90b2tlbi5hc3NldF9yZWNlaXZlciA9PSBudHRfdG9rZW5fYWRkcmVzcywgZXJyLkFTU0VUX1JFQ0VJVkVSX1VOS05PV04KICAgIGZyYW1lX2RpZyAtNgogICAgZ3R4bnMgQXNzZXRSZWNlaXZlcgogICAgPT0KICAgIGFzc2VydCAvLyBVbmtub3duIGFzc2V0IHJlY2VpdmVyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzIzCiAgICAvLyBhc3NlcnQgc2VuZF90b2tlbi5hc3NldF9hbW91bnQgPT0gYW1vdW50LCBlcnIuQVNTRVRfQU1PVU5UX0lOQ09SUkVDVAogICAgZnJhbWVfZGlnIC02CiAgICBndHhucyBBc3NldEFtb3VudAogICAgZnJhbWVfZGlnIC01CiAgICA9PQogICAgYXNzZXJ0IC8vIEluY29ycmVjdCBhc3NldCBhbW91bnQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozMjUtMzI2CiAgICAvLyAjIGNoZWNrIGFtb3VudCBhbmQgcmVjaXBpZW50IGFpbid0IHplcm8KICAgIC8vIGFzc2VydCBhbW91bnQsIGVyci5aRVJPX0FNT1VOVAogICAgZnJhbWVfZGlnIC01CiAgICBhc3NlcnQgLy8gQ2Fubm90IHRyYW5zZmVyIHplcm8gYW1vdW50CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzI3CiAgICAvLyBhc3NlcnQgcmVjaXBpZW50LmJ5dGVzICE9IG9wLmJ6ZXJvKGNvbnN0LkJZVEVTMzJfTEVOR1RIKSwgZXJyLlJFQ0lQSUVOVF9JTlZBTElECiAgICBpbnRjXzIgLy8gMzIKICAgIGJ6ZXJvCiAgICBmcmFtZV9kaWcgLTMKICAgICE9CiAgICBhc3NlcnQgLy8gSW52YWxpZCByZWNpcGllbnQgYWRkcmVzcwogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjMyOS0zMzAKICAgIC8vICMgYWxzbyBjaGVja3MgaWYga25vd24gcmVjaXBpZW50IGNoYWluCiAgICAvLyBudHRfbWFuYWdlcl9wZWVyID0gc2VsZi5nZXRfbnR0X21hbmFnZXJfcGVlcihyZWNpcGllbnRfY2hhaW4pCiAgICBmcmFtZV9kaWcgLTQKICAgIGNhbGxzdWIgZ2V0X250dF9tYW5hZ2VyX3BlZXIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozMzItMzMzCiAgICAvLyAjIHRyaW0gYW1vdW50IHRvIGNvbW1vbiBudW1iZXIgb2YgZGVjaW1hbHMKICAgIC8vIHRyaW1tZWRfYW1vdW50ID0gc2VsZi5fdHJpbV90cmFuc2Zlcl9hbW91bnQoYW1vdW50LCBudHRfbWFuYWdlcl9wZWVyLmRlY2ltYWxzKQogICAgZXh0cmFjdCAzMiAxCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDYzCiAgICAvLyBmcm9tX2RlY2ltYWxzID0gc2VsZi5fZ2V0X2Fzc2V0X2RlY2ltYWxzKCkKICAgIGNhbGxzdWIgX2dldF9hc3NldF9kZWNpbWFscwogICAgLy8gbnR0X2NvbnRyYWN0cy9saWJyYXJ5L1RyaW1tZWRBbW91bnRMaWIucHk6MzgKICAgIC8vIGFjdHVhbF90b19kZWNpbWFscyA9IE1hdGhMaWIubWluX3VpbnQ4KE1hdGhMaWIubWluX3VpbnQ4KFVJbnQ4KFRSSU1NRURfREVDSU1BTFMpLCBmcm9tX2RlY2ltYWxzKSwgdG9fZGVjaW1hbHMpCiAgICBwdXNoYnl0ZXMgMHgwOAogICAgLy8gbnR0X2NvbnRyYWN0cy9saWJyYXJ5L01hdGhMaWIucHk6MTAKICAgIC8vIHJldHVybiBhIGlmIGEgPCBiIGVsc2UgYgogICAgZGlnIDEKICAgIGI8CiAgICBkaWcgMQogICAgLy8gbnR0X2NvbnRyYWN0cy9saWJyYXJ5L1RyaW1tZWRBbW91bnRMaWIucHk6MzgKICAgIC8vIGFjdHVhbF90b19kZWNpbWFscyA9IE1hdGhMaWIubWluX3VpbnQ4KE1hdGhMaWIubWluX3VpbnQ4KFVJbnQ4KFRSSU1NRURfREVDSU1BTFMpLCBmcm9tX2RlY2ltYWxzKSwgdG9fZGVjaW1hbHMpCiAgICBwdXNoYnl0ZXMgMHgwOAogICAgLy8gbnR0X2NvbnRyYWN0cy9saWJyYXJ5L01hdGhMaWIucHk6MTAKICAgIC8vIHJldHVybiBhIGlmIGEgPCBiIGVsc2UgYgogICAgdW5jb3ZlciAyCiAgICBzZWxlY3QKICAgIGR1cAogICAgZGlnIDMKICAgIGI8CiAgICB1bmNvdmVyIDMKICAgIGNvdmVyIDIKICAgIHNlbGVjdAogICAgLy8gbnR0X2NvbnRyYWN0cy9saWJyYXJ5L1RyaW1tZWRBbW91bnRMaWIucHk6MzkKICAgIC8vIGFtb3VudF9zY2FsZWQgPSBzY2FsZShhbXQsIGZyb21fZGVjaW1hbHMsIGFjdHVhbF90b19kZWNpbWFscykKICAgIGZyYW1lX2RpZyAtNQogICAgZGlnIDIKICAgIGRpZyAyCiAgICBjYWxsc3ViIHNjYWxlCiAgICAvLyBudHRfY29udHJhY3RzL2xpYnJhcnkvVHJpbW1lZEFtb3VudExpYi5weTo0MAogICAgLy8gcmV0dXJuIFRyaW1tZWRBbW91bnQoQVJDNFVJbnQ2NChhbW91bnRfc2NhbGVkKSwgYWN0dWFsX3RvX2RlY2ltYWxzKQogICAgaXRvYgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC8vIG50dF9jb250cmFjdHMvbGlicmFyeS9UcmltbWVkQW1vdW50TGliLnB5OjUzCiAgICAvLyByZXR1cm4gc2NhbGUoYW10LmFtb3VudC5hc191aW50NjQoKSwgYW10LmRlY2ltYWxzLCB0b19kZWNpbWFscykKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgMQogICAgZXh0cmFjdCA4IDEKICAgIHVuY292ZXIgMwogICAgY2FsbHN1YiBzY2FsZQogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjQ2NwogICAgLy8gYXNzZXJ0IGFtb3VudCA9PSBuZXdfYW1vdW50LCBlcnIuVFJBTlNGRVJfQU1PVU5UX0hBU19EVVNUCiAgICBmcmFtZV9kaWcgLTUKICAgID09CiAgICBhc3NlcnQgLy8gVHJhbnNmZXIgYW1vdW50IGhhcyBkdXN0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6Mjk4CiAgICAvLyBzZWxmLm1lc3NhZ2Vfc2VxdWVuY2UgKz0gMQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE3IC8vICJtZXNzYWdlX3NlcXVlbmNlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm1lc3NhZ2Vfc2VxdWVuY2UgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWMgMTcgLy8gIm1lc3NhZ2Vfc2VxdWVuY2UiCiAgICBkaWcgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weToyOTkKICAgIC8vIHJldHVybiBNZXNzYWdlSWQuZnJvbV9ieXRlcyhvcC5rZWNjYWsyNTYob3AuaXRvYihzZWxmLm1lc3NhZ2Vfc2VxdWVuY2UpKSkKICAgIGl0b2IKICAgIGtlY2NhazI1NgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjMzOC0zNDcKICAgIC8vICMgY2hlY2sgaWYgcmF0ZSBsaW1pdGVkIGFuZCBlaXRoZXIgZW5xdWV1ZSBvciBjYXJyeSBvdXQgdHJhbnNmZXIKICAgIC8vIGlzX2VucXVldWVkID0gc2VsZi5fZW5xdWV1ZV9vcl9jb25zdW1lX291dGJvdW5kX3RyYW5zZmVyKAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICByZWNpcGllbnRfY2hhaW4sCiAgICAvLyAgICAgcmVjaXBpZW50LAogICAgLy8gICAgIHNob3VsZF9xdWV1ZSwKICAgIC8vICAgICB0cmFuc2NlaXZlcl9pbnN0cnVjdGlvbnMsCiAgICAvLyAgICAgdHJpbW1lZF9hbW91bnQsCiAgICAvLyAgICAgbWVzc2FnZV9pZAogICAgLy8gKQogICAgZnJhbWVfZGlnIC01CiAgICBmcmFtZV9kaWcgLTQKICAgIGZyYW1lX2RpZyAtMwogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIHVuY292ZXIgNgogICAgdW5jb3ZlciA2CiAgICBjYWxsc3ViIF9lbnF1ZXVlX29yX2NvbnN1bWVfb3V0Ym91bmRfdHJhbnNmZXIKICAgIGNvdmVyIDMKICAgIGZyYW1lX2J1cnkgLTEKICAgIGZyYW1lX2J1cnkgLTMKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozNDgKICAgIC8vIGlmIGlzX2VucXVldWVkOgogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAhPQogICAgYnogX3RyYW5zZmVyX2VudHJ5X3BvaW50X2Vsc2VfYm9keUA3CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzQ5LTM1MAogICAgLy8gIyByZWZ1bmQgZmVlIHBheW1lbnQKICAgIC8vIGl0eG4uUGF5bWVudChhbW91bnQ9ZmVlX3BheW1lbnQuYW1vdW50LCByZWNlaXZlcj1mZWVfcGF5bWVudC5zZW5kZXIsIGZlZT0wKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIC03CiAgICBndHhucyBBbW91bnQKICAgIGZyYW1lX2RpZyAtNwogICAgZ3R4bnMgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAoKX3RyYW5zZmVyX2VudHJ5X3BvaW50X2FmdGVyX2lmX2Vsc2VAMTI6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzYyCiAgICAvLyByZXR1cm4gbWVzc2FnZV9pZAogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2RpZyAtMwogICAgZnJhbWVfZGlnIC0xCiAgICB1bmNvdmVyIDQKICAgIHVuY292ZXIgNAogICAgcmV0c3ViCgpfdHJhbnNmZXJfZW50cnlfcG9pbnRfZWxzZV9ib2R5QDc6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzU5CiAgICAvLyBBZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgdHhuIFNlbmRlcgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjM1Mi0zNjEKICAgIC8vICMgY2Fycnkgb3V0IHRyYW5zZmVyCiAgICAvLyBzZWxmLl90cmFuc2ZlcigKICAgIC8vICAgICBmZWVfcGF5bWVudCwKICAgIC8vICAgICBtZXNzYWdlX2lkLAogICAgLy8gICAgIHRyaW1tZWRfYW1vdW50LAogICAgLy8gICAgIHJlY2lwaWVudF9jaGFpbiwKICAgIC8vICAgICByZWNpcGllbnQsCiAgICAvLyAgICAgQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICB0cmFuc2NlaXZlcl9pbnN0cnVjdGlvbnMsCiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTcKICAgIGZyYW1lX2RpZyAxCiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIC00CiAgICBmcmFtZV9kaWcgLTMKICAgIHVuY292ZXIgNQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF90cmFuc2ZlcgogICAgZnJhbWVfYnVyeSAtMQogICAgZnJhbWVfYnVyeSAtMwogICAgZnJhbWVfYnVyeSAxCiAgICBiIF90cmFuc2Zlcl9lbnRyeV9wb2ludF9hZnRlcl9pZl9lbHNlQDEyCgoKLy8gbnR0X2NvbnRyYWN0cy5udHRfbWFuYWdlci5OdHRNYW5hZ2VyLk50dE1hbmFnZXIuX3RyYW5zZmVyKGZlZV9wYXltZW50OiB1aW50NjQsIG1lc3NhZ2VfaWQ6IGJ5dGVzLCB0cmltbWVkX2Ftb3VudDogYnl0ZXMsIHJlY2lwaWVudF9jaGFpbjogYnl0ZXMsIHJlY2lwaWVudDogYnl0ZXMsIHNlbmRlcjogYnl0ZXMsIHRyYW5zY2VpdmVyX2luc3RydWN0aW9uczogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlcywgYnl0ZXM6Cl90cmFuc2ZlcjoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozNjQtMzc0CiAgICAvLyBAc3Vicm91dGluZShpbmxpbmU9RmFsc2UpCiAgICAvLyBkZWYgX3RyYW5zZmVyKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZmVlX3BheW1lbnQ6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIG1lc3NhZ2VfaWQ6IE1lc3NhZ2VJZCwKICAgIC8vICAgICB0cmltbWVkX2Ftb3VudDogVHJpbW1lZEFtb3VudCwKICAgIC8vICAgICByZWNpcGllbnRfY2hhaW46IFVJbnQxNiwKICAgIC8vICAgICByZWNpcGllbnQ6IFVuaXZlcnNhbEFkZHJlc3MsCiAgICAvLyAgICAgc2VuZGVyOiBBZGRyZXNzLAogICAgLy8gICAgIHRyYW5zY2VpdmVyX2luc3RydWN0aW9uczogVHJhbnNjZWl2ZXJJbnN0cnVjdGlvbnMsCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA3IDMKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozNzUtMzc2CiAgICAvLyAjIGFsc28gY2hlY2tzIGlmIGtub3duIHJlY2lwaWVudCBjaGFpbgogICAgLy8gbnR0X21hbmFnZXJfcGVlciA9IHNlbGYuZ2V0X250dF9tYW5hZ2VyX3BlZXIocmVjaXBpZW50X2NoYWluKQogICAgZnJhbWVfZGlnIC00CiAgICBjYWxsc3ViIGdldF9udHRfbWFuYWdlcl9wZWVyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzgxCiAgICAvLyB0cmltbWVkX2Ftb3VudC5kZWNpbWFscy5ieXRlcyArCiAgICBmcmFtZV9kaWcgLTUKICAgIGV4dHJhY3QgOCAxCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozODAKICAgIC8vIEJ5dGVzLmZyb21faGV4KE5UVF9QQVlMT0FEX1BSRUZJWCkgKwogICAgYnl0ZWMgMjQgLy8gMHg5OTRlNTQ1NAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjM4MC0zODEKICAgIC8vIEJ5dGVzLmZyb21faGV4KE5UVF9QQVlMT0FEX1BSRUZJWCkgKwogICAgLy8gdHJpbW1lZF9hbW91bnQuZGVjaW1hbHMuYnl0ZXMgKwogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzgyCiAgICAvLyBvcC5pdG9iKHRyaW1tZWRfYW1vdW50LmFtb3VudC5hc191aW50NjQoKSkgKwogICAgZnJhbWVfZGlnIC01CiAgICBleHRyYWN0IDAgOAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjM4MC0zODIKICAgIC8vIEJ5dGVzLmZyb21faGV4KE5UVF9QQVlMT0FEX1BSRUZJWCkgKwogICAgLy8gdHJpbW1lZF9hbW91bnQuZGVjaW1hbHMuYnl0ZXMgKwogICAgLy8gb3AuaXRvYih0cmltbWVkX2Ftb3VudC5hbW91bnQuYXNfdWludDY0KCkpICsKICAgIGNvbmNhdAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjM4MwogICAgLy8gQnl0ZXNVdGlscy5jb252ZXJ0X3VpbnQ2NF90b19ieXRlczMyKHNlbGYuYXNzZXRfaWQudmFsdWUpLmJ5dGVzICsKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNiAvLyAiYXNzZXRfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNzZXRfaWQgZXhpc3RzCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQnl0ZXNVdGlscy5weToxMAogICAgLy8gcmV0dXJuIEJ5dGVzMzIuZnJvbV9ieXRlcyhvcC5yZXBsYWNlKG9wLmJ6ZXJvKGNvbnN0LkJZVEVTMzJfTEVOR1RIKSwgY29uc3QuQllURVMyNF9MRU5HVEgsIG9wLml0b2IoYSkpKQogICAgaW50Y18yIC8vIDMyCiAgICBiemVybwogICAgc3dhcAogICAgaXRvYgogICAgZGlnIDEKICAgIHN3YXAKICAgIHJlcGxhY2UyIDI0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzgwLTM4MwogICAgLy8gQnl0ZXMuZnJvbV9oZXgoTlRUX1BBWUxPQURfUFJFRklYKSArCiAgICAvLyB0cmltbWVkX2Ftb3VudC5kZWNpbWFscy5ieXRlcyArCiAgICAvLyBvcC5pdG9iKHRyaW1tZWRfYW1vdW50LmFtb3VudC5hc191aW50NjQoKSkgKwogICAgLy8gQnl0ZXNVdGlscy5jb252ZXJ0X3VpbnQ2NF90b19ieXRlczMyKHNlbGYuYXNzZXRfaWQudmFsdWUpLmJ5dGVzICsKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzgwLTM4NAogICAgLy8gQnl0ZXMuZnJvbV9oZXgoTlRUX1BBWUxPQURfUFJFRklYKSArCiAgICAvLyB0cmltbWVkX2Ftb3VudC5kZWNpbWFscy5ieXRlcyArCiAgICAvLyBvcC5pdG9iKHRyaW1tZWRfYW1vdW50LmFtb3VudC5hc191aW50NjQoKSkgKwogICAgLy8gQnl0ZXNVdGlscy5jb252ZXJ0X3VpbnQ2NF90b19ieXRlczMyKHNlbGYuYXNzZXRfaWQudmFsdWUpLmJ5dGVzICsKICAgIC8vIHJlY2lwaWVudC5ieXRlcyArCiAgICBmcmFtZV9kaWcgLTMKICAgIGNvbmNhdAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjM4MC0zODUKICAgIC8vIEJ5dGVzLmZyb21faGV4KE5UVF9QQVlMT0FEX1BSRUZJWCkgKwogICAgLy8gdHJpbW1lZF9hbW91bnQuZGVjaW1hbHMuYnl0ZXMgKwogICAgLy8gb3AuaXRvYih0cmltbWVkX2Ftb3VudC5hbW91bnQuYXNfdWludDY0KCkpICsKICAgIC8vIEJ5dGVzVXRpbHMuY29udmVydF91aW50NjRfdG9fYnl0ZXMzMihzZWxmLmFzc2V0X2lkLnZhbHVlKS5ieXRlcyArCiAgICAvLyByZWNpcGllbnQuYnl0ZXMgKwogICAgLy8gcmVjaXBpZW50X2NoYWluLmJ5dGVzCiAgICBmcmFtZV9kaWcgLTQKICAgIGNvbmNhdAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjM3OC0zODYKICAgIC8vICMgY29uc3RydWN0IG1lc3NhZ2UgYnkgY29uY2F0ZW5hdGluZyB1bmRlcmx5aW5nIGJ5dGVzCiAgICAvLyBwYXlsb2FkID0gRHluYW1pY0J5dGVzKAogICAgLy8gICAgIEJ5dGVzLmZyb21faGV4KE5UVF9QQVlMT0FEX1BSRUZJWCkgKwogICAgLy8gICAgIHRyaW1tZWRfYW1vdW50LmRlY2ltYWxzLmJ5dGVzICsKICAgIC8vICAgICBvcC5pdG9iKHRyaW1tZWRfYW1vdW50LmFtb3VudC5hc191aW50NjQoKSkgKwogICAgLy8gICAgIEJ5dGVzVXRpbHMuY29udmVydF91aW50NjRfdG9fYnl0ZXMzMihzZWxmLmFzc2V0X2lkLnZhbHVlKS5ieXRlcyArCiAgICAvLyAgICAgcmVjaXBpZW50LmJ5dGVzICsKICAgIC8vICAgICByZWNpcGllbnRfY2hhaW4uYnl0ZXMKICAgIC8vICkKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6MzkwCiAgICAvLyBzb3VyY2VfYWRkcmVzcz1CeXRlc1V0aWxzLmNvbnZlcnRfdWludDY0X3RvX2J5dGVzMzIoR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQuaWQpLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQnl0ZXNVdGlscy5weToxMAogICAgLy8gcmV0dXJuIEJ5dGVzMzIuZnJvbV9ieXRlcyhvcC5yZXBsYWNlKG9wLmJ6ZXJvKGNvbnN0LkJZVEVTMzJfTEVOR1RIKSwgY29uc3QuQllURVMyNF9MRU5HVEgsIG9wLml0b2IoYSkpKQogICAgaXRvYgogICAgdW5jb3ZlciAyCiAgICBzd2FwCiAgICByZXBsYWNlMiAyNAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjM5MgogICAgLy8gaGFuZGxlcl9hZGRyZXNzPW50dF9tYW5hZ2VyX3BlZXIucGVlcl9jb250cmFjdC5jb3B5KCksCiAgICB1bmNvdmVyIDIKICAgIGV4dHJhY3QgMCAzMgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjM5Ni0zOTcKICAgIC8vICMgY2FsbCB0cmFuc2NlaXZlciBtYW5hZ2VyIHRvIHNlbmQgbWVzc2FnZSB0aHJvdWdoIGNvbmZpZ3VyZWQgdHJhbnNjZWl2ZXJzCiAgICAvLyB0b3RhbF9kZWxpdmVyeV9wcmljZSA9IHNlbGYuX3NlbmRfbWVzc2FnZShtZXNzYWdlLCB0cmFuc2NlaXZlcl9pbnN0cnVjdGlvbnMpCiAgICBmcmFtZV9kaWcgLTYKICAgIGZyYW1lX2RpZyAtMgogICAgdW5jb3ZlciAzCiAgICBmcmFtZV9kaWcgLTQKICAgIHVuY292ZXIgNAogICAgdW5jb3ZlciA1CiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX3NlbmRfbWVzc2FnZQogICAgZnJhbWVfYnVyeSAtMQogICAgcG9wbiA1CiAgICBkdXAKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTozOTktNDAwCiAgICAvLyAjIGNoZWNrIGZlZSBwYXltZW50IGFuZCBpZiBhcHBsaWNhYmxlLCByZWZ1bmQgZXhjZXNzCiAgICAvLyBhc3NlcnQgZmVlX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywgZXJyLkZFRV9QQVlNRU5UX1JFQ0VJVkVSX1VOS05PV04KICAgIGZyYW1lX2RpZyAtNwogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFVua25vd24gZmVlIHBheW1lbnQgcmVjZWl2ZXIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo0MDEKICAgIC8vIGFzc2VydCBmZWVfcGF5bWVudC5hbW91bnQgPj0gdG90YWxfZGVsaXZlcnlfcHJpY2UsIGVyci5GRUVfUEFZTUVOVF9BTU9VTlRfSU5TVUZGSUNJRU5UCiAgICBmcmFtZV9kaWcgLTcKICAgIGd0eG5zIEFtb3VudAogICAgZHVwCiAgICBkaWcgMgogICAgPj0KICAgIGFzc2VydCAvLyBJbnN1ZmZpY2llbnQgZmVlIHBheW1lbnQgYW1vdW50CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDAyCiAgICAvLyBleGNlc3NfZmVlX3BheW1lbnQgPSBmZWVfcGF5bWVudC5hbW91bnQgLSB0b3RhbF9kZWxpdmVyeV9wcmljZQogICAgc3dhcAogICAgLQogICAgZHVwCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDAzCiAgICAvLyBpZiBleGNlc3NfZmVlX3BheW1lbnQ6CiAgICBieiBfdHJhbnNmZXJfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDA0CiAgICAvLyBpdHhuLlBheW1lbnQoYW1vdW50PWV4Y2Vzc19mZWVfcGF5bWVudCwgcmVjZWl2ZXI9ZmVlX3BheW1lbnQuc2VuZGVyLCBmZWU9MCkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtNwogICAgZ3R4bnMgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgMgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCl90cmFuc2Zlcl9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDczCiAgICAvLyB0b19kZWNpbWFscyA9IHNlbGYuX2dldF9hc3NldF9kZWNpbWFscygpCiAgICBjYWxsc3ViIF9nZXRfYXNzZXRfZGVjaW1hbHMKICAgIC8vIG50dF9jb250cmFjdHMvbGlicmFyeS9UcmltbWVkQW1vdW50TGliLnB5OjUzCiAgICAvLyByZXR1cm4gc2NhbGUoYW10LmFtb3VudC5hc191aW50NjQoKSwgYW10LmRlY2ltYWxzLCB0b19kZWNpbWFscykKICAgIGZyYW1lX2RpZyAtNQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgMAogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIHNjYWxlCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDEwCiAgICAvLyBBUkM0VUludDY0KHNlbGYuX3VudHJpbV90cmFuc2Zlcl9hbW91bnQodHJpbW1lZF9hbW91bnQpKSwKICAgIGl0b2IKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo0MTEKICAgIC8vIEFSQzRVSW50NjQodG90YWxfZGVsaXZlcnlfcHJpY2UpLAogICAgZnJhbWVfZGlnIDEKICAgIGl0b2IKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo0MDYtNDEyCiAgICAvLyBlbWl0KFRyYW5zZmVyU2VudCgKICAgIC8vICAgICBtZXNzYWdlX2lkLAogICAgLy8gICAgIHJlY2lwaWVudCwKICAgIC8vICAgICByZWNpcGllbnRfY2hhaW4sCiAgICAvLyAgICAgQVJDNFVJbnQ2NChzZWxmLl91bnRyaW1fdHJhbnNmZXJfYW1vdW50KHRyaW1tZWRfYW1vdW50KSksCiAgICAvLyAgICAgQVJDNFVJbnQ2NCh0b3RhbF9kZWxpdmVyeV9wcmljZSksCiAgICAvLyApKQogICAgZnJhbWVfZGlnIC02CiAgICBmcmFtZV9kaWcgLTMKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC00CiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweGJlMGQ4YzY1IC8vIG1ldGhvZCAiVHJhbnNmZXJTZW50KGJ5dGVbMzJdLGJ5dGVbMzJdLHVpbnQxNix1aW50NjQsdWludDY0KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBmcmFtZV9kaWcgLTYKICAgIGZyYW1lX2RpZyAtMwogICAgZnJhbWVfZGlnIC0xCiAgICB1bmNvdmVyIDUKICAgIHVuY292ZXIgNQogICAgdW5jb3ZlciA1CiAgICByZXRzdWIKCgovLyBudHRfY29udHJhY3RzLm50dF9tYW5hZ2VyLk50dE1hbmFnZXIuTnR0TWFuYWdlci5fZ2V0X2Fzc2V0X2RlY2ltYWxzKCkgLT4gYnl0ZXM6Cl9nZXRfYXNzZXRfZGVjaW1hbHM6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dE1hbmFnZXIucHk6NDU3CiAgICAvLyBhc3NldF9kZWNpbWFscywgZXhpc3RzID0gb3AuQXNzZXRQYXJhbXNHZXQuYXNzZXRfZGVjaW1hbHMoc2VsZi5hc3NldF9pZC52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNiAvLyAiYXNzZXRfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNzZXRfaWQgZXhpc3RzCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo0NTgKICAgIC8vIGFzc2VydCBleGlzdHMsIGVyci5BU1NFVF9VTktOT1dOCiAgICBhc3NlcnQgLy8gVW5rbm93biBhc3NldAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjQ1OQogICAgLy8gcmV0dXJuIFVJbnQ4KGFzc2V0X2RlY2ltYWxzKQogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIGludGNfMyAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgcmV0c3ViCgoKLy8gbnR0X2NvbnRyYWN0cy5udHRfbWFuYWdlci5OdHRNYW5hZ2VyLk50dE1hbmFnZXIuX3JlZnVuZF9taW5fYmFsYW5jZV90b19jYWxsZXIoKSAtPiB2b2lkOgpfcmVmdW5kX21pbl9iYWxhbmNlX3RvX2NhbGxlcjoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0TWFuYWdlci5weTo0NzgtNDc5CiAgICAvLyAjIHRoaXMgd2lsbCBhbHNvIHNlbmQgYWxsIGRvbmF0ZWQgQUxHTyB0byB0aGUgY2FsbGVyCiAgICAvLyBhbW91bnQgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLQogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRNYW5hZ2VyLnB5OjQ4MAogICAgLy8gaXR4bi5QYXltZW50KGFtb3VudD1hbW91bnQsIHJlY2VpdmVyPVR4bi5zZW5kZXIsIGZlZT0wKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgdHhuIFNlbmRlcgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIG50dF9jb250cmFjdHMudHJhbnNjZWl2ZXIuTWVzc2FnZUhhbmRsZXIuTWVzc2FnZUhhbmRsZXIuaXNfbWVzc2FnZV9hcHByb3ZlZChtZXNzYWdlX2RpZ2VzdDogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlczoKaXNfbWVzc2FnZV9hcHByb3ZlZDoKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6NjktNzAKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBpc19tZXNzYWdlX2FwcHJvdmVkKHNlbGYsIG1lc3NhZ2VfZGlnZXN0OiBNZXNzYWdlRGlnZXN0KSAtPiBCb29sOgogICAgcHJvdG8gMSAyCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5Ojc2LTgxCiAgICAvLyBtZXNzYWdlX2F0dGVzdGF0aW9ucywgdHhuID0gYWJpX2NhbGwoCiAgICAvLyAgICAgSVRyYW5zY2VpdmVyTWFuYWdlci5tZXNzYWdlX2F0dGVzdGF0aW9ucywKICAgIC8vICAgICBtZXNzYWdlX2RpZ2VzdCwKICAgIC8vICAgICBhcHBfaWQ9c2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyLnZhbHVlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weTo3OQogICAgLy8gYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNCAvLyAidHJhbnNjZWl2ZXJfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyIGV4aXN0cwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5Ojc2LTgxCiAgICAvLyBtZXNzYWdlX2F0dGVzdGF0aW9ucywgdHhuID0gYWJpX2NhbGwoCiAgICAvLyAgICAgSVRyYW5zY2VpdmVyTWFuYWdlci5tZXNzYWdlX2F0dGVzdGF0aW9ucywKICAgIC8vICAgICBtZXNzYWdlX2RpZ2VzdCwKICAgIC8vICAgICBhcHBfaWQ9c2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyLnZhbHVlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4MDgwZGFmNmQgLy8gbWV0aG9kICJtZXNzYWdlX2F0dGVzdGF0aW9ucyhieXRlWzMyXSl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6ODAKICAgIC8vIGZlZT0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5Ojc2LTgxCiAgICAvLyBtZXNzYWdlX2F0dGVzdGF0aW9ucywgdHhuID0gYWJpX2NhbGwoCiAgICAvLyAgICAgSVRyYW5zY2VpdmVyTWFuYWdlci5tZXNzYWdlX2F0dGVzdGF0aW9ucywKICAgIC8vICAgICBtZXNzYWdlX2RpZ2VzdCwKICAgIC8vICAgICBhcHBfaWQ9c2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyLnZhbHVlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBsb2cgdmFsdWUgaXMgbm90IHRoZSByZXN1bHQgb2YgYW4gQUJJIHJldHVybgogICAgYnRvaQogICAgZHVwCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjgyCiAgICAvLyByZXR1cm4gQm9vbChtZXNzYWdlX2F0dGVzdGF0aW9ucyA+IDAgYW5kIG1lc3NhZ2VfYXR0ZXN0YXRpb25zID49IHNlbGYudGhyZXNob2xkLnZhbHVlKQogICAgYnogaXNfbWVzc2FnZV9hcHByb3ZlZF9ib29sX2ZhbHNlQDQKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyOCAvLyAidGhyZXNob2xkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRocmVzaG9sZCBleGlzdHMKICAgIGZyYW1lX2RpZyAwCiAgICA8PQogICAgYnogaXNfbWVzc2FnZV9hcHByb3ZlZF9ib29sX2ZhbHNlQDQKICAgIGludGNfMSAvLyAxCgppc19tZXNzYWdlX2FwcHJvdmVkX2Jvb2xfbWVyZ2VANToKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6ODIKICAgIC8vIHJldHVybiBCb29sKG1lc3NhZ2VfYXR0ZXN0YXRpb25zID4gMCBhbmQgbWVzc2FnZV9hdHRlc3RhdGlvbnMgPj0gc2VsZi50aHJlc2hvbGQudmFsdWUpCiAgICBieXRlY18wIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgZnJhbWVfZGlnIC0xCiAgICB1bmNvdmVyIDIKICAgIHJldHN1YgoKaXNfbWVzc2FnZV9hcHByb3ZlZF9ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzAgLy8gMAogICAgYiBpc19tZXNzYWdlX2FwcHJvdmVkX2Jvb2xfbWVyZ2VANQoKCi8vIG50dF9jb250cmFjdHMudHJhbnNjZWl2ZXIuTWVzc2FnZUhhbmRsZXIuTWVzc2FnZUhhbmRsZXIuaXNfbWVzc2FnZV9leGVjdXRlZChtZXNzYWdlX2RpZ2VzdDogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlczoKaXNfbWVzc2FnZV9leGVjdXRlZDoKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6ODQtODUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBpc19tZXNzYWdlX2V4ZWN1dGVkKHNlbGYsIG1lc3NhZ2VfZGlnZXN0OiBNZXNzYWdlRGlnZXN0KSAtPiBCb29sOgogICAgcHJvdG8gMSAyCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjkzCiAgICAvLyByZXR1cm4gQm9vbChtZXNzYWdlX2RpZ2VzdCBpbiBzZWxmLm1lc3NhZ2VzX2V4ZWN1dGVkKSBhbmQgc2VsZi5tZXNzYWdlc19leGVjdXRlZFttZXNzYWdlX2RpZ2VzdF0KICAgIGJ5dGVjIDIzIC8vIDB4NmQ2NTczNzM2MTY3NjU3MzVmNjU3ODY1NjM3NTc0NjU2NDVmCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBkdXAKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgPT0KICAgIGJ6IGlzX21lc3NhZ2VfZXhlY3V0ZWRfdGVybmFyeV9mYWxzZUAyCiAgICBmcmFtZV9kaWcgMQoKaXNfbWVzc2FnZV9leGVjdXRlZF90ZXJuYXJ5X21lcmdlQDM6CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjkzCiAgICAvLyByZXR1cm4gQm9vbChtZXNzYWdlX2RpZ2VzdCBpbiBzZWxmLm1lc3NhZ2VzX2V4ZWN1dGVkKSBhbmQgc2VsZi5tZXNzYWdlc19leGVjdXRlZFttZXNzYWdlX2RpZ2VzdF0KICAgIGZyYW1lX2RpZyAtMQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDMKICAgIHJldHN1YgoKaXNfbWVzc2FnZV9leGVjdXRlZF90ZXJuYXJ5X2ZhbHNlQDI6CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjkzCiAgICAvLyByZXR1cm4gQm9vbChtZXNzYWdlX2RpZ2VzdCBpbiBzZWxmLm1lc3NhZ2VzX2V4ZWN1dGVkKSBhbmQgc2VsZi5tZXNzYWdlc19leGVjdXRlZFttZXNzYWdlX2RpZ2VzdF0KICAgIGZyYW1lX2RpZyAwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5tZXNzYWdlc19leGVjdXRlZCBlbnRyeSBleGlzdHMKICAgIGIgaXNfbWVzc2FnZV9leGVjdXRlZF90ZXJuYXJ5X21lcmdlQDMKCgovLyBudHRfY29udHJhY3RzLnRyYW5zY2VpdmVyLk1lc3NhZ2VIYW5kbGVyLk1lc3NhZ2VIYW5kbGVyLl9zZXRfdHJhbnNjZWl2ZXJfbWFuYWdlcihhZG1pbl9pbl90cmFuc2NlaXZlcl9tYW5hZ2VyOiBieXRlcywgdHJhbnNjZWl2ZXJfbWFuYWdlcjogdWludDY0KSAtPiB2b2lkOgpfc2V0X3RyYW5zY2VpdmVyX21hbmFnZXI6CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5Ojk1LTk2CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9zZXRfdHJhbnNjZWl2ZXJfbWFuYWdlcihzZWxmLCBhZG1pbl9pbl90cmFuc2NlaXZlcl9tYW5hZ2VyOiBBZGRyZXNzLCB0cmFuc2NlaXZlcl9tYW5hZ2VyOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MTA4CiAgICAvLyBzZWxmLnRyYW5zY2VpdmVyX21hbmFnZXIudmFsdWUgPSB0cmFuc2NlaXZlcl9tYW5hZ2VyCiAgICBieXRlYyAxNCAvLyAidHJhbnNjZWl2ZXJfbWFuYWdlciIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MTA5LTExNAogICAgLy8gYWJpX2NhbGwoCiAgICAvLyAgICAgSVRyYW5zY2VpdmVyTWFuYWdlci5hZGRfbWVzc2FnZV9oYW5kbGVyLAogICAgLy8gICAgIGFkbWluX2luX3RyYW5zY2VpdmVyX21hbmFnZXIsCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHhmNDQyNmE2ZiAvLyBtZXRob2QgImFkZF9tZXNzYWdlX2hhbmRsZXIoYWRkcmVzcylib29sIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjExMwogICAgLy8gZmVlPTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MTA5LTExNAogICAgLy8gYWJpX2NhbGwoCiAgICAvLyAgICAgSVRyYW5zY2VpdmVyTWFuYWdlci5hZGRfbWVzc2FnZV9oYW5kbGVyLAogICAgLy8gICAgIGFkbWluX2luX3RyYW5zY2VpdmVyX21hbmFnZXIsCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuYm9vbAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBsb2cgdmFsdWUgaXMgbm90IHRoZSByZXN1bHQgb2YgYW4gQUJJIHJldHVybgogICAgcmV0c3ViCgoKLy8gbnR0X2NvbnRyYWN0cy50cmFuc2NlaXZlci5NZXNzYWdlSGFuZGxlci5NZXNzYWdlSGFuZGxlci5fc2V0X3RocmVzaG9sZChuZXdfdGhyZXNob2xkOiB1aW50NjQpIC0+IHZvaWQ6Cl9zZXRfdGhyZXNob2xkOgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weToxMTYtMTE3CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9zZXRfdGhyZXNob2xkKHNlbGYsIG5ld190aHJlc2hvbGQ6IFVJbnQ2NCkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weToxMzIKICAgIC8vIGFzc2VydCBuZXdfdGhyZXNob2xkLCBlcnIuWkVST19USFJFU0hPTEQKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXJ0IC8vIENhbm5vdCBzZXQgemVybyB0aHJlc2hvbGQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MTMzCiAgICAvLyBzZWxmLnRocmVzaG9sZC52YWx1ZSA9IG5ld190aHJlc2hvbGQKICAgIGJ5dGVjIDI4IC8vICJ0aHJlc2hvbGQiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjEzNAogICAgLy8gZW1pdChUaHJlc2hvbGRVcGRhdGVkKEFSQzRVSW50NjQobmV3X3RocmVzaG9sZCkpKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHhlMTFiNmVlMCAvLyBtZXRob2QgIlRocmVzaG9sZFVwZGF0ZWQodWludDY0KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICByZXRzdWIKCgovLyBudHRfY29udHJhY3RzLnRyYW5zY2VpdmVyLk1lc3NhZ2VIYW5kbGVyLk1lc3NhZ2VIYW5kbGVyLl9zZW5kX21lc3NhZ2UobWVzc2FnZS5pZDogYnl0ZXMsIG1lc3NhZ2UudXNlcl9hZGRyZXNzOiBieXRlcywgbWVzc2FnZS5zb3VyY2VfYWRkcmVzczogYnl0ZXMsIG1lc3NhZ2UuZGVzdGluYXRpb25fY2hhaW5faWQ6IGJ5dGVzLCBtZXNzYWdlLmhhbmRsZXJfYWRkcmVzczogYnl0ZXMsIG1lc3NhZ2UucGF5bG9hZDogYnl0ZXMsIHRyYW5zY2VpdmVyX2luc3RydWN0aW9uczogYnl0ZXMpIC0+IHVpbnQ2NCwgYnl0ZXMsIGJ5dGVzLCBieXRlcywgYnl0ZXMsIGJ5dGVzLCBieXRlczoKX3NlbmRfbWVzc2FnZToKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MTM2LTEzNwogICAgLy8gQHN1YnJvdXRpbmUoaW5saW5lPUZhbHNlKQogICAgLy8gZGVmIF9zZW5kX21lc3NhZ2Uoc2VsZiwgbWVzc2FnZTogTWVzc2FnZVRvU2VuZCwgdHJhbnNjZWl2ZXJfaW5zdHJ1Y3Rpb25zOiBUcmFuc2NlaXZlckluc3RydWN0aW9ucykgLT4gVUludDY0OgogICAgcHJvdG8gNyA3CiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjE1MC0xNTgKICAgIC8vICMgcXVvdGUgdG90YWwgZGVsaXZlcnkgcHJpY2UKICAgIC8vIHRvdGFsX2RlbGl2ZXJ5X3ByaWNlLCB0eG4gPSBhYmlfY2FsbCgKICAgIC8vICAgICBJVHJhbnNjZWl2ZXJNYW5hZ2VyLnF1b3RlX2RlbGl2ZXJ5X3ByaWNlcywKICAgIC8vICAgICBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9pZC5pZCwKICAgIC8vICAgICBtZXNzYWdlLAogICAgLy8gICAgIHRyYW5zY2VpdmVyX2luc3RydWN0aW9ucywKICAgIC8vICAgICBhcHBfaWQ9c2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyLnZhbHVlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weToxNTMKICAgIC8vIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLmlkLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICBpdG9iCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjE1NAogICAgLy8gbWVzc2FnZSwKICAgIGZyYW1lX2RpZyAtNwogICAgZnJhbWVfZGlnIC02CiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtNQogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTQKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0zCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDAwODQKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MTU2CiAgICAvLyBhcHBfaWQ9c2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE0IC8vICJ0cmFuc2NlaXZlcl9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRyYW5zY2VpdmVyX21hbmFnZXIgZXhpc3RzCiAgICBkdXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weToxNTAtMTU4CiAgICAvLyAjIHF1b3RlIHRvdGFsIGRlbGl2ZXJ5IHByaWNlCiAgICAvLyB0b3RhbF9kZWxpdmVyeV9wcmljZSwgdHhuID0gYWJpX2NhbGwoCiAgICAvLyAgICAgSVRyYW5zY2VpdmVyTWFuYWdlci5xdW90ZV9kZWxpdmVyeV9wcmljZXMsCiAgICAvLyAgICAgR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQuaWQsCiAgICAvLyAgICAgbWVzc2FnZSwKICAgIC8vICAgICB0cmFuc2NlaXZlcl9pbnN0cnVjdGlvbnMsCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIHB1c2hieXRlcyAweDI3Yzk2ZTMwIC8vIG1ldGhvZCAicXVvdGVfZGVsaXZlcnlfcHJpY2VzKHVpbnQ2NCwoYnl0ZVszMl0sYnl0ZVszMl0sYnl0ZVszMl0sdWludDE2LGJ5dGVbMzJdLGJ5dGVbXSksKHVpbnQ2NCxieXRlW10pW10pdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MTU3CiAgICAvLyBmZWU9MCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weToxNTAtMTU4CiAgICAvLyAjIHF1b3RlIHRvdGFsIGRlbGl2ZXJ5IHByaWNlCiAgICAvLyB0b3RhbF9kZWxpdmVyeV9wcmljZSwgdHhuID0gYWJpX2NhbGwoCiAgICAvLyAgICAgSVRyYW5zY2VpdmVyTWFuYWdlci5xdW90ZV9kZWxpdmVyeV9wcmljZXMsCiAgICAvLyAgICAgR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQuaWQsCiAgICAvLyAgICAgbWVzc2FnZSwKICAgIC8vICAgICB0cmFuc2NlaXZlcl9pbnN0cnVjdGlvbnMsCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gbG9nIHZhbHVlIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGFuIEFCSSByZXR1cm4KICAgIGJ0b2kKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MTYwLTE2MQogICAgLy8gIyBzZW5kIG1lc3NhZ2UKICAgIC8vIHRyYW5zY2VpdmVyX21hbmFnZXJfYWRkcmVzcywgZXhpc3RzID0gb3AuQXBwUGFyYW1zR2V0LmFwcF9hZGRyZXNzKHNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSkKICAgIGRpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjE2MgogICAgLy8gYXNzZXJ0IGV4aXN0cywgZXJyLlRSQU5TQ0VJVkVSX01BTkFHRVJfQUREUkVTU19VTktOT1dOCiAgICBhc3NlcnQgLy8gVHJhbnNjZWl2ZXJNYW5hZ2VyIGFkZHJlc3MgdW5rbm93bgogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weToxNjMtMTcwCiAgICAvLyBhYmlfY2FsbCgKICAgIC8vICAgICBJVHJhbnNjZWl2ZXJNYW5hZ2VyLnNlbmRfbWVzc2FnZV90b190cmFuc2NlaXZlcnMsCiAgICAvLyAgICAgaXR4bi5QYXltZW50KGFtb3VudD10b3RhbF9kZWxpdmVyeV9wcmljZSwgcmVjZWl2ZXI9dHJhbnNjZWl2ZXJfbWFuYWdlcl9hZGRyZXNzLCBmZWU9MCksCiAgICAvLyAgICAgbWVzc2FnZSwKICAgIC8vICAgICB0cmFuc2NlaXZlcl9pbnN0cnVjdGlvbnMsCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGR1cAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MTY1CiAgICAvLyBpdHhuLlBheW1lbnQoYW1vdW50PXRvdGFsX2RlbGl2ZXJ5X3ByaWNlLCByZWNlaXZlcj10cmFuc2NlaXZlcl9tYW5hZ2VyX2FkZHJlc3MsIGZlZT0wKSwKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weToxNjMtMTcwCiAgICAvLyBhYmlfY2FsbCgKICAgIC8vICAgICBJVHJhbnNjZWl2ZXJNYW5hZ2VyLnNlbmRfbWVzc2FnZV90b190cmFuc2NlaXZlcnMsCiAgICAvLyAgICAgaXR4bi5QYXltZW50KGFtb3VudD10b3RhbF9kZWxpdmVyeV9wcmljZSwgcmVjZWl2ZXI9dHJhbnNjZWl2ZXJfbWFuYWdlcl9hZGRyZXNzLCBmZWU9MCksCiAgICAvLyAgICAgbWVzc2FnZSwKICAgIC8vICAgICB0cmFuc2NlaXZlcl9pbnN0cnVjdGlvbnMsCiAgICAvLyAgICAgYXBwX2lkPXNlbGYudHJhbnNjZWl2ZXJfbWFuYWdlci52YWx1ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkKICAgIGl0eG5fbmV4dAogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHhiYzFjMjliZSAvLyBtZXRob2QgInNlbmRfbWVzc2FnZV90b190cmFuc2NlaXZlcnMocGF5LChieXRlWzMyXSxieXRlWzMyXSxieXRlWzMyXSx1aW50MTYsYnl0ZVszMl0sYnl0ZVtdKSwodWludDY0LGJ5dGVbXSlbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gbnR0X2NvbnRyYWN0cy90cmFuc2NlaXZlci9NZXNzYWdlSGFuZGxlci5weToxNjkKICAgIC8vIGZlZT0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBudHRfY29udHJhY3RzL3RyYW5zY2VpdmVyL01lc3NhZ2VIYW5kbGVyLnB5OjE2My0xNzAKICAgIC8vIGFiaV9jYWxsKAogICAgLy8gICAgIElUcmFuc2NlaXZlck1hbmFnZXIuc2VuZF9tZXNzYWdlX3RvX3RyYW5zY2VpdmVycywKICAgIC8vICAgICBpdHhuLlBheW1lbnQoYW1vdW50PXRvdGFsX2RlbGl2ZXJ5X3ByaWNlLCByZWNlaXZlcj10cmFuc2NlaXZlcl9tYW5hZ2VyX2FkZHJlc3MsIGZlZT0wKSwKICAgIC8vICAgICBtZXNzYWdlLAogICAgLy8gICAgIHRyYW5zY2VpdmVyX2luc3RydWN0aW9ucywKICAgIC8vICAgICBhcHBfaWQ9c2VsZi50cmFuc2NlaXZlcl9tYW5hZ2VyLnZhbHVlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIG50dF9jb250cmFjdHMvdHJhbnNjZWl2ZXIvTWVzc2FnZUhhbmRsZXIucHk6MTcyLTE3MwogICAgLy8gIyByZXR1cm4gdG90YWwKICAgIC8vIHJldHVybiB0b3RhbF9kZWxpdmVyeV9wcmljZQogICAgZnJhbWVfZGlnIC03CiAgICBmcmFtZV9kaWcgLTYKICAgIGZyYW1lX2RpZyAtNQogICAgZnJhbWVfZGlnIC0zCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgcmV0c3ViCgoKLy8gbnR0X2NvbnRyYWN0cy5udHRfbWFuYWdlci5OdHRSYXRlTGltaXRlci5OdHRSYXRlTGltaXRlci5nZXRfb3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyKG1lc3NhZ2VfaWQ6IGJ5dGVzKSAtPiBieXRlcywgYnl0ZXMsIGJ5dGVzOgpnZXRfb3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyOgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxMzgtMTM5CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgZ2V0X291dGJvdW5kX3F1ZXVlZF90cmFuc2ZlcihzZWxmLCBtZXNzYWdlX2lkOiBNZXNzYWdlSWQpIC0+IFR1cGxlW0Jvb2wsIE91dGJvdW5kUXVldWVkVHJhbnNmZXJdOgogICAgcHJvdG8gMSAzCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjMzMAogICAgLy8gYXNzZXJ0IG1lc3NhZ2VfaWQgaW4gc2VsZi5vdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXJzLCBlcnIuT1VUQk9VTkRfUVVFVUVEX1RSQU5TRkVSX1VOS05PV04KICAgIGJ5dGVjIDIxIC8vIDB4NmY3NTc0NjI2Zjc1NmU2NDVmNzE3NTY1NzU2NTY0NWY3NDcyNjE2ZTczNjY2NTcyNzM1ZgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gVW5rbm93biBvdXRib3VuZCBxdWV1ZWQgdHJhbnNmZXIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTUwCiAgICAvLyBvdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXIgPSBzZWxmLm91dGJvdW5kX3F1ZXVlZF90cmFuc2ZlcnNbbWVzc2FnZV9pZF0uY29weSgpCiAgICBkdXAKICAgIGJveF9nZXQKICAgIHBvcAogICAgc3dhcAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxNTItMTUzCiAgICAvLyAjIGluY2x1ZGUgd2hldGhlciBzdWZmaWNpZW50IHRpbWUgaGFzIHBhc3NlZAogICAgLy8gZGVsdGEgPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCAtIG91dGJvdW5kX3F1ZXVlZF90cmFuc2Zlci50aW1lc3RhbXAuYXNfdWludDY0KCkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIHN3YXAKICAgIGludGNfMCAvLyAwCiAgICBpbnRjXzMgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIC0KICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTkzCiAgICAvLyByZXR1cm4gQnl0ZXMzMi5mcm9tX2J5dGVzKG9wLmtlY2NhazI1NihiIk9VVEJPVU5EIikpCiAgICBieXRlYyA0IC8vIDB4ZDQ2ZWMzYjhiZDU0NGZiZGQyYTFhYWIwZGRlN2YzMDc4YTY2Njg4ZjM4NTJlZDA1MGJkZDc5YWQ2YmFkNjM5YgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxNTQKICAgIC8vIGNhbl9jb21wbGV0ZSA9IGRlbHRhID49IHNlbGYuZ2V0X3JhdGVfZHVyYXRpb24oc2VsZi5vdXRib3VuZF9idWNrZXRfaWQoKSkKICAgIGNhbGxzdWIgZ2V0X3JhdGVfZHVyYXRpb24KICAgIHBvcAogICAgPj0KICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTU2CiAgICAvLyByZXR1cm4gQm9vbChjYW5fY29tcGxldGUpLCBvdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXIuY29weSgpCiAgICBieXRlY18wIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgc3dhcAogICAgZnJhbWVfZGlnIC0xCiAgICByZXRzdWIKCgovLyBudHRfY29udHJhY3RzLm50dF9tYW5hZ2VyLk50dFJhdGVMaW1pdGVyLk50dFJhdGVMaW1pdGVyLmdldF9pbmJvdW5kX3F1ZXVlZF90cmFuc2ZlcihtZXNzYWdlX2RpZ2VzdDogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlcywgYnl0ZXM6CmdldF9pbmJvdW5kX3F1ZXVlZF90cmFuc2ZlcjoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTY3LTE2OAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgLy8gZGVmIGdldF9pbmJvdW5kX3F1ZXVlZF90cmFuc2ZlcihzZWxmLCBtZXNzYWdlX2RpZ2VzdDogTWVzc2FnZURpZ2VzdCkgLT4gVHVwbGVbQm9vbCwgSW5ib3VuZFF1ZXVlZFRyYW5zZmVyXToKICAgIHByb3RvIDEgMwogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weTozMzQKICAgIC8vIGFzc2VydCBtZXNzYWdlX2RpZ2VzdCBpbiBzZWxmLmluYm91bmRfcXVldWVkX3RyYW5zZmVycywgZXJyLklOQk9VTkRfUVVFVUVEX1RSQU5TRkVSX1VOS05PV04KICAgIGJ5dGVjIDIwIC8vIDB4Njk2ZTYyNmY3NTZlNjQ1ZjcxNzU2NTc1NjU2NDVmNzQ3MjYxNmU3MzY2NjU3MjczNWYKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIFVua25vd24gaW5ib3VuZCBxdWV1ZWQgdHJhbnNmZXIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTc5CiAgICAvLyBpbmJvdW5kX3F1ZXVlZF90cmFuc2ZlciA9IHNlbGYuaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXJzW21lc3NhZ2VfZGlnZXN0XQogICAgYm94X2dldAogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE4MS0xODIKICAgIC8vICMgaW5jbHVkZSB3aGV0aGVyIHN1ZmZpY2llbnQgdGltZSBoYXMgcGFzc2VkCiAgICAvLyBkZWx0YSA9IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wIC0gaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXIudGltZXN0YW1wLmFzX3VpbnQ2NCgpCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBkaWcgMQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAtCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE4MwogICAgLy8gY2FuX2NvbXBsZXRlID0gZGVsdGEgPj0gc2VsZi5nZXRfcmF0ZV9kdXJhdGlvbihzZWxmLmluYm91bmRfYnVja2V0X2lkKGluYm91bmRfcXVldWVkX3RyYW5zZmVyLnNvdXJjZV9jaGFpbikpCiAgICBkaWcgMQogICAgZXh0cmFjdCAxNyAyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE4OQogICAgLy8gcmV0dXJuIEJ5dGVzMzIuZnJvbV9ieXRlcyhvcC5rZWNjYWsyNTYoYiJJTkJPVU5EXyIgKyBjaGFpbl9pZC5ieXRlcykpCiAgICBieXRlYyA1IC8vIDB4NDk0ZTQyNGY1NTRlNDQ1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBrZWNjYWsyNTYKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTgzCiAgICAvLyBjYW5fY29tcGxldGUgPSBkZWx0YSA+PSBzZWxmLmdldF9yYXRlX2R1cmF0aW9uKHNlbGYuaW5ib3VuZF9idWNrZXRfaWQoaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXIuc291cmNlX2NoYWluKSkKICAgIGNhbGxzdWIgZ2V0X3JhdGVfZHVyYXRpb24KICAgIHBvcAogICAgPj0KICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTg1CiAgICAvLyByZXR1cm4gQm9vbChjYW5fY29tcGxldGUpLCBpbmJvdW5kX3F1ZXVlZF90cmFuc2ZlcgogICAgYnl0ZWNfMCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIHN3YXAKICAgIGZyYW1lX2RpZyAtMQogICAgcmV0c3ViCgoKLy8gbnR0X2NvbnRyYWN0cy5udHRfbWFuYWdlci5OdHRSYXRlTGltaXRlci5OdHRSYXRlTGltaXRlci5fZW5xdWV1ZV9vcl9jb25zdW1lX291dGJvdW5kX3RyYW5zZmVyKHVudHJpbW1lZF9hbW91bnQ6IHVpbnQ2NCwgcmVjaXBpZW50X2NoYWluOiBieXRlcywgcmVjaXBpZW50OiBieXRlcywgc2hvdWxkX3F1ZXVlOiBieXRlcywgdHJhbnNjZWl2ZXJfaW5zdHJ1Y3Rpb25zOiBieXRlcywgdHJpbW1lZF9hbW91bnQ6IGJ5dGVzLCBtZXNzYWdlX2lkOiBieXRlcykgLT4gYnl0ZXMsIGJ5dGVzLCBieXRlcywgYnl0ZXM6Cl9lbnF1ZXVlX29yX2NvbnN1bWVfb3V0Ym91bmRfdHJhbnNmZXI6CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE5OS0yMDkKICAgIC8vIEBzdWJyb3V0aW5lKGlubGluZT1GYWxzZSkKICAgIC8vIGRlZiBfZW5xdWV1ZV9vcl9jb25zdW1lX291dGJvdW5kX3RyYW5zZmVyKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdW50cmltbWVkX2Ftb3VudDogVUludDY0LAogICAgLy8gICAgIHJlY2lwaWVudF9jaGFpbjogVUludDE2LAogICAgLy8gICAgIHJlY2lwaWVudDogVW5pdmVyc2FsQWRkcmVzcywKICAgIC8vICAgICBzaG91bGRfcXVldWU6IEJvb2wsCiAgICAvLyAgICAgdHJhbnNjZWl2ZXJfaW5zdHJ1Y3Rpb25zOiBUcmFuc2NlaXZlckluc3RydWN0aW9ucywKICAgIC8vICAgICB0cmltbWVkX2Ftb3VudDogVHJpbW1lZEFtb3VudCwKICAgIC8vICAgICBtZXNzYWdlX2lkOiBNZXNzYWdlSWQsCiAgICAvLyApIC0+IEJvb2w6CiAgICBwcm90byA3IDQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MjI1LTIyNgogICAgLy8gIyBjaGVjayByYXRlIGxpbWl0CiAgICAvLyBoYXNfY2FwYWNpdHkgPSBzZWxmLmhhc19jYXBhY2l0eShzZWxmLm91dGJvdW5kX2J1Y2tldF9pZCgpLCBVSW50MjU2KHVudHJpbW1lZF9hbW91bnQpKQogICAgZnJhbWVfZGlnIC03CiAgICBpdG9iCiAgICBkdXAKICAgIGludGNfMiAvLyAzMgogICAgYnplcm8KICAgIGJ8CiAgICBkdXAKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTkzCiAgICAvLyByZXR1cm4gQnl0ZXMzMi5mcm9tX2J5dGVzKG9wLmtlY2NhazI1NihiIk9VVEJPVU5EIikpCiAgICBieXRlYyA0IC8vIDB4ZDQ2ZWMzYjhiZDU0NGZiZGQyYTFhYWIwZGRlN2YzMDc4YTY2Njg4ZjM4NTJlZDA1MGJkZDc5YWQ2YmFkNjM5YgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyMjUtMjI2CiAgICAvLyAjIGNoZWNrIHJhdGUgbGltaXQKICAgIC8vIGhhc19jYXBhY2l0eSA9IHNlbGYuaGFzX2NhcGFjaXR5KHNlbGYub3V0Ym91bmRfYnVja2V0X2lkKCksIFVJbnQyNTYodW50cmltbWVkX2Ftb3VudCkpCiAgICBzd2FwCiAgICBjYWxsc3ViIGhhc19jYXBhY2l0eQogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjIyNwogICAgLy8gYXNzZXJ0IHNob3VsZF9xdWV1ZSBvciBoYXNfY2FwYWNpdHksIGVyci5PVVRCT1VORF9RVUVVRURfVFJBTlNGRVJfSU5TVUZGSUNJRU5UX0NBUEFDSVRZCiAgICBmcmFtZV9kaWcgLTQKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgIT0KICAgIGR1cAogICAgYm56IF9lbnF1ZXVlX29yX2NvbnN1bWVfb3V0Ym91bmRfdHJhbnNmZXJfYm9vbF90cnVlQDIKICAgIGZyYW1lX2RpZyAyCiAgICBieXRlY18wIC8vIDB4MDAKICAgICE9CiAgICBieiBfZW5xdWV1ZV9vcl9jb25zdW1lX291dGJvdW5kX3RyYW5zZmVyX2Jvb2xfZmFsc2VAMwoKX2VucXVldWVfb3JfY29uc3VtZV9vdXRib3VuZF90cmFuc2Zlcl9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgpfZW5xdWV1ZV9vcl9jb25zdW1lX291dGJvdW5kX3RyYW5zZmVyX2Jvb2xfbWVyZ2VANDoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MjI3CiAgICAvLyBhc3NlcnQgc2hvdWxkX3F1ZXVlIG9yIGhhc19jYXBhY2l0eSwgZXJyLk9VVEJPVU5EX1FVRVVFRF9UUkFOU0ZFUl9JTlNVRkZJQ0lFTlRfQ0FQQUNJVFkKICAgIGFzc2VydCAvLyBJbnN1ZmZpY2llbnQgY2FwYWNpdHkgZm9yIG91dGJvdW5kIHF1ZXVlZCB0cmFuc2ZlcgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyMjktMjMwCiAgICAvLyAjIGVucXVldWUgaWYgbmVlZGVkCiAgICAvLyBpZiBzaG91bGRfcXVldWUgYW5kIG5vdCBoYXNfY2FwYWNpdHk6CiAgICBmcmFtZV9kaWcgMwogICAgYnogX2VucXVldWVfb3JfY29uc3VtZV9vdXRib3VuZF90cmFuc2Zlcl9hZnRlcl9pZl9lbHNlQDcKICAgIGZyYW1lX2RpZyAyCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjIyNwogICAgLy8gYXNzZXJ0IHNob3VsZF9xdWV1ZSBvciBoYXNfY2FwYWNpdHksIGVyci5PVVRCT1VORF9RVUVVRURfVFJBTlNGRVJfSU5TVUZGSUNJRU5UX0NBUEFDSVRZCiAgICBieXRlY18wIC8vIDB4MDAKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MjI5LTIzMAogICAgLy8gIyBlbnF1ZXVlIGlmIG5lZWRlZAogICAgLy8gaWYgc2hvdWxkX3F1ZXVlIGFuZCBub3QgaGFzX2NhcGFjaXR5OgogICAgPT0KICAgIGJ6IF9lbnF1ZXVlX29yX2NvbnN1bWVfb3V0Ym91bmRfdHJhbnNmZXJfYWZ0ZXJfaWZfZWxzZUA3CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjIzMwogICAgLy8gQVJDNFVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjIzNwogICAgLy8gQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MjMxLTIzOQogICAgLy8gIyBlbnF1ZXVlIHRyYW5zZmVyCiAgICAvLyBzZWxmLm91dGJvdW5kX3F1ZXVlZF90cmFuc2ZlcnNbbWVzc2FnZV9pZF0gPSBPdXRib3VuZFF1ZXVlZFRyYW5zZmVyKAogICAgLy8gICAgIEFSQzRVSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gICAgIHRyaW1tZWRfYW1vdW50LAogICAgLy8gICAgIHJlY2lwaWVudF9jaGFpbiwKICAgIC8vICAgICByZWNpcGllbnQuY29weSgpLAogICAgLy8gICAgIEFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgdHJhbnNjZWl2ZXJfaW5zdHJ1Y3Rpb25zLmNvcHkoKQogICAgLy8gKQogICAgc3dhcAogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtNgogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTUKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHgwMDU1CiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMwogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjIzMS0yMzIKICAgIC8vICMgZW5xdWV1ZSB0cmFuc2ZlcgogICAgLy8gc2VsZi5vdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXJzW21lc3NhZ2VfaWRdID0gT3V0Ym91bmRRdWV1ZWRUcmFuc2ZlcigKICAgIGJ5dGVjIDIxIC8vIDB4NmY3NTc0NjI2Zjc1NmU2NDVmNzE3NTY1NzU2NTY0NWY3NDcyNjE2ZTczNjY2NTcyNzM1ZgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MjMxLTIzOQogICAgLy8gIyBlbnF1ZXVlIHRyYW5zZmVyCiAgICAvLyBzZWxmLm91dGJvdW5kX3F1ZXVlZF90cmFuc2ZlcnNbbWVzc2FnZV9pZF0gPSBPdXRib3VuZFF1ZXVlZFRyYW5zZmVyKAogICAgLy8gICAgIEFSQzRVSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gICAgIHRyaW1tZWRfYW1vdW50LAogICAgLy8gICAgIHJlY2lwaWVudF9jaGFpbiwKICAgIC8vICAgICByZWNpcGllbnQuY29weSgpLAogICAgLy8gICAgIEFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgdHJhbnNjZWl2ZXJfaW5zdHJ1Y3Rpb25zLmNvcHkoKQogICAgLy8gKQogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTkzCiAgICAvLyByZXR1cm4gQnl0ZXMzMi5mcm9tX2J5dGVzKG9wLmtlY2NhazI1NihiIk9VVEJPVU5EIikpCiAgICBieXRlYyA0IC8vIDB4ZDQ2ZWMzYjhiZDU0NGZiZGQyYTFhYWIwZGRlN2YzMDc4YTY2Njg4ZjM4NTJlZDA1MGJkZDc5YWQ2YmFkNjM5YgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToxMzYKICAgIC8vIHJldHVybiBzZWxmLmdldF9jdXJyZW50X2NhcGFjaXR5KHNlbGYub3V0Ym91bmRfYnVja2V0X2lkKCkpCiAgICBjYWxsc3ViIGdldF9jdXJyZW50X2NhcGFjaXR5CiAgICBwb3AKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MjQ0CiAgICAvLyBBZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgdHhuIFNlbmRlcgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyNDMtMjQ4CiAgICAvLyBlbWl0KE91dGJvdW5kVHJhbnNmZXJSYXRlTGltaXRlZCgKICAgIC8vICAgICBBZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIG1lc3NhZ2VfaWQsCiAgICAvLyAgICAgY3VycmVudF9jYXBhY2l0eSwKICAgIC8vICAgICBBUkM0VUludDY0KHVudHJpbW1lZF9hbW91bnQpCiAgICAvLyApKQogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDAKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4YzEwNjVjMmYgLy8gbWV0aG9kICJPdXRib3VuZFRyYW5zZmVyUmF0ZUxpbWl0ZWQoYWRkcmVzcyxieXRlWzMyXSx1aW50MjU2LHVpbnQ2NCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyNDkKICAgIC8vIHJldHVybiBCb29sKFRydWUpCiAgICBieXRlYyA3IC8vIDB4ODAKICAgIGZyYW1lX2RpZyAtNQogICAgZnJhbWVfZGlnIC0zCiAgICBmcmFtZV9kaWcgLTEKICAgIHVuY292ZXIgNwogICAgdW5jb3ZlciA3CiAgICB1bmNvdmVyIDcKICAgIHVuY292ZXIgNwogICAgcmV0c3ViCgpfZW5xdWV1ZV9vcl9jb25zdW1lX291dGJvdW5kX3RyYW5zZmVyX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTkzCiAgICAvLyByZXR1cm4gQnl0ZXMzMi5mcm9tX2J5dGVzKG9wLmtlY2NhazI1NihiIk9VVEJPVU5EIikpCiAgICBieXRlYyA0IC8vIDB4ZDQ2ZWMzYjhiZDU0NGZiZGQyYTFhYWIwZGRlN2YzMDc4YTY2Njg4ZjM4NTJlZDA1MGJkZDc5YWQ2YmFkNjM5YgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyNTEtMjUyCiAgICAvLyAjIG90aGVyd2lzZSBjb25zdW1lIGFuZCBiYWNrZmlsbCBhbW91bnQKICAgIC8vIHNlbGYuX2NvbnN1bWVfYW1vdW50KHNlbGYub3V0Ym91bmRfYnVja2V0X2lkKCksIFVJbnQyNTYodW50cmltbWVkX2Ftb3VudCkpCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBjYWxsc3ViIF9jb25zdW1lX2Ftb3VudAogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE4OQogICAgLy8gcmV0dXJuIEJ5dGVzMzIuZnJvbV9ieXRlcyhvcC5rZWNjYWsyNTYoYiJJTkJPVU5EXyIgKyBjaGFpbl9pZC5ieXRlcykpCiAgICBieXRlYyA1IC8vIDB4NDk0ZTQyNGY1NTRlNDQ1ZgogICAgZnJhbWVfZGlnIC02CiAgICBjb25jYXQKICAgIGtlY2NhazI1NgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyNTMKICAgIC8vIHNlbGYuX2ZpbGxfYW1vdW50KHNlbGYuaW5ib3VuZF9idWNrZXRfaWQocmVjaXBpZW50X2NoYWluKSwgVUludDI1Nih1bnRyaW1tZWRfYW1vdW50KSkKICAgIHN3YXAKICAgIGNhbGxzdWIgX2ZpbGxfYW1vdW50CiAgICBwb3AKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MjI3CiAgICAvLyBhc3NlcnQgc2hvdWxkX3F1ZXVlIG9yIGhhc19jYXBhY2l0eSwgZXJyLk9VVEJPVU5EX1FVRVVFRF9UUkFOU0ZFUl9JTlNVRkZJQ0lFTlRfQ0FQQUNJVFkKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyNTQKICAgIC8vIHJldHVybiBCb29sKEZhbHNlKQogICAgZnJhbWVfZGlnIC01CiAgICBmcmFtZV9kaWcgLTMKICAgIGZyYW1lX2RpZyAtMQogICAgdW5jb3ZlciA3CiAgICB1bmNvdmVyIDcKICAgIHVuY292ZXIgNwogICAgdW5jb3ZlciA3CiAgICByZXRzdWIKCl9lbnF1ZXVlX29yX2NvbnN1bWVfb3V0Ym91bmRfdHJhbnNmZXJfYm9vbF9mYWxzZUAzOgogICAgaW50Y18wIC8vIDAKICAgIGIgX2VucXVldWVfb3JfY29uc3VtZV9vdXRib3VuZF90cmFuc2Zlcl9ib29sX21lcmdlQDQKCgovLyBudHRfY29udHJhY3RzLm50dF9tYW5hZ2VyLk50dFJhdGVMaW1pdGVyLk50dFJhdGVMaW1pdGVyLl9lbnF1ZXVlX29yX2NvbnN1bWVfaW5ib3VuZF90cmFuc2Zlcih1bnRyaW1tZWRfYW1vdW50OiB1aW50NjQsIHNvdXJjZV9jaGFpbjogYnl0ZXMsIHRyaW1tZWRfYW1vdW50OiBieXRlcywgcmVjaXBpZW50OiBieXRlcywgbWVzc2FnZV9kaWdlc3Q6IGJ5dGVzKSAtPiBieXRlcywgYnl0ZXM6Cl9lbnF1ZXVlX29yX2NvbnN1bWVfaW5ib3VuZF90cmFuc2ZlcjoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MjU2LTI2NAogICAgLy8gQHN1YnJvdXRpbmUoaW5saW5lPUZhbHNlKQogICAgLy8gZGVmIF9lbnF1ZXVlX29yX2NvbnN1bWVfaW5ib3VuZF90cmFuc2ZlcigKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHVudHJpbW1lZF9hbW91bnQ6IFVJbnQ2NCwKICAgIC8vICAgICBzb3VyY2VfY2hhaW46IFVJbnQxNiwKICAgIC8vICAgICB0cmltbWVkX2Ftb3VudDogVHJpbW1lZEFtb3VudCwKICAgIC8vICAgICByZWNpcGllbnQ6IEFkZHJlc3MsCiAgICAvLyAgICAgbWVzc2FnZV9kaWdlc3Q6IE1lc3NhZ2VEaWdlc3QsCiAgICAvLyApIC0+IEJvb2w6CiAgICBwcm90byA1IDIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MTg5CiAgICAvLyByZXR1cm4gQnl0ZXMzMi5mcm9tX2J5dGVzKG9wLmtlY2NhazI1NihiIklOQk9VTkRfIiArIGNoYWluX2lkLmJ5dGVzKSkKICAgIGJ5dGVjIDUgLy8gMHg0OTRlNDI0ZjU1NGU0NDVmCiAgICBmcmFtZV9kaWcgLTQKICAgIGNvbmNhdAogICAga2VjY2FrMjU2CiAgICBkdXAKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6Mjc4LTI3OQogICAgLy8gIyBjaGVjayByYXRlIGxpbWl0CiAgICAvLyBoYXNfY2FwYWNpdHkgPSBzZWxmLmhhc19jYXBhY2l0eShzZWxmLmluYm91bmRfYnVja2V0X2lkKHNvdXJjZV9jaGFpbiksIFVJbnQyNTYodW50cmltbWVkX2Ftb3VudCkpCiAgICBmcmFtZV9kaWcgLTUKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgMwogICAgaW50Y18yIC8vIDMyCiAgICBiemVybwogICAgYnwKICAgIGR1cAogICAgY292ZXIgMwogICAgY2FsbHN1YiBoYXNfY2FwYWNpdHkKICAgIHBvcAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyODEtMjgyCiAgICAvLyAjIGVucXVldWUgaWYgbmVlZGVkCiAgICAvLyBpZiBub3QgaGFzX2NhcGFjaXR5OgogICAgYnl0ZWNfMCAvLyAweDAwCiAgICA9PQogICAgYnogX2VucXVldWVfb3JfY29uc3VtZV9pbmJvdW5kX3RyYW5zZmVyX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyODUKICAgIC8vIEFSQzRVSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyODMtMjg5CiAgICAvLyAjIGVucXVldWUgdHJhbnNmZXIKICAgIC8vIHNlbGYuaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXJzW21lc3NhZ2VfZGlnZXN0XSA9IEluYm91bmRRdWV1ZWRUcmFuc2ZlcigKICAgIC8vICAgICBBUkM0VUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKSwKICAgIC8vICAgICB0cmltbWVkX2Ftb3VudCwKICAgIC8vICAgICBzb3VyY2VfY2hhaW4sCiAgICAvLyAgICAgcmVjaXBpZW50LAogICAgLy8gKQogICAgZnJhbWVfZGlnIC0zCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtNAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTIKICAgIGNvbmNhdAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyODMtMjg0CiAgICAvLyAjIGVucXVldWUgdHJhbnNmZXIKICAgIC8vIHNlbGYuaW5ib3VuZF9xdWV1ZWRfdHJhbnNmZXJzW21lc3NhZ2VfZGlnZXN0XSA9IEluYm91bmRRdWV1ZWRUcmFuc2ZlcigKICAgIGJ5dGVjIDIwIC8vIDB4Njk2ZTYyNmY3NTZlNjQ1ZjcxNzU2NTc1NjU2NDVmNzQ3MjYxNmU3MzY2NjU3MjczNWYKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjI4My0yODkKICAgIC8vICMgZW5xdWV1ZSB0cmFuc2ZlcgogICAgLy8gc2VsZi5pbmJvdW5kX3F1ZXVlZF90cmFuc2ZlcnNbbWVzc2FnZV9kaWdlc3RdID0gSW5ib3VuZFF1ZXVlZFRyYW5zZmVyKAogICAgLy8gICAgIEFSQzRVSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgLy8gICAgIHRyaW1tZWRfYW1vdW50LAogICAgLy8gICAgIHNvdXJjZV9jaGFpbiwKICAgIC8vICAgICByZWNpcGllbnQsCiAgICAvLyApCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE2NQogICAgLy8gcmV0dXJuIHNlbGYuZ2V0X2N1cnJlbnRfY2FwYWNpdHkoc2VsZi5pbmJvdW5kX2J1Y2tldF9pZChjaGFpbl9pZCkpCiAgICBjYWxsc3ViIGdldF9jdXJyZW50X2NhcGFjaXR5CiAgICBwb3AKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MjkzLTI5NwogICAgLy8gZW1pdChJbmJvdW5kVHJhbnNmZXJSYXRlTGltaXRlZCgKICAgIC8vICAgICByZWNpcGllbnQsCiAgICAvLyAgICAgbWVzc2FnZV9kaWdlc3QsCiAgICAvLyAgICAgY3VycmVudF9jYXBhY2l0eSwKICAgIC8vICAgICBBUkM0VUludDY0KHVudHJpbW1lZF9hbW91bnQpKQogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgMAogICAgY29uY2F0CiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjI5My0yOTgKICAgIC8vIGVtaXQoSW5ib3VuZFRyYW5zZmVyUmF0ZUxpbWl0ZWQoCiAgICAvLyAgICAgcmVjaXBpZW50LAogICAgLy8gICAgIG1lc3NhZ2VfZGlnZXN0LAogICAgLy8gICAgIGN1cnJlbnRfY2FwYWNpdHksCiAgICAvLyAgICAgQVJDNFVJbnQ2NCh1bnRyaW1tZWRfYW1vdW50KSkKICAgIC8vICkKICAgIHB1c2hieXRlcyAweGZhNDY5MzdiIC8vIG1ldGhvZCAiSW5ib3VuZFRyYW5zZmVyUmF0ZUxpbWl0ZWQoYWRkcmVzcyxieXRlWzMyXSx1aW50MjU2LHVpbnQ2NCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyOTkKICAgIC8vIHJldHVybiBCb29sKFRydWUpCiAgICBieXRlYyA3IC8vIDB4ODAKICAgIGZyYW1lX2RpZyAtMQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDMKICAgIHJldHN1YgoKX2VucXVldWVfb3JfY29uc3VtZV9pbmJvdW5kX3RyYW5zZmVyX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MzAxLTMwMgogICAgLy8gIyBvdGhlcndpc2UgY29uc3VtZSBhbmQgYmFja2ZpbGwgYW1vdW50CiAgICAvLyBzZWxmLl9jb25zdW1lX2Ftb3VudChzZWxmLmluYm91bmRfYnVja2V0X2lkKHNvdXJjZV9jaGFpbiksIFVJbnQyNTYodW50cmltbWVkX2Ftb3VudCkpCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBjYWxsc3ViIF9jb25zdW1lX2Ftb3VudAogICAgcG9wCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjE5MwogICAgLy8gcmV0dXJuIEJ5dGVzMzIuZnJvbV9ieXRlcyhvcC5rZWNjYWsyNTYoYiJPVVRCT1VORCIpKQogICAgYnl0ZWMgNCAvLyAweGQ0NmVjM2I4YmQ1NDRmYmRkMmExYWFiMGRkZTdmMzA3OGE2NjY4OGYzODUyZWQwNTBiZGQ3OWFkNmJhZDYzOWIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MzAzCiAgICAvLyBzZWxmLl9maWxsX2Ftb3VudChzZWxmLm91dGJvdW5kX2J1Y2tldF9pZCgpLCBVSW50MjU2KHVudHJpbW1lZF9hbW91bnQpKQogICAgc3dhcAogICAgY2FsbHN1YiBfZmlsbF9hbW91bnQKICAgIHBvcAogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weToyODEtMjgyCiAgICAvLyAjIGVucXVldWUgaWYgbmVlZGVkCiAgICAvLyBpZiBub3QgaGFzX2NhcGFjaXR5OgogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjMwNAogICAgLy8gcmV0dXJuIEJvb2woRmFsc2UpCiAgICBmcmFtZV9kaWcgLTEKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAzCiAgICByZXRzdWIKCgovLyBudHRfY29udHJhY3RzLm50dF9tYW5hZ2VyLk50dFJhdGVMaW1pdGVyLk50dFJhdGVMaW1pdGVyLl9kZWxldGVfb3V0Ym91bmRfdHJhbnNmZXIobWVzc2FnZV9pZDogYnl0ZXMpIC0+IGJ5dGVzOgpfZGVsZXRlX291dGJvdW5kX3RyYW5zZmVyOgogICAgLy8gbnR0X2NvbnRyYWN0cy9udHRfbWFuYWdlci9OdHRSYXRlTGltaXRlci5weTozMDYtMzA3CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9kZWxldGVfb3V0Ym91bmRfdHJhbnNmZXIoc2VsZiwgbWVzc2FnZV9pZDogTWVzc2FnZUlkKSAtPiBOb25lOgogICAgcHJvdG8gMSAxCiAgICAvLyBudHRfY29udHJhY3RzL250dF9tYW5hZ2VyL050dFJhdGVMaW1pdGVyLnB5OjMzMAogICAgLy8gYXNzZXJ0IG1lc3NhZ2VfaWQgaW4gc2VsZi5vdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXJzLCBlcnIuT1VUQk9VTkRfUVVFVUVEX1RSQU5TRkVSX1VOS05PV04KICAgIGJ5dGVjIDIxIC8vIDB4NmY3NTc0NjI2Zjc1NmU2NDVmNzE3NTY1NzU2NTY0NWY3NDcyNjE2ZTczNjY2NTcyNzM1ZgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gVW5rbm93biBvdXRib3VuZCBxdWV1ZWQgdHJhbnNmZXIKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MzE0CiAgICAvLyBkZWwgc2VsZi5vdXRib3VuZF9xdWV1ZWRfdHJhbnNmZXJzW21lc3NhZ2VfaWRdCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIG50dF9jb250cmFjdHMvbnR0X21hbmFnZXIvTnR0UmF0ZUxpbWl0ZXIucHk6MzE1CiAgICAvLyBlbWl0KE91dGJvdW5kVHJhbnNmZXJEZWxldGVkKG1lc3NhZ2VfaWQpKQogICAgcHVzaGJ5dGVzIDB4ZjEwMTE2NzUgLy8gbWV0aG9kICJPdXRib3VuZFRyYW5zZmVyRGVsZXRlZChieXRlWzMyXSkiCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgbG9nCiAgICBmcmFtZV9kaWcgLTEKICAgIHJldHN1YgoKCi8vIGZvbGtzX2NvbnRyYWN0cy5saWJyYXJ5LlJhdGVMaW1pdGVyLlJhdGVMaW1pdGVyLmdldF9jdXJyZW50X2NhcGFjaXR5KGJ1Y2tldF9pZDogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlczoKZ2V0X2N1cnJlbnRfY2FwYWNpdHk6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6NTQtNTUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfY3VycmVudF9jYXBhY2l0eShzZWxmLCBidWNrZXRfaWQ6IEJ5dGVzMzIpIC0+IFVJbnQyNTY6CiAgICBwcm90byAxIDIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weTo2OS03MAogICAgLy8gIyBmYWlscyBpZiBidWNrZXQgaXMgdW5rbm93bgogICAgLy8gc2VsZi5fdXBkYXRlX2NhcGFjaXR5KGJ1Y2tldF9pZCkKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfdXBkYXRlX2NhcGFjaXR5CiAgICBmcmFtZV9idXJ5IC0xCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6NzItNzMKICAgIC8vICMgcmV0dXJuIGNhcGFjaXR5IG5vdyB0aGF0J3MgdXBkYXRlZCB0byBjdXJyZW50IHRpbWUKICAgIC8vIHJldHVybiBzZWxmLnJhdGVfbGltaXRfYnVja2V0c1tidWNrZXRfaWRdLmN1cnJlbnRfY2FwYWNpdHkKICAgIGJ5dGVjXzMgLy8gMHg3MjYxNzQ2NTVmNmM2OTZkNjk3NDVmNjI3NTYzNmI2NTc0NzM1ZgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJhdGVfbGltaXRfYnVja2V0cyBlbnRyeSBleGlzdHMKICAgIGV4dHJhY3QgMzIgMzIKICAgIGZyYW1lX2RpZyAtMQogICAgcmV0c3ViCgoKLy8gZm9sa3NfY29udHJhY3RzLmxpYnJhcnkuUmF0ZUxpbWl0ZXIuUmF0ZUxpbWl0ZXIuaGFzX2NhcGFjaXR5KGJ1Y2tldF9pZDogYnl0ZXMsIGFtb3VudDogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlczoKaGFzX2NhcGFjaXR5OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5Ojc1LTc2CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgaGFzX2NhcGFjaXR5KHNlbGYsIGJ1Y2tldF9pZDogQnl0ZXMzMiwgYW1vdW50OiBVSW50MjU2KSAtPiBCb29sOgogICAgcHJvdG8gMiAyCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6ODgtODkKICAgIC8vICMgZmFpbHMgaWYgYnVja2V0IGlzIHVua25vd24KICAgIC8vIHNlbGYuX3VwZGF0ZV9jYXBhY2l0eShidWNrZXRfaWQpCiAgICBmcmFtZV9kaWcgLTIKICAgIGNhbGxzdWIgX3VwZGF0ZV9jYXBhY2l0eQogICAgZHVwCiAgICBmcmFtZV9idXJ5IC0yCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6OTEtOTIKICAgIC8vICMgaWdub3JlIGlmIGR1cmF0aW9uIGlzIHplcm8KICAgIC8vIHJhdGVfbGltaXRfYnVja2V0ID0gc2VsZi5fZ2V0X2J1Y2tldChidWNrZXRfaWQpCiAgICBjYWxsc3ViIF9nZXRfYnVja2V0CiAgICBmcmFtZV9idXJ5IC0yCiAgICBkdXAKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weTo5MwogICAgLy8gaWYgbm90IHJhdGVfbGltaXRfYnVja2V0LmR1cmF0aW9uLmFzX3VpbnQ2NCgpOgogICAgcHVzaGludCA2NCAvLyA2NAogICAgZXh0cmFjdF91aW50NjQKICAgIGJueiBoYXNfY2FwYWNpdHlfYWZ0ZXJfaWZfZWxzZUA2CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6OTQKICAgIC8vIHJldHVybiBCb29sKFRydWUpCiAgICBieXRlYyA3IC8vIDB4ODAKICAgIGZyYW1lX2RpZyAtMgogICAgdW5jb3ZlciAyCiAgICByZXRzdWIKCmhhc19jYXBhY2l0eV9hZnRlcl9pZl9lbHNlQDY6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6OTYtOTcKICAgIC8vICMgZW5zdXJlIHRoZXJlIGlzIGVub3VnaCBjYXBhY2l0eQogICAgLy8gcmV0dXJuIEJvb2woYW1vdW50IDw9IHJhdGVfbGltaXRfYnVja2V0LmN1cnJlbnRfY2FwYWNpdHkpCiAgICBmcmFtZV9kaWcgMAogICAgZXh0cmFjdCAzMiAzMgogICAgZnJhbWVfZGlnIC0xCiAgICBiPj0KICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBmcmFtZV9kaWcgLTIKICAgIHVuY292ZXIgMgogICAgcmV0c3ViCgoKLy8gZm9sa3NfY29udHJhY3RzLmxpYnJhcnkuUmF0ZUxpbWl0ZXIuUmF0ZUxpbWl0ZXIuZ2V0X3JhdGVfZHVyYXRpb24oYnVja2V0X2lkOiBieXRlcykgLT4gdWludDY0LCBieXRlczoKZ2V0X3JhdGVfZHVyYXRpb246CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MTEyLTExMwogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgLy8gZGVmIGdldF9yYXRlX2R1cmF0aW9uKHNlbGYsIGJ1Y2tldF9pZDogQnl0ZXMzMikgLT4gVUludDY0OgogICAgcHJvdG8gMSAyCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6Mjk3CiAgICAvLyBhc3NlcnQgYnVja2V0X2lkIGluIHNlbGYucmF0ZV9saW1pdF9idWNrZXRzLCAiVW5rbm93biBidWNrZXQiCiAgICBieXRlY18zIC8vIDB4NzI2MTc0NjU1ZjZjNjk2ZDY5NzQ1ZjYyNzU2MzZiNjU3NDczNWYKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIFVua25vd24gYnVja2V0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MTIzCiAgICAvLyByZXR1cm4gc2VsZi5yYXRlX2xpbWl0X2J1Y2tldHNbYnVja2V0X2lkXS5kdXJhdGlvbi5hc191aW50NjQoKQogICAgYm94X2dldAogICAgcG9wCiAgICBwdXNoaW50IDY0IC8vIDY0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfZGlnIC0xCiAgICByZXRzdWIKCgovLyBmb2xrc19jb250cmFjdHMubGlicmFyeS5SYXRlTGltaXRlci5SYXRlTGltaXRlci5fYWRkX2J1Y2tldChidWNrZXRfaWQ6IGJ5dGVzLCBsaW1pdDogYnl0ZXMsIGR1cmF0aW9uOiB1aW50NjQpIC0+IGJ5dGVzOgpfYWRkX2J1Y2tldDoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToxMjUtMTI2CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9hZGRfYnVja2V0KHNlbGYsIGJ1Y2tldF9pZDogQnl0ZXMzMiwgbGltaXQ6IFVJbnQyNTYsIGR1cmF0aW9uOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAzIDEKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToxMzkKICAgIC8vIGFzc2VydCBidWNrZXRfaWQgbm90IGluIHNlbGYucmF0ZV9saW1pdF9idWNrZXRzLCAiQnVja2V0IGFscmVhZHkgZXhpc3RzIgogICAgYnl0ZWNfMyAvLyAweDcyNjE3NDY1NWY2YzY5NmQ2OTc0NWY2Mjc1NjM2YjY1NzQ3MzVmCiAgICBmcmFtZV9kaWcgLTMKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgICEKICAgIGFzc2VydCAvLyBCdWNrZXQgYWxyZWFkeSBleGlzdHMKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToxNDMKICAgIC8vIGR1cmF0aW9uPUFSQzRVSW50NjQoZHVyYXRpb24pLAogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MTQ0CiAgICAvLyBsYXN0X3VwZGF0ZWQ9QVJDNFVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToxNDAtMTQ1CiAgICAvLyBzZWxmLnJhdGVfbGltaXRfYnVja2V0c1tidWNrZXRfaWRdID0gUmF0ZUxpbWl0QnVja2V0KAogICAgLy8gICAgIGxpbWl0PWxpbWl0LAogICAgLy8gICAgIGN1cnJlbnRfY2FwYWNpdHk9bGltaXQsCiAgICAvLyAgICAgZHVyYXRpb249QVJDNFVJbnQ2NChkdXJhdGlvbiksCiAgICAvLyAgICAgbGFzdF91cGRhdGVkPUFSQzRVSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApCiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTIKICAgIGR1cAogICAgY29uY2F0CiAgICBkaWcgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjE0NgogICAgLy8gZW1pdChCdWNrZXRBZGRlZChidWNrZXRfaWQsIGxpbWl0LCBBUkM0VUludDY0KGR1cmF0aW9uKSkpCiAgICBmcmFtZV9kaWcgLTMKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDM5YmNiYzllIC8vIG1ldGhvZCAiQnVja2V0QWRkZWQoYnl0ZVszMl0sdWludDI1Nix1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGZyYW1lX2RpZyAtMwogICAgcmV0c3ViCgoKLy8gZm9sa3NfY29udHJhY3RzLmxpYnJhcnkuUmF0ZUxpbWl0ZXIuUmF0ZUxpbWl0ZXIuX3VwZGF0ZV9yYXRlX2xpbWl0KGJ1Y2tldF9pZDogYnl0ZXMsIG5ld19saW1pdDogYnl0ZXMpIC0+IGJ5dGVzOgpfdXBkYXRlX3JhdGVfbGltaXQ6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MTY1LTE2NgogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBfdXBkYXRlX3JhdGVfbGltaXQoc2VsZiwgYnVja2V0X2lkOiBCeXRlczMyLCBuZXdfbGltaXQ6IFVJbnQyNTYpIC0+IE5vbmU6CiAgICBwcm90byAyIDEKICAgIGludGNfMCAvLyAwCiAgICBkdXAKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToxNzYtMTc3CiAgICAvLyAjIGZhaWxzIGlmIGJ1Y2tldCBpcyB1bmtub3duCiAgICAvLyBzZWxmLl91cGRhdGVfY2FwYWNpdHkoYnVja2V0X2lkKQogICAgZnJhbWVfZGlnIC0yCiAgICBjYWxsc3ViIF91cGRhdGVfY2FwYWNpdHkKICAgIGR1cAogICAgZnJhbWVfYnVyeSAtMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjE3OS0xODAKICAgIC8vICMgaW5jcmVhc2Ugb3IgZGVjcmVhc2UgY2FwYWNpdHkgYnkgY2hhbmdlIGluIGxpbWl0CiAgICAvLyByYXRlX2xpbWl0X2J1Y2tldCA9IHNlbGYuX2dldF9idWNrZXQoYnVja2V0X2lkKQogICAgY2FsbHN1YiBfZ2V0X2J1Y2tldAogICAgZnJhbWVfYnVyeSAtMgogICAgZHVwCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MTgxCiAgICAvLyBpZiBuZXdfbGltaXQuYXNfYmlndWludCgpIDwgcmF0ZV9saW1pdF9idWNrZXQubGltaXQuYXNfYmlndWludCgpOgogICAgZXh0cmFjdCAwIDMyCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2RpZyAtMQogICAgYj4KICAgIGJ6IF91cGRhdGVfcmF0ZV9saW1pdF9lbHNlX2JvZHlAOQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjE4Mi0xODMKICAgIC8vICMgaWYgcmVkdWNpbmcgbGltaXQgdGhlbiBkZWNyZWFzZSBjYXBhY2l0eSBieSBkaWZmZXJlbmNlCiAgICAvLyBkaWZmID0gcmF0ZV9saW1pdF9idWNrZXQubGltaXQuYXNfYmlndWludCgpIC0gbmV3X2xpbWl0LmFzX2JpZ3VpbnQoKQogICAgc3dhcAogICAgZnJhbWVfZGlnIC0xCiAgICBiLQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToxODUKICAgIC8vIGlmIHJhdGVfbGltaXRfYnVja2V0LmN1cnJlbnRfY2FwYWNpdHkuYXNfYmlndWludCgpID4gZGlmZiBlbHNlIEJpZ1VJbnQoMCkKICAgIHN3YXAKICAgIGV4dHJhY3QgMzIgMzIKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICBiPAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjE4NC0xODUKICAgIC8vIG5ld19jYXBhY2l0eSA9IHJhdGVfbGltaXRfYnVja2V0LmN1cnJlbnRfY2FwYWNpdHkuYXNfYmlndWludCgpIC0gZGlmZiBcCiAgICAvLyAgICAgaWYgcmF0ZV9saW1pdF9idWNrZXQuY3VycmVudF9jYXBhY2l0eS5hc19iaWd1aW50KCkgPiBkaWZmIGVsc2UgQmlnVUludCgwKQogICAgYnogX3VwZGF0ZV9yYXRlX2xpbWl0X3Rlcm5hcnlfZmFsc2VANwogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjE4NAogICAgLy8gbmV3X2NhcGFjaXR5ID0gcmF0ZV9saW1pdF9idWNrZXQuY3VycmVudF9jYXBhY2l0eS5hc19iaWd1aW50KCkgLSBkaWZmIFwKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgYi0KCl91cGRhdGVfcmF0ZV9saW1pdF9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjE5MAogICAgLy8gc2VsZi5yYXRlX2xpbWl0X2J1Y2tldHNbYnVja2V0X2lkXS5jdXJyZW50X2NhcGFjaXR5ID0gQVJDNFVJbnQyNTYobmV3X2NhcGFjaXR5KQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgaW50Y18yIC8vIDMyCiAgICBiemVybwogICAgYnwKICAgIGJ5dGVjXzMgLy8gMHg3MjYxNzQ2NTVmNmM2OTZkNjk3NDVmNjI3NTYzNmI2NTc0NzM1ZgogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIGR1cAogICAgaW50Y18yIC8vIDMyCiAgICB1bmNvdmVyIDMKICAgIGJveF9yZXBsYWNlCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MTkyLTE5MwogICAgLy8gIyB1cGRhdGUgbGltaXQKICAgIC8vIHNlbGYucmF0ZV9saW1pdF9idWNrZXRzW2J1Y2tldF9pZF0ubGltaXQgPSBuZXdfbGltaXQKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9kaWcgLTEKICAgIGJveF9yZXBsYWNlCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MTk0CiAgICAvLyBlbWl0KEJ1Y2tldFJhdGVMaW1pdFVwZGF0ZWQoYnVja2V0X2lkLCBuZXdfbGltaXQpKQogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4YTI2Njc1MjEgLy8gbWV0aG9kICJCdWNrZXRSYXRlTGltaXRVcGRhdGVkKGJ5dGVbMzJdLHVpbnQyNTYpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCl91cGRhdGVfcmF0ZV9saW1pdF90ZXJuYXJ5X2ZhbHNlQDc6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MTg1CiAgICAvLyBpZiByYXRlX2xpbWl0X2J1Y2tldC5jdXJyZW50X2NhcGFjaXR5LmFzX2JpZ3VpbnQoKSA+IGRpZmYgZWxzZSBCaWdVSW50KDApCiAgICBwdXNoYnl0ZXMgMHgKICAgIGIgX3VwZGF0ZV9yYXRlX2xpbWl0X2FmdGVyX2lmX2Vsc2VAMTAKCl91cGRhdGVfcmF0ZV9saW1pdF9lbHNlX2JvZHlAOToKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToxODctMTg4CiAgICAvLyAjIGlmIGluY3JlYXNpbmcgbGltaXQgdGhlbiBpbmNyZWFzZSBjYXBhY2l0eSBieSBkaWZmZXJlbmNlCiAgICAvLyBkaWZmID0gbmV3X2xpbWl0LmFzX2JpZ3VpbnQoKSAtIHJhdGVfbGltaXRfYnVja2V0LmxpbWl0LmFzX2JpZ3VpbnQoKQogICAgZnJhbWVfZGlnIC0xCiAgICB1bmNvdmVyIDIKICAgIGItCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MTg5CiAgICAvLyBuZXdfY2FwYWNpdHkgPSByYXRlX2xpbWl0X2J1Y2tldC5jdXJyZW50X2NhcGFjaXR5LmFzX2JpZ3VpbnQoKSArIGRpZmYKICAgIHN3YXAKICAgIGV4dHJhY3QgMzIgMzIKICAgIGIrCiAgICBiIF91cGRhdGVfcmF0ZV9saW1pdF9hZnRlcl9pZl9lbHNlQDEwCgoKLy8gZm9sa3NfY29udHJhY3RzLmxpYnJhcnkuUmF0ZUxpbWl0ZXIuUmF0ZUxpbWl0ZXIuX3VwZGF0ZV9yYXRlX2R1cmF0aW9uKGJ1Y2tldF9pZDogYnl0ZXMsIG5ld19kdXJhdGlvbjogdWludDY0KSAtPiBieXRlczoKX3VwZGF0ZV9yYXRlX2R1cmF0aW9uOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjE5Ni0xOTcKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgX3VwZGF0ZV9yYXRlX2R1cmF0aW9uKHNlbGYsIGJ1Y2tldF9pZDogQnl0ZXMzMiwgbmV3X2R1cmF0aW9uOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAyIDEKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyMDctMjA4CiAgICAvLyAjIGZhaWxzIGlmIGJ1Y2tldCBpcyB1bmtub3duCiAgICAvLyBzZWxmLl91cGRhdGVfY2FwYWNpdHkoYnVja2V0X2lkKQogICAgZnJhbWVfZGlnIC0yCiAgICBjYWxsc3ViIF91cGRhdGVfY2FwYWNpdHkKICAgIGR1cAogICAgZnJhbWVfYnVyeSAtMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjIxMC0yMTEKICAgIC8vICMgaGFuZGxlIHNwZWNpYWwgY2FzZSB3aGVuIHVwZGF0aW5nIGZyb20gemVybyB0byBub24temVybyBkdXJhdGlvbiBidWNrZXQKICAgIC8vIHJhdGVfbGltaXRfYnVja2V0ID0gc2VsZi5fZ2V0X2J1Y2tldChidWNrZXRfaWQpCiAgICBjYWxsc3ViIF9nZXRfYnVja2V0CiAgICBmcmFtZV9idXJ5IC0yCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MjEyCiAgICAvLyBpZiBuZXdfZHVyYXRpb24gYW5kIG5vdCByYXRlX2xpbWl0X2J1Y2tldC5kdXJhdGlvbi5hc191aW50NjQoKToKICAgIGZyYW1lX2RpZyAtMQogICAgYnogX3VwZGF0ZV9yYXRlX2R1cmF0aW9uX2FmdGVyX2lmX2Vsc2VANwogICAgZnJhbWVfZGlnIDAKICAgIHB1c2hpbnQgNjQgLy8gNjQKICAgIGV4dHJhY3RfdWludDY0CiAgICBibnogX3VwZGF0ZV9yYXRlX2R1cmF0aW9uX2FmdGVyX2lmX2Vsc2VANwogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjIxMy0yMTQKICAgIC8vICMgcmVzZXQgdGhlIGNhcGFjaXR5IHRvIGVxdWFsIHRoZSBsaW1pdAogICAgLy8gc2VsZi5yYXRlX2xpbWl0X2J1Y2tldHNbYnVja2V0X2lkXS5jdXJyZW50X2NhcGFjaXR5ID0gcmF0ZV9saW1pdF9idWNrZXQubGltaXQKICAgIGZyYW1lX2RpZyAwCiAgICBleHRyYWN0IDAgMzIKICAgIGJ5dGVjXzMgLy8gMHg3MjYxNzQ2NTVmNmM2OTZkNjk3NDVmNjI3NTYzNmI2NTc0NzM1ZgogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIGR1cAogICAgaW50Y18yIC8vIDMyCiAgICB1bmNvdmVyIDMKICAgIGJveF9yZXBsYWNlCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MjE1CiAgICAvLyBzZWxmLnJhdGVfbGltaXRfYnVja2V0c1tidWNrZXRfaWRdLmxhc3RfdXBkYXRlZCA9IEFSQzRVSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICBwdXNoaW50IDcyIC8vIDcyCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQoKX3VwZGF0ZV9yYXRlX2R1cmF0aW9uX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyMTctMjE4CiAgICAvLyAjIHVwZGF0ZSBkdXJhdGlvbgogICAgLy8gc2VsZi5yYXRlX2xpbWl0X2J1Y2tldHNbYnVja2V0X2lkXS5kdXJhdGlvbiA9IEFSQzRVSW50NjQobmV3X2R1cmF0aW9uKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBieXRlY18zIC8vIDB4NzI2MTc0NjU1ZjZjNjk2ZDY5NzQ1ZjYyNzU2MzZiNjU3NDczNWYKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICBwdXNoaW50IDY0IC8vIDY0CiAgICBkaWcgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyMTkKICAgIC8vIGVtaXQoQnVja2V0UmF0ZUR1cmF0aW9uVXBkYXRlZChidWNrZXRfaWQsIEFSQzRVSW50NjQobmV3X2R1cmF0aW9uKSkpCiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4NTkzNzIyMTQgLy8gbWV0aG9kICJCdWNrZXRSYXRlRHVyYXRpb25VcGRhdGVkKGJ5dGVbMzJdLHVpbnQ2NCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICByZXRzdWIKCgovLyBmb2xrc19jb250cmFjdHMubGlicmFyeS5SYXRlTGltaXRlci5SYXRlTGltaXRlci5fY29uc3VtZV9hbW91bnQoYnVja2V0X2lkOiBieXRlcywgYW1vdW50OiBieXRlcykgLT4gYnl0ZXM6Cl9jb25zdW1lX2Ftb3VudDoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyMjEtMjIyCiAgICAvLyBAc3Vicm91dGluZShpbmxpbmU9RmFsc2UpCiAgICAvLyBkZWYgX2NvbnN1bWVfYW1vdW50KHNlbGYsIGJ1Y2tldF9pZDogQnl0ZXMzMiwgYW1vdW50OiBVSW50MjU2KSAtPiBOb25lOgogICAgcHJvdG8gMiAxCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MjMzLTIzNAogICAgLy8gIyBmYWlscyBpZiBidWNrZXQgaXMgdW5rbm93bgogICAgLy8gc2VsZi5fdXBkYXRlX2NhcGFjaXR5KGJ1Y2tldF9pZCkKICAgIGZyYW1lX2RpZyAtMgogICAgY2FsbHN1YiBfdXBkYXRlX2NhcGFjaXR5CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgLTIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyMzYtMjM3CiAgICAvLyAjIGlnbm9yZSBpZiBkdXJhdGlvbiBpcyB6ZXJvCiAgICAvLyByYXRlX2xpbWl0X2J1Y2tldCA9IHNlbGYuX2dldF9idWNrZXQoYnVja2V0X2lkKQogICAgY2FsbHN1YiBfZ2V0X2J1Y2tldAogICAgZnJhbWVfYnVyeSAtMgogICAgZHVwCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MjM4CiAgICAvLyBpZiByYXRlX2xpbWl0X2J1Y2tldC5kdXJhdGlvbi5hc191aW50NjQoKToKICAgIHB1c2hpbnQgNjQgLy8gNjQKICAgIGV4dHJhY3RfdWludDY0CiAgICBieiBfY29uc3VtZV9hbW91bnRfYWZ0ZXJfaWZfZWxzZUA2CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MjM5LTI0MAogICAgLy8gIyBlbnN1cmUgdGhlcmUgaXMgZW5vdWdoIGNhcGFjaXR5CiAgICAvLyBhc3NlcnQgYW1vdW50IDw9IHJhdGVfbGltaXRfYnVja2V0LmN1cnJlbnRfY2FwYWNpdHksICJJbnN1ZmZpY2llbnQgY2FwYWNpdHkgdG8gY29uc3VtZSIKICAgIGZyYW1lX2RpZyAwCiAgICBleHRyYWN0IDMyIDMyCiAgICBmcmFtZV9kaWcgLTEKICAgIGRpZyAxCiAgICBiPD0KICAgIGFzc2VydCAvLyBJbnN1ZmZpY2llbnQgY2FwYWNpdHkgdG8gY29uc3VtZQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI0Mi0yNDMKICAgIC8vICMgY29uc3VtZSBhbW91bnQKICAgIC8vIG5ld19jYXBhY2l0eSA9IHJhdGVfbGltaXRfYnVja2V0LmN1cnJlbnRfY2FwYWNpdHkuYXNfYmlndWludCgpIC0gYW1vdW50LmFzX2JpZ3VpbnQoKQogICAgZnJhbWVfZGlnIC0xCiAgICBiLQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI0NAogICAgLy8gc2VsZi5yYXRlX2xpbWl0X2J1Y2tldHNbYnVja2V0X2lkXS5jdXJyZW50X2NhcGFjaXR5ID0gQVJDNFVJbnQyNTYobmV3X2NhcGFjaXR5KQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgaW50Y18yIC8vIDMyCiAgICBiemVybwogICAgYnwKICAgIGJ5dGVjXzMgLy8gMHg3MjYxNzQ2NTVmNmM2OTZkNjk3NDVmNjI3NTYzNmI2NTc0NzM1ZgogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIGludGNfMiAvLyAzMgogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQoKX2NvbnN1bWVfYW1vdW50X2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyNDYKICAgIC8vIGVtaXQoQnVja2V0Q29uc3VtZWQoYnVja2V0X2lkLCBhbW91bnQpKQogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4N2QxNWU1MzkgLy8gbWV0aG9kICJCdWNrZXRDb25zdW1lZChieXRlWzMyXSx1aW50MjU2KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIGZvbGtzX2NvbnRyYWN0cy5saWJyYXJ5LlJhdGVMaW1pdGVyLlJhdGVMaW1pdGVyLl9maWxsX2Ftb3VudChidWNrZXRfaWQ6IGJ5dGVzLCBhbW91bnQ6IGJ5dGVzKSAtPiBieXRlczoKX2ZpbGxfYW1vdW50OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI0OC0yNDkKICAgIC8vIEBzdWJyb3V0aW5lKGlubGluZT1GYWxzZSkKICAgIC8vIGRlZiBfZmlsbF9hbW91bnQoc2VsZiwgYnVja2V0X2lkOiBCeXRlczMyLCBhbW91bnQ6IFVJbnQyNTYpIC0+IE5vbmU6CiAgICBwcm90byAyIDEKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyNTktMjYwCiAgICAvLyAjIGZhaWxzIGlmIGJ1Y2tldCBpcyB1bmtub3duCiAgICAvLyBzZWxmLl91cGRhdGVfY2FwYWNpdHkoYnVja2V0X2lkKQogICAgZnJhbWVfZGlnIC0yCiAgICBjYWxsc3ViIF91cGRhdGVfY2FwYWNpdHkKICAgIGR1cAogICAgZnJhbWVfYnVyeSAtMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI2Mi0yNjMKICAgIC8vICMgaWdub3JlIGlmIGR1cmF0aW9uIGlzIHplcm8KICAgIC8vIHJhdGVfbGltaXRfYnVja2V0ID0gc2VsZi5fZ2V0X2J1Y2tldChidWNrZXRfaWQpCiAgICBjYWxsc3ViIF9nZXRfYnVja2V0CiAgICBmcmFtZV9idXJ5IC0yCiAgICBkdXAKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyNjQKICAgIC8vIGlmIHJhdGVfbGltaXRfYnVja2V0LmR1cmF0aW9uLmFzX3VpbnQ2NCgpOgogICAgcHVzaGludCA2NCAvLyA2NAogICAgZXh0cmFjdF91aW50NjQKICAgIGJ6IF9maWxsX2Ftb3VudF9lbHNlX2JvZHlAOQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI2NS0yNjYKICAgIC8vICMgZmlsbCBhbW91bnQgd2l0aG91dCBleGNlZWRpbmcgbGltaXQKICAgIC8vIG1heF9maWxsX2Ftb3VudCA9IHJhdGVfbGltaXRfYnVja2V0LmxpbWl0LmFzX2JpZ3VpbnQoKSAtIHJhdGVfbGltaXRfYnVja2V0LmN1cnJlbnRfY2FwYWNpdHkuYXNfYmlndWludCgpCiAgICBmcmFtZV9kaWcgMwogICAgZHVwCiAgICBleHRyYWN0IDAgMzIKICAgIHN3YXAKICAgIGV4dHJhY3QgMzIgMzIKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICBiLQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyNjcKICAgIC8vIGZpbGxfYW1vdW50ID0gYW1vdW50LmFzX2JpZ3VpbnQoKSBpZiBhbW91bnQuYXNfYmlndWludCgpIDwgbWF4X2ZpbGxfYW1vdW50IGVsc2UgbWF4X2ZpbGxfYW1vdW50CiAgICBmcmFtZV9kaWcgLTEKICAgIGI+CiAgICBieiBfZmlsbF9hbW91bnRfdGVybmFyeV9mYWxzZUA3CiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2J1cnkgMQoKX2ZpbGxfYW1vdW50X3Rlcm5hcnlfbWVyZ2VAODoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyNjgKICAgIC8vIG5ld19jYXBhY2l0eSA9IHJhdGVfbGltaXRfYnVja2V0LmN1cnJlbnRfY2FwYWNpdHkuYXNfYmlndWludCgpICsgZmlsbF9hbW91bnQKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgYisKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyNjkKICAgIC8vIHNlbGYucmF0ZV9saW1pdF9idWNrZXRzW2J1Y2tldF9pZF0uY3VycmVudF9jYXBhY2l0eSA9IEFSQzRVSW50MjU2KG5ld19jYXBhY2l0eSkKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGludGNfMiAvLyAzMgogICAgYnplcm8KICAgIGJ8CiAgICBieXRlY18zIC8vIDB4NzI2MTc0NjU1ZjZjNjk2ZDY5NzQ1ZjYyNzU2MzZiNjU3NDczNWYKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICBpbnRjXzIgLy8gMzIKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKCl9maWxsX2Ftb3VudF9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI3MwogICAgLy8gZW1pdChCdWNrZXRGaWxsZWQoYnVja2V0X2lkLCBhbW91bnQsIEFSQzRVSW50MjU2KGZpbGxfYW1vdW50KSkpCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgaW50Y18yIC8vIDMyCiAgICBiemVybwogICAgYnwKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4ZmIzNzhmYjMgLy8gbWV0aG9kICJCdWNrZXRGaWxsZWQoYnl0ZVszMl0sdWludDI1Nix1aW50MjU2KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpfZmlsbF9hbW91bnRfdGVybmFyeV9mYWxzZUA3OgogICAgZnJhbWVfZGlnIDIKICAgIGZyYW1lX2J1cnkgMQogICAgYiBfZmlsbF9hbW91bnRfdGVybmFyeV9tZXJnZUA4CgpfZmlsbF9hbW91bnRfZWxzZV9ib2R5QDk6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MjcxCiAgICAvLyBmaWxsX2Ftb3VudCA9IEJpZ1VJbnQoMCkKICAgIHB1c2hieXRlcyAweAogICAgZnJhbWVfYnVyeSAxCiAgICBiIF9maWxsX2Ftb3VudF9hZnRlcl9pZl9lbHNlQDEwCgoKLy8gZm9sa3NfY29udHJhY3RzLmxpYnJhcnkuUmF0ZUxpbWl0ZXIuUmF0ZUxpbWl0ZXIuX3VwZGF0ZV9jYXBhY2l0eShidWNrZXRfaWQ6IGJ5dGVzKSAtPiBieXRlczoKX3VwZGF0ZV9jYXBhY2l0eToKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyNzUtMjc2CiAgICAvLyBAc3Vicm91dGluZShpbmxpbmU9RmFsc2UpCiAgICAvLyBkZWYgX3VwZGF0ZV9jYXBhY2l0eShzZWxmLCBidWNrZXRfaWQ6IEJ5dGVzMzIpIC0+IE5vbmU6CiAgICBwcm90byAxIDEKICAgIGludGNfMCAvLyAwCiAgICBkdXAKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyNzctMjc4CiAgICAvLyAjIGZhaWxzIGlmIGJ1Y2tldCBpcyB1bmtub3duCiAgICAvLyByYXRlX2xpbWl0X2J1Y2tldCA9IHNlbGYuX2dldF9idWNrZXQoYnVja2V0X2lkKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9nZXRfYnVja2V0CiAgICBmcmFtZV9idXJ5IC0xCiAgICBkdXAKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyODAtMjgxCiAgICAvLyAjIGlnbm9yZSBpZiBkdXJhdGlvbiBpcyB6ZXJvCiAgICAvLyBpZiBub3QgcmF0ZV9saW1pdF9idWNrZXQuZHVyYXRpb24uYXNfdWludDY0KCk6CiAgICBwdXNoaW50IDY0IC8vIDY0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBibnogX3VwZGF0ZV9jYXBhY2l0eV9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyODIKICAgIC8vIHJldHVybgogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKX3VwZGF0ZV9jYXBhY2l0eV9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6Mjg0LTI4NQogICAgLy8gIyBpbmNyZWFzZSBjYXBhY2l0eSBieSBmaWxsIHJhdGUgb2YgPGxpbWl0PiBwZXIgPGR1cmF0aW9uPiB3aXRob3V0IGV4Y2VlZGluZyBsaW1pdAogICAgLy8gdGltZV9kZWx0YSA9IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wIC0gcmF0ZV9saW1pdF9idWNrZXQubGFzdF91cGRhdGVkLmFzX3VpbnQ2NCgpCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBmcmFtZV9kaWcgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBwdXNoaW50IDcyIC8vIDcyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI4NgogICAgLy8gbmV3X2NhcGFjaXR5X3dpdGhvdXRfbWF4ID0gcmF0ZV9saW1pdF9idWNrZXQuY3VycmVudF9jYXBhY2l0eS5hc19iaWd1aW50KCkgKyAoCiAgICBkaWcgMQogICAgZXh0cmFjdCAzMiAzMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI4NwogICAgLy8gKHJhdGVfbGltaXRfYnVja2V0LmxpbWl0LmFzX2JpZ3VpbnQoKSAqIHRpbWVfZGVsdGEpIC8vIHJhdGVfbGltaXRfYnVja2V0LmR1cmF0aW9uLmFzX3VpbnQ2NCgpCiAgICB1bmNvdmVyIDIKICAgIGV4dHJhY3QgMCAzMgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgZGlnIDEKICAgIGIqCiAgICBmcmFtZV9kaWcgMwogICAgaXRvYgogICAgYi8KICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9SYXRlTGltaXRlci5weToyODYtMjg4CiAgICAvLyBuZXdfY2FwYWNpdHlfd2l0aG91dF9tYXggPSByYXRlX2xpbWl0X2J1Y2tldC5jdXJyZW50X2NhcGFjaXR5LmFzX2JpZ3VpbnQoKSArICgKICAgIC8vICAgICAgICAgKHJhdGVfbGltaXRfYnVja2V0LmxpbWl0LmFzX2JpZ3VpbnQoKSAqIHRpbWVfZGVsdGEpIC8vIHJhdGVfbGltaXRfYnVja2V0LmR1cmF0aW9uLmFzX3VpbnQ2NCgpCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIGIrCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI5MgogICAgLy8gaWYgbmV3X2NhcGFjaXR5X3dpdGhvdXRfbWF4ID4gcmF0ZV9saW1pdF9idWNrZXQubGltaXQgZWxzZSBBUkM0VUludDI1NihuZXdfY2FwYWNpdHlfd2l0aG91dF9tYXgpCiAgICBiPAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI5MC0yOTIKICAgIC8vICMgdXBkYXRlIGNhcGFjaXR5IGFuZCBsYXN0IHVwZGF0ZWQgdGltZXN0YW1wCiAgICAvLyBzZWxmLnJhdGVfbGltaXRfYnVja2V0c1tidWNrZXRfaWRdLmN1cnJlbnRfY2FwYWNpdHkgPSByYXRlX2xpbWl0X2J1Y2tldC5saW1pdCBcCiAgICAvLyAgICAgaWYgbmV3X2NhcGFjaXR5X3dpdGhvdXRfbWF4ID4gcmF0ZV9saW1pdF9idWNrZXQubGltaXQgZWxzZSBBUkM0VUludDI1NihuZXdfY2FwYWNpdHlfd2l0aG91dF9tYXgpCiAgICBieiBfdXBkYXRlX2NhcGFjaXR5X3Rlcm5hcnlfZmFsc2VANgogICAgZnJhbWVfZGlnIDAKCl91cGRhdGVfY2FwYWNpdHlfdGVybmFyeV9tZXJnZUA3OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI5MC0yOTEKICAgIC8vICMgdXBkYXRlIGNhcGFjaXR5IGFuZCBsYXN0IHVwZGF0ZWQgdGltZXN0YW1wCiAgICAvLyBzZWxmLnJhdGVfbGltaXRfYnVja2V0c1tidWNrZXRfaWRdLmN1cnJlbnRfY2FwYWNpdHkgPSByYXRlX2xpbWl0X2J1Y2tldC5saW1pdCBcCiAgICBieXRlY18zIC8vIDB4NzI2MTc0NjU1ZjZjNjk2ZDY5NzQ1ZjYyNzU2MzZiNjU3NDczNWYKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MjkwLTI5MgogICAgLy8gIyB1cGRhdGUgY2FwYWNpdHkgYW5kIGxhc3QgdXBkYXRlZCB0aW1lc3RhbXAKICAgIC8vIHNlbGYucmF0ZV9saW1pdF9idWNrZXRzW2J1Y2tldF9pZF0uY3VycmVudF9jYXBhY2l0eSA9IHJhdGVfbGltaXRfYnVja2V0LmxpbWl0IFwKICAgIC8vICAgICBpZiBuZXdfY2FwYWNpdHlfd2l0aG91dF9tYXggPiByYXRlX2xpbWl0X2J1Y2tldC5saW1pdCBlbHNlIEFSQzRVSW50MjU2KG5ld19jYXBhY2l0eV93aXRob3V0X21heCkKICAgIGR1cAogICAgaW50Y18yIC8vIDMyCiAgICB1bmNvdmVyIDMKICAgIGJveF9yZXBsYWNlCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MjkzCiAgICAvLyBzZWxmLnJhdGVfbGltaXRfYnVja2V0c1tidWNrZXRfaWRdLmxhc3RfdXBkYXRlZCA9IEFSQzRVSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICBwdXNoaW50IDcyIC8vIDcyCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKX3VwZGF0ZV9jYXBhY2l0eV90ZXJuYXJ5X2ZhbHNlQDY6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6MjkyCiAgICAvLyBpZiBuZXdfY2FwYWNpdHlfd2l0aG91dF9tYXggPiByYXRlX2xpbWl0X2J1Y2tldC5saW1pdCBlbHNlIEFSQzRVSW50MjU2KG5ld19jYXBhY2l0eV93aXRob3V0X21heCkKICAgIGZyYW1lX2RpZyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBpbnRjXzIgLy8gMzIKICAgIGJ6ZXJvCiAgICBifAogICAgYiBfdXBkYXRlX2NhcGFjaXR5X3Rlcm5hcnlfbWVyZ2VANwoKCi8vIGZvbGtzX2NvbnRyYWN0cy5saWJyYXJ5LlJhdGVMaW1pdGVyLlJhdGVMaW1pdGVyLl9nZXRfYnVja2V0KGJ1Y2tldF9pZDogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlczoKX2dldF9idWNrZXQ6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvUmF0ZUxpbWl0ZXIucHk6Mjk5LTMwMAogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBfZ2V0X2J1Y2tldChzZWxmLCBidWNrZXRfaWQ6IEJ5dGVzMzIpIC0+IFJhdGVMaW1pdEJ1Y2tldDoKICAgIHByb3RvIDEgMgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjI5NwogICAgLy8gYXNzZXJ0IGJ1Y2tldF9pZCBpbiBzZWxmLnJhdGVfbGltaXRfYnVja2V0cywgIlVua25vd24gYnVja2V0IgogICAgYnl0ZWNfMyAvLyAweDcyNjE3NDY1NWY2YzY5NmQ2OTc0NWY2Mjc1NjM2YjY1NzQ3MzVmCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBVbmtub3duIGJ1Y2tldAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1JhdGVMaW1pdGVyLnB5OjMwMgogICAgLy8gcmV0dXJuIHNlbGYucmF0ZV9saW1pdF9idWNrZXRzW2J1Y2tldF9pZF0KICAgIGJveF9nZXQKICAgIHBvcAogICAgZnJhbWVfZGlnIC0xCiAgICByZXRzdWIKCgovLyBmb2xrc19jb250cmFjdHMubGlicmFyeS5VcGdyYWRlYWJsZS5VcGdyYWRlYWJsZS5nZXRfYWN0aXZlX21pbl91cGdyYWRlX2RlbGF5KCkgLT4gdWludDY0OgpnZXRfYWN0aXZlX21pbl91cGdyYWRlX2RlbGF5OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIyMAogICAgLy8gbWluX3VwZ3JhZGVfZGVsYXkgPSBzZWxmLm1pbl91cGdyYWRlX2RlbGF5LnZhbHVlLmNvcHkoKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gIm1pbl91cGdyYWRlX2RlbGF5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5taW5fdXBncmFkZV9kZWxheSBleGlzdHMKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMjIKICAgIC8vIG1pbl91cGdyYWRlX2RlbGF5LmRlbGF5XzEgaWYgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgPj0gbWluX3VwZ3JhZGVfZGVsYXkudGltZXN0YW1wCiAgICBleHRyYWN0IDE2IDgKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIGI8PQogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIyMi0yMjMKICAgIC8vIG1pbl91cGdyYWRlX2RlbGF5LmRlbGF5XzEgaWYgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgPj0gbWluX3VwZ3JhZGVfZGVsYXkudGltZXN0YW1wCiAgICAvLyBlbHNlIG1pbl91cGdyYWRlX2RlbGF5LmRlbGF5XzAKICAgIGJ6IGdldF9hY3RpdmVfbWluX3VwZ3JhZGVfZGVsYXlfdGVybmFyeV9mYWxzZUAyCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjIyCiAgICAvLyBtaW5fdXBncmFkZV9kZWxheS5kZWxheV8xIGlmIEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wID49IG1pbl91cGdyYWRlX2RlbGF5LnRpbWVzdGFtcAogICAgZXh0cmFjdCA4IDgKCmdldF9hY3RpdmVfbWluX3VwZ3JhZGVfZGVsYXlfdGVybmFyeV9tZXJnZUAzOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L1VwZ3JhZGVhYmxlLnB5OjIyMS0yMjQKICAgIC8vIHJldHVybiAoCiAgICAvLyAgICAgbWluX3VwZ3JhZGVfZGVsYXkuZGVsYXlfMSBpZiBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCA+PSBtaW5fdXBncmFkZV9kZWxheS50aW1lc3RhbXAKICAgIC8vICAgICBlbHNlIG1pbl91cGdyYWRlX2RlbGF5LmRlbGF5XzAKICAgIC8vICkuYXNfdWludDY0KCkKICAgIGJ0b2kKICAgIHJldHN1YgoKZ2V0X2FjdGl2ZV9taW5fdXBncmFkZV9kZWxheV90ZXJuYXJ5X2ZhbHNlQDI6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvVXBncmFkZWFibGUucHk6MjIzCiAgICAvLyBlbHNlIG1pbl91cGdyYWRlX2RlbGF5LmRlbGF5XzAKICAgIGV4dHJhY3QgMCA4CiAgICBiIGdldF9hY3RpdmVfbWluX3VwZ3JhZGVfZGVsYXlfdGVybmFyeV9tZXJnZUAzCgoKLy8gZm9sa3NfY29udHJhY3RzLmxpYnJhcnkuVXBncmFkZWFibGUuVXBncmFkZWFibGUuX2NoZWNrX3NjaGVkdWxlX3RpbWVzdGFtcCh0aW1lc3RhbXA6IHVpbnQ2NCkgLT4gdm9pZDoKX2NoZWNrX3NjaGVkdWxlX3RpbWVzdGFtcDoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMzAtMjMxCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9jaGVja19zY2hlZHVsZV90aW1lc3RhbXAoc2VsZiwgdGltZXN0YW1wOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMzMKICAgIC8vIHRpbWVzdGFtcCA+PSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIHNlbGYuZ2V0X2FjdGl2ZV9taW5fdXBncmFkZV9kZWxheSgpCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBjYWxsc3ViIGdldF9hY3RpdmVfbWluX3VwZ3JhZGVfZGVsYXkKICAgICsKICAgIGZyYW1lX2RpZyAtMQogICAgPD0KICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9VcGdyYWRlYWJsZS5weToyMzItMjM0CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHRpbWVzdGFtcCA+PSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIHNlbGYuZ2V0X2FjdGl2ZV9taW5fdXBncmFkZV9kZWxheSgpCiAgICAvLyApLCAiTXVzdCBzY2hlZHVsZSBhdCBsZWFzdCBtaW4gdXBncmFkZSBkZWxheSB0aW1lIGluIGZ1dHVyZSIKICAgIGFzc2VydCAvLyBNdXN0IHNjaGVkdWxlIGF0IGxlYXN0IG1pbiB1cGdyYWRlIGRlbGF5IHRpbWUgaW4gZnV0dXJlCiAgICByZXRzdWIKCgovLyBmb2xrc19jb250cmFjdHMubGlicmFyeS5BY2Nlc3NDb250cm9sLkFjY2Vzc0NvbnRyb2wuaGFzX3JvbGUocm9sZTogYnl0ZXMsIGFjY291bnQ6IGJ5dGVzKSAtPiBieXRlcywgYnl0ZXM6Cmhhc19yb2xlOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTExLTExMgogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgLy8gZGVmIGhhc19yb2xlKHNlbGYsIHJvbGU6IEJ5dGVzMTYsIGFjY291bnQ6IEFkZHJlc3MpIC0+IEJvb2w6CiAgICBwcm90byAyIDIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjE1NQogICAgLy8gcmV0dXJuIEFkZHJlc3NSb2xlS2V5KHJvbGUuY29weSgpLCBhY2NvdW50KQogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTIzCiAgICAvLyByZXR1cm4gQm9vbChhZGRyZXNzX3JvbGVfa2V5IGluIHNlbGYuYWRkcmVzc2VzX3JvbGVzKSBhbmQgc2VsZi5hZGRyZXNzZXNfcm9sZXNbYWRkcmVzc19yb2xlX2tleV0KICAgIGJ5dGVjIDIyIC8vIDB4NjE2NDY0NzI2NTczNzM1ZjcyNmY2YzY1NzM1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnl0ZWNfMCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGR1cAogICAgYnl0ZWNfMCAvLyAweDAwCiAgICA9PQogICAgYnogaGFzX3JvbGVfdGVybmFyeV9mYWxzZUA0CiAgICBmcmFtZV9kaWcgMQoKaGFzX3JvbGVfdGVybmFyeV9tZXJnZUA1OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTIzCiAgICAvLyByZXR1cm4gQm9vbChhZGRyZXNzX3JvbGVfa2V5IGluIHNlbGYuYWRkcmVzc2VzX3JvbGVzKSBhbmQgc2VsZi5hZGRyZXNzZXNfcm9sZXNbYWRkcmVzc19yb2xlX2tleV0KICAgIGZyYW1lX2RpZyAtMgogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDMKICAgIHJldHN1YgoKaGFzX3JvbGVfdGVybmFyeV9mYWxzZUA0OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTIzCiAgICAvLyByZXR1cm4gQm9vbChhZGRyZXNzX3JvbGVfa2V5IGluIHNlbGYuYWRkcmVzc2VzX3JvbGVzKSBhbmQgc2VsZi5hZGRyZXNzZXNfcm9sZXNbYWRkcmVzc19yb2xlX2tleV0KICAgIGZyYW1lX2RpZyAwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hZGRyZXNzZXNfcm9sZXMgZW50cnkgZXhpc3RzCiAgICBiIGhhc19yb2xlX3Rlcm5hcnlfbWVyZ2VANQoKCi8vIGZvbGtzX2NvbnRyYWN0cy5saWJyYXJ5LkFjY2Vzc0NvbnRyb2wuQWNjZXNzQ29udHJvbC5nZXRfcm9sZV9hZG1pbihyb2xlOiBieXRlcykgLT4gYnl0ZXMsIGJ5dGVzOgpnZXRfcm9sZV9hZG1pbjoKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjEyNS0xMjYKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfcm9sZV9hZG1pbihzZWxmLCByb2xlOiBCeXRlczE2KSAtPiBCeXRlczE2OgogICAgcHJvdG8gMSAyCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxMzUKICAgIC8vIGlmIHJvbGUgbm90IGluIHNlbGYucm9sZXM6CiAgICBwdXNoYnl0ZXMgMHg3MjZmNmM2NTVmCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJueiBnZXRfcm9sZV9hZG1pbl9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjEwOQogICAgLy8gcmV0dXJuIEJ5dGVzMTYuZnJvbV9ieXRlcyhvcC5iemVybyhjb25zdC5CWVRFUzE2X0xFTkdUSCkpCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBiemVybwogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTM2CiAgICAvLyByZXR1cm4gc2VsZi5kZWZhdWx0X2FkbWluX3JvbGUoKQogICAgZnJhbWVfZGlnIC0xCiAgICB1bmNvdmVyIDIKICAgIHJldHN1YgoKZ2V0X3JvbGVfYWRtaW5fYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTM3CiAgICAvLyByZXR1cm4gc2VsZi5yb2xlc1tyb2xlXQogICAgZnJhbWVfZGlnIDAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvbGVzIGVudHJ5IGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICB1bmNvdmVyIDIKICAgIHJldHN1YgoKCi8vIGZvbGtzX2NvbnRyYWN0cy5saWJyYXJ5LkFjY2Vzc0NvbnRyb2wuQWNjZXNzQ29udHJvbC5fY2hlY2tfc2VuZGVyX3JvbGUocm9sZTogYnl0ZXMpIC0+IGJ5dGVzOgpfY2hlY2tfc2VuZGVyX3JvbGU6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNTctMTU4CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9jaGVja19zZW5kZXJfcm9sZShzZWxmLCByb2xlOiBCeXRlczE2KSAtPiBOb25lOgogICAgcHJvdG8gMSAxCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNjMKICAgIC8vIGFzc2VydCBzZWxmLmhhc19yb2xlKHJvbGUsIGFjY291bnQpLCAiQWNjZXNzIGNvbnRyb2wgdW5hdXRob3Jpc2VkIGFjY291bnQiCiAgICBmcmFtZV9kaWcgLTEKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjE1OQogICAgLy8gc2VsZi5fY2hlY2tfcm9sZShyb2xlLCBBZGRyZXNzKFR4bi5zZW5kZXIpKQogICAgdHhuIFNlbmRlcgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTYzCiAgICAvLyBhc3NlcnQgc2VsZi5oYXNfcm9sZShyb2xlLCBhY2NvdW50KSwgIkFjY2VzcyBjb250cm9sIHVuYXV0aG9yaXNlZCBhY2NvdW50IgogICAgY2FsbHN1YiBoYXNfcm9sZQogICAgZnJhbWVfYnVyeSAtMQogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAhPQogICAgYXNzZXJ0IC8vIEFjY2VzcyBjb250cm9sIHVuYXV0aG9yaXNlZCBhY2NvdW50CiAgICBmcmFtZV9kaWcgLTEKICAgIHJldHN1YgoKCi8vIGZvbGtzX2NvbnRyYWN0cy5saWJyYXJ5LkFjY2Vzc0NvbnRyb2wuQWNjZXNzQ29udHJvbC5fZ3JhbnRfcm9sZShyb2xlOiBieXRlcywgYWNjb3VudDogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlczoKX2dyYW50X3JvbGU6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNjUtMTY2CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9ncmFudF9yb2xlKHNlbGYsIHJvbGU6IEJ5dGVzMTYsIGFjY291bnQ6IEFkZHJlc3MpIC0+IEJvb2w6CiAgICBwcm90byAyIDIKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjE2Ny0xNjgKICAgIC8vICMgZ3JhbnQgcm9sZSB0byBhY2NvdW50IGlmIGl0IGRvZXNuJ3QgaGF2ZQogICAgLy8gaWYgbm90IHNlbGYuaGFzX3JvbGUocm9sZSwgYWNjb3VudCk6CiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBoYXNfcm9sZQogICAgZnJhbWVfYnVyeSAtMgogICAgYnl0ZWNfMCAvLyAweDAwCiAgICA9PQogICAgYnogX2dyYW50X3JvbGVfZWxzZV9ib2R5QDYKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjE1NQogICAgLy8gcmV0dXJuIEFkZHJlc3NSb2xlS2V5KHJvbGUuY29weSgpLCBhY2NvdW50KQogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTcwCiAgICAvLyBzZWxmLmFkZHJlc3Nlc19yb2xlc1thZGRyZXNzX3JvbGVfa2V5XSA9IEJvb2woVHJ1ZSkKICAgIGJ5dGVjIDIyIC8vIDB4NjE2NDY0NzI2NTczNzM1ZjcyNmY2YzY1NzM1ZgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgYnl0ZWMgNyAvLyAweDgwCiAgICBib3hfcHV0CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNzEKICAgIC8vIGVtaXQoUm9sZUdyYW50ZWQocm9sZSwgYWNjb3VudCwgQWRkcmVzcyhUeG4uc2VuZGVyKSkpCiAgICB0eG4gU2VuZGVyCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDQ4NjgwYjk1IC8vIG1ldGhvZCAiUm9sZUdyYW50ZWQoYnl0ZVsxNl0sYWRkcmVzcyxhZGRyZXNzKSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNzAKICAgIC8vIHNlbGYuYWRkcmVzc2VzX3JvbGVzW2FkZHJlc3Nfcm9sZV9rZXldID0gQm9vbChUcnVlKQogICAgYnl0ZWMgNyAvLyAweDgwCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNzIKICAgIC8vIHJldHVybiBCb29sKFRydWUpCiAgICBmcmFtZV9kaWcgLTIKICAgIHJldHN1YgoKX2dyYW50X3JvbGVfZWxzZV9ib2R5QDY6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNjctMTY4CiAgICAvLyAjIGdyYW50IHJvbGUgdG8gYWNjb3VudCBpZiBpdCBkb2Vzbid0IGhhdmUKICAgIC8vIGlmIG5vdCBzZWxmLmhhc19yb2xlKHJvbGUsIGFjY291bnQpOgogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNzQKICAgIC8vIHJldHVybiBCb29sKEZhbHNlKQogICAgZnJhbWVfZGlnIC0yCiAgICByZXRzdWIKCgovLyBmb2xrc19jb250cmFjdHMubGlicmFyeS5BY2Nlc3NDb250cm9sLkFjY2Vzc0NvbnRyb2wuX3Jldm9rZV9yb2xlKHJvbGU6IGJ5dGVzLCBhY2NvdW50OiBieXRlcykgLT4gYnl0ZXMsIGJ5dGVzOgpfcmV2b2tlX3JvbGU6CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNzYtMTc3CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9yZXZva2Vfcm9sZShzZWxmLCByb2xlOiBCeXRlczE2LCBhY2NvdW50OiBBZGRyZXNzKSAtPiBCb29sOgogICAgcHJvdG8gMiAyCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNzgtMTc5CiAgICAvLyAjIHJldm9rZSByb2xlIGZyb20gYWNjb3VudCBpZiBpdCBkb2VzIGhhdmUKICAgIC8vIGlmIHNlbGYuaGFzX3JvbGUocm9sZSwgYWNjb3VudCk6CiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBoYXNfcm9sZQogICAgZnJhbWVfYnVyeSAtMgogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAhPQogICAgYnogX3Jldm9rZV9yb2xlX2Vsc2VfYm9keUA2CiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxNTUKICAgIC8vIHJldHVybiBBZGRyZXNzUm9sZUtleShyb2xlLmNvcHkoKSwgYWNjb3VudCkKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIC8vIHZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9mb2xrc19jb250cmFjdHMvbGlicmFyeS9BY2Nlc3NDb250cm9sLnB5OjE4MQogICAgLy8gZGVsIHNlbGYuYWRkcmVzc2VzX3JvbGVzW2FkZHJlc3Nfcm9sZV9rZXldCiAgICBieXRlYyAyMiAvLyAweDYxNjQ2NDcyNjU3MzczNWY3MjZmNmM2NTczNWYKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGJveF9kZWwKICAgIHBvcAogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTgyCiAgICAvLyBlbWl0KFJvbGVSZXZva2VkKHJvbGUsIGFjY291bnQsIEFkZHJlc3MoVHhuLnNlbmRlcikpKQogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHg5YjViM2U3MyAvLyBtZXRob2QgIlJvbGVSZXZva2VkKGJ5dGVbMTZdLGFkZHJlc3MsYWRkcmVzcykiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTgzCiAgICAvLyByZXR1cm4gQm9vbChUcnVlKQogICAgYnl0ZWMgNyAvLyAweDgwCiAgICBmcmFtZV9kaWcgLTIKICAgIHJldHN1YgoKX3Jldm9rZV9yb2xlX2Vsc2VfYm9keUA2OgogICAgLy8gdmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL2ZvbGtzX2NvbnRyYWN0cy9saWJyYXJ5L0FjY2Vzc0NvbnRyb2wucHk6MTc4LTE3OQogICAgLy8gIyByZXZva2Ugcm9sZSBmcm9tIGFjY291bnQgaWYgaXQgZG9lcyBoYXZlCiAgICAvLyBpZiBzZWxmLmhhc19yb2xlKHJvbGUsIGFjY291bnQpOgogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAvLyB2ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvZm9sa3NfY29udHJhY3RzL2xpYnJhcnkvQWNjZXNzQ29udHJvbC5weToxODUKICAgIC8vIHJldHVybiBCb29sKEZhbHNlKQogICAgZnJhbWVfZGlnIC0yCiAgICByZXRzdWIK",
    clear:
      "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K",
  },
  byteCode: {
    approval:
      "CyAFAAEgCIDqSSYdAQAEFR98dQ5pc19pbml0aWFsaXNlZBNyYXRlX2xpbWl0X2J1Y2tldHNfINRuw7i9VE+90qGqsN3n8weKZmiPOFLtBQvdea1rrWObCElOQk9VTkRfEW1pbl91cGdyYWRlX2RlbGF5AYAJaXNfcGF1c2VkEM+M0ye4oujgUSo5bbqfAHsac2NoZWR1bGVkX2NvbnRyYWN0X3VwZ3JhZGUQuvxs6S1GQz/FuCqXNxnphgludHRfdG9rZW4HdmVyc2lvbhN0cmFuc2NlaXZlcl9tYW5hZ2VyEGpnOAW6pd2VkurDjsOZuCgIYXNzZXRfaWQQbWVzc2FnZV9zZXF1ZW5jZQhjaGFpbl9pZARIILR4GWluYm91bmRfcXVldWVkX3RyYW5zZmVyc18ab3V0Ym91bmRfcXVldWVkX3RyYW5zZmVyc18OYWRkcmVzc19yb2xlc18SbWVzc2FnZXNfZXhlY3V0ZWRfBJlOVFQRbnR0X21hbmFnZXJfcGVlcl8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAJdGhyZXNob2xkIkcNgABHCjEYQAAPKiJnJw0jZycIImcnESJngASPo4iLNhoAjgEKCTEZFEQxGEEJgoItBFrw9h8EAXj5SwQbUp3oBNLgX0kEz6SptATQw9pFBKw/OoQEvsWtAgTSuR91BLatixcEX+AA/gTnJhEMBGuq2hcERqF4dQSL8GXMBJTpMGcEPhyQNwTYtOaUBOsz3osEtriVJwTGm9huBPT+weMEk/xHRwQUKjRzBCoRnBIELYAnfASI52XpBLjxSDQE8QmxtASXrFriBLilbCEEtQ1ppATcuXKoBOA06WsEVjMZXgQQi2iXBP+4kUgE2XzjEAR97bzSBNc7okQEcrow7gQOlNv8BGe9UjcE/WGovgRVV3f2NhoAji0H6we/B5AHYgdJBswGjAXNBXkFHgS4BJ8EhgRtBFsDRQMzAyEDBQLoAr8ClQKJAm8CVwJEAjACBwHuAdwBwgGnAZQBKAD3ANIAuQCoAJ4AfABaAEgALwAUAAEANhoBSRWBEBJEiBEnSClMULAjQzYaAUkVgRASRDYaAkkVJBJEiBDhSClMULAjQ4AUFR98dQAAAAAAAAAAAAAAAAAAAACwI0M2GgFJFYEQEkQxAIgRSEYCI0M2GgFJFYEQEkQ2GgJJFSQSREyIEMVMiBDmSEyIESZGAiNDNhoBSRWBEBJENhoCSRUkEkRMiBCjTIgQxEhMiBDRRgIjQ4gQPBYpTFCwI0OADBUffHUAAAAAABJ1ALAjQ4AUFR98dc+M0ye4oujgUSo5bbqfAHuwI0MiKmVERCcJiBB9SCInCmVEVwAgJwppMgcWUIAEAKbI8UxQsCNDNhoBSRUkEkQ2GgJJFSUSREkXIiplREQnCYgQRkiID+RQJwpLAWeABJCLxVFMULAjQzYaAUlFD0kVJRJEFzYaAklFD0kVJRJEFyIqZUREJwmIEA9ITCEEDkSID6giJwZlRFcQCDIHFqZBAA8iJwZlRElXCAhcACcGTGciJwZlREsOSU4CXAhLDklOAlwQJwZMZ1CABEV9+fdMULAjQzYaAUkVJBJEiA0ASBYpTFCwI0M2GgFJFSQSRCtMUEm9RQFEvkhXACApTFCwI0M2GgFJFSQSRDYaAkkVJBJEiAyaSClMULAjQzYaAUkVJBJEiAxySClMULAjQ4AUFR98dbr8bOktRkM/xbgqlzcZ6YawI0OAJBUffHXUbsO4vVRPvdKhqrDd5/MHimZojzhS7QUL3Xmta61jm7AjQzYaAUkVgQISRCcFTFACKUxQsCNDNhoBSRUkEkSICrBIUClMULAjQzYaAUkVgQISRCcFTFACiAvxSClMULAjQzYaAUkVJBJEiApcSEyAAgADUExQKUxQsCNDJwSIC8tIKUxQsCNDNhoBSRWBAhJENhoCSRUlEkQXIiplREQnC4gOqEgnBU8CUAJMiAyaSCNDNhoBSRWBAhJENhoCSRUkEkQiKmVERCcLiA5/SCcFTwJQAkyIDAFII0M2GgFJFSUSRBciKmVERCcLiA5eSCcETIgMVEgjQzYaAUkVJBJEIiplREQnC4gOQkgnBEyIC8hII0M2GgFJFSQSRIgIrEgpTFCwI0M2GgFJFSQSRIgISkgpTFCwI0M2GgFJFUsBgYIBWUmBhAESREsCTEsCUkkiWYGGAQhPAhJESwFXQAJLAldCIEsDV2IgsSInDmVEshiABDe8camyGk8EshqBBrIQIrIBs7Q+SVcEAEkVJBJETFcABCkSREsBUQAYgRivEkRMgRhbMggSRIgHz0woE0SICBhMKBJEJxdLAVAnB78iKmVERIgF4UsCiAXMVwAgTwISREsCVwIEJxgSREsCgQZVFkmTJQ5EVwcBSwNXBwhLBFcvIElFGEkVJBJETwWBT1kiJxJlREwWqERMTwJQiAc+SwEiW0sCVwgBTwKIBURJRQZOBExPAogJnEgoEkEAHLFJFiInDGVEshgnE7IaSxKyGrIagQayECKyAbMjQzYaAUkVgQISRIgFPilMULAjQ4AUFR98dYKzLZq1EA2wiuuaDgi0ItGwI0OAFBUffHVTlECCADDEmU204xtrgA3qsCNDgBQVH3x1amc4Bbql3ZWS6sOOw5m4KLAjQzYaAUkVJBJEIiplRESIBO2ICDRPAigTRCcUSwFQSb1FAUS8SIAExu9zOkxQsElXCAmIBnBLASJbTwJXCAFPAogEdrFMVxMgTBYiJwxlRLIYJxOyGkyyGrIagQayECKyAbOIBlIjQzYaAUkVJBJEIiplRESIBIeIB6VOAkUBMQBLAVczIBJETIgI+0hXCAmIBhNLASJbTwJXCAFPAogEGbExAEwWIicMZUSyGCcTshpMshqyGoEGshAisgGziAX3I0MxFiMJSTgQIxJENhoBSRUkEkQiKmVERIgEIogHQE8CKBNEiAifSwFXCAlLAlcRAksDVxMgSwRXMyBLBYFTWUsGFU8HTgJSiATfRgKIBacpTFCwI0MxFoECCUlFCjgQIxJEMRYjCUlFBjgQgQQSRDYaAUkVJRJEF0UKNhoCSUUSFYECEkQ2GgNJRRMVJBJENhoESUUQFSMSRDYaBUlFDUkiWUlFDYECC0UISRVFA1cCAEUZIkUISwdLCwxBADRLB0mBAgtLGklPAllJSwpJTgQSREsBFVJJFUsBJVlJgQoSRExSIlmBDAgIRQgjCEUIQv/ESwaBAghLAhJESwhLBUsLSxNLFUsTSxGIAzlGAilMULAjQzEWgQIJSTgQIxJEMRYjCUk4EIEEEkQ2GgFJFSUSRBc2GgJJFYECEkQ2GgNJFSQSRCiAAgAAiAL5RgIpTFCwI0M2GgFJRRdJFYECEkQ2GgJJRRcVJBJENhoDSUUWSRUjEkQiKmVERCcPiApiSCInEmVESwKpRBdEJxlMUElFGb1FARQoIk8CVElFGCgTQQANJwVLFlACJxoiiAeMSEsUSUsVSU4DUEsaTL9LF0xQTFBLF1CABEy+tPhMULAjQzYaAUkVJRJEFyIqZUREJw+ICf1IiATRI0M2GgFJFSQSRDYaAkkVJRJESRciKmVERCcPiAnbSE8CTIgEeoAECjtvnkxQsCNDIiplRESAEIKzLZq1EA2wiuuaDgi0ItGICa9IIicIZUREJwgiZ4AFfav3fgCwI0MiKmVERIAQU5RAggAwxJlNtOMba4AN6ogJgEiIAdgnCCNngAV9q/d+gLAjQzYaAUkVJBJENhoCSRUlEkQXMQAyCRJEIiplRBREKiNnJwQnGiKIBqBIgRCvSwKICU9GAicLSwKICUZGAksBTIgD0icJSwGICTdGAicPTIgJL0YCI0OABLemmmE2GgCOAQABADYaAUkVJRJEFzYaAkkVgQISRDYaA0kVJRJEFzYaBEkVJRJESRdPAogDuSEEDkQnG0xQJxtQJwZMZ7FLAbIYgARboiqEshqBBrIQIrIBs7Q+SVcEAEkVJRJETFcABCkSRBcnEExnJwxPAmcnEkxnI0MxGYEEEjEYEEQiKmVERCcJiAiISCInCmVMSU4CRRJEVyAIMgcWpkSACGFwcHJvdmFsRRMxQUUEIkUGSwVLBAxBABNLBUnAQAFLFExQRRQjCEUGQv/lSxKABWNsZWFyUEUTMUNFAyJFBksFSwMMQQATSwVJwEIBSxRMUEUUIwhFBkL/5UsSAUsQVwAgSwESRCcKaSInDWVEIwgnDUxnKiJnIicNZUQWUIAEkkLa8UxQsCNDigMBi/6L/6hBAAOL/YmL/ov/pUEAEIv+F4v/FwmBCkyUi/1MComL/xeL/hcJgQpMlIv9C4mKAQEnGYv/UEm9RQFEvkiJIicIZUQURImKBwMiKmVERIj/7Yv5OAcyChJEIicMZURyCESL+jgRIicQZUQSRIv6OBQSRIv6OBKL+xJEi/tEJK+L/RNEi/yI/6ZXIAGIAVeAAQhLAaRLAYABCE8CTUlLA6RPA04CTYv7SwJLAoj/SxZMUElOAkkiW0sBVwgBTwOI/ziL+xJEIicRZUQjCCcRSwFnFgKL+4v8i/2L/ov/TwZPBogC0k4DjP+M/SgTQQAfsYv5OAiL+TgAsgeyCCOyECKyAbOLAYv9i/9PBE8EiTEAi/mLAYsAi/yL/U8Fi/+IAAmM/4z9jAFC/9mKBwOL/Ij+/Iv7VwgBSU4CJxhMUIv7VwAIUCInEGVEJK9MFksBTFwYTwJMUIv9UIv8UEkVFlcGAkxQMggWTwJMXBhPAlcAIIv6i/5PA4v8TwRPBYv/iAFQjP9GBUmL+TgHMgoSRIv5OAhJSwIPREwJSUEAErGL+TgAsgeLArIII7IQIrIBs4gAMov7IluLAE8CiP47FosBFov6i/1Qi/xQTwJQTFCABL4NjGVMULCL+ov9i/9PBU8FTwWJIicQZURxAUQWSZMlDkRXBwGJMgpzAEQyCnMBRAmxMQCyB7III7IQIrIBs4mKAQKxIicOZUSyGIAECA2vbbIai/+yGoEGshAisgGztD5JVwQASRUlEkRMVwAEKRJEF0lBABYiJxxlRIsADkEACyMoIk8CVIv/TwKJIkL/8ooBAicXi/9QSb1FASgiTwJUSSgSQQAJiwGL/08DTwOJiwC+REL/8ooCACcOi/9nsYv/shiABPRCam+yGov+shqBBrIQIrIBs7Q+SVcEABUjEkRXAAQpEkSJigEAi/9EJxyL/2eL/xaABOEbbuBMULCJigcHsTIIFov5i/pQi/tQi/xQi/1QgAIAhFCL/lAiJw5lREmyGIAEJ8luMLIaTwKyGksBshqL/7IagQayECKyAbO0PklXBABJFSUSRExXAAQpEkQXSwFyCESxsgdJsggjshAisgG2TLIYgAS8HCm+shpMshqL/7IagQayECKyAbOL+Yv6i/uL/Yv+i/+JigEDJxWL/1BJvUUBREm+SEwyB0wiJboXCScEiAGrSA8oIk8CVEyL/4mKAQMnFIv/UEm9RQFEvkgyB0sBIlsJSwFXEQInBUxQAogBfUgPKCJPAlRMi/+JigcEi/kWSSSvq0knBEyIATFIi/woE0lAAAeLAigTQQCBI0SLA0EAVIsCKBJBAE0yBxYxAEyL/lCL+lCL+1BMUIACAFVQi/1QJxWL/1BJvEhMvycEiADVSDEAi/9QTFCLAFCABMEGXC9MULAnB4v7i/2L/08HTwdPB08HiScEiwFJTgKIAfJIJwWL+lACTIgCLkgoi/uL/Yv/TwdPB08HTweJIkL/fIoFAicFi/xQAkmL+xZJTgMkr6tJTgOIAINIKBJBADMyBxaL/VCL/FCL/lAnFIv/UEy/iABRSIv+i/9QTFCLAFCABPpGk3tMULAnB4v/TwNPA4mLAUlOAogBeEgnBEyIAbhIKIv/TwNPA4mKAQEnFYv/UEm9RQFEvEiABPEBFnWL/1Cwi/+JigECi/+IAgKM/yuL/1C+RFcgIIv/iYoCAov+iAHsSYz+iAJPjP5JgUBbQAAHJweL/k8CiYsAVyAgi/+nKCJPAlSL/k8CiYoBAiuL/1BJvUUBRL5IgUBbi/+JigMBK4v9UEm9RQEURIv/FjIHFov+SVBLAlBMUE8CTL+L/Yv+UExQgAQ5vLyeTFCwi/2JigIBIkmL/ogBc0mM/ogB1oz+SVcAIElOAov/pUEAREyL/6FJjAFMVyAgSYwApEEALYsAiwGhSRUkDkQkr6sri/5QSSRPA7sii/+7i/6L/1CABKJmdSFMULCL/owAiYAAQv/Ti/9PAqFMVyAgoEL/xooCAYv+iAEFSYz+iAFojP6L/0EAHYsAgUBbQAAViwBXACAri/5QSSRPA7syBxaBSEy7i/8WK4v+UIFASwK7i/5MUIAEWTciFExQsIv+TImKAgGL/ogAtkmM/ogBGYz+SYFAW0EAHosAVyAgi/9LAaZEi/+hSRUkDkQkr6sri/5QJE8Cu4v+i/9QgAR9FeU5TFCwi/5MiYoCASJHAov+iABsSYz+iADPjP5JgUBbQQBWiwNJVwAgTFcgIEmMAKFJjAKL/6VBADiL/4wBiwCLAaBJFSQORCSvqyuL/lAkTwK7iwFJFSQORCSvq4v+i/9QTFCABPs3j7NMULCL/owAiYsCjAFC/8WAAIwBQv/TigEBIkmL/4gAX4z/SYFAW0lAAAWL/4wAiTIHiwJJTgKBSFsJSwFXICBPAlcAIEmMAE8CFksBo4sDFqJPAqBJjAGkQQAXiwAri/9QSSRPA7syBxaBSEy7i/+MAImLAUkVJA5EJK+rQv/eigECK4v/UEm9RQFEvkiL/4kiJwZlTElPAkRXEAgyBxamQQAFVwgIF4lXAAhC//iKAQAyB4j/2giL/w5EiYoCAov+i/9QJxZMUEm9RQEoIk8CVEkoEkEACYsBi/5PA08DiYsAvkRC//KKAQKABXJvbGVfi/9QSb1FAUAACIEQr4v/TwKJiwC+RIv/TwKJigEBi/8xAIj/poz/KBNEi/+JigICi/6L/4j/lIz+KBJBAB6L/ov/UCcWSwFQJwe/MQBQgARIaAuVTFCwJweL/okoi/6JigICi/6L/4j/YYz+KBNBAB2L/ov/UCcWSwFQvEgxAFCABJtbPnNMULAnB4v+iSiL/ok=",
    clear: "C4EBQw==",
  },
  events: [
    { name: "ThresholdUpdated", args: [{ type: "uint64", name: "threshold" }] },
    {
      name: "BucketAdded",
      args: [
        { type: "byte[32]", name: "bucket_id" },
        { type: "uint256", name: "limit" },
        { type: "uint64", name: "duration" },
      ],
    },
    {
      name: "RoleGranted",
      args: [
        { type: "byte[16]", name: "role" },
        { type: "address", name: "account" },
        { type: "address", name: "sender" },
      ],
    },
    { name: "Paused", args: [{ type: "bool", name: "is_paused" }] },
    {
      name: "TransceiverManagerUpdated",
      args: [{ type: "uint64", name: "transceiver_manager" }],
    },
    {
      name: "NttManagerPeerSet",
      args: [
        { type: "uint16", name: "peer_chain_id" },
        { type: "byte[32]", name: "peer_contract" },
        { type: "uint8", name: "peer_decimals" },
        { type: "bool", name: "is_new" },
      ],
    },
    {
      name: "OutboundTransferRateLimited",
      args: [
        { type: "address", name: "sender" },
        { type: "byte[32]", name: "message_id" },
        { type: "uint256", name: "current_capacity" },
        { type: "uint64", name: "amount" },
      ],
    },
    {
      name: "BucketConsumed",
      args: [
        { type: "byte[32]", name: "bucket_id" },
        { type: "uint256", name: "amount" },
      ],
    },
    {
      name: "BucketFilled",
      args: [
        { type: "byte[32]", name: "bucket_id" },
        { type: "uint256", name: "requested_amount" },
        { type: "uint256", name: "actual_amount" },
      ],
    },
    {
      name: "TransferSent",
      args: [
        { type: "byte[32]", name: "message_id" },
        { type: "byte[32]", name: "recipient" },
        { type: "uint16", name: "recipient_chain" },
        { type: "uint64", name: "amount" },
        { type: "uint64", name: "fee" },
      ],
    },
    {
      name: "OutboundTransferDeleted",
      args: [{ type: "byte[32]", name: "message_id" }],
    },
    {
      name: "InboundTransferDeleted",
      args: [{ type: "byte[32]", name: "message_digest" }],
    },
    {
      name: "InboundTransferRateLimited",
      args: [
        { type: "address", name: "recipient" },
        { type: "byte[32]", name: "message_digest" },
        { type: "uint256", name: "current_capacity" },
        { type: "uint64", name: "amount" },
      ],
    },
    {
      name: "BucketRateLimitUpdated",
      args: [
        { type: "byte[32]", name: "bucket_id" },
        { type: "uint256", name: "limit" },
      ],
    },
    {
      name: "BucketRateDurationUpdated",
      args: [
        { type: "byte[32]", name: "bucket_id" },
        { type: "uint64", name: "duration" },
      ],
    },
    {
      name: "MinimumUpgradeDelayChange",
      args: [
        { type: "uint64", name: "delay" },
        { type: "uint64", name: "timestamp" },
      ],
    },
    {
      name: "UpgradeScheduled",
      args: [
        { type: "byte[32]", name: "program_sha256" },
        { type: "uint64", name: "timestamp" },
      ],
    },
    {
      name: "UpgradeCancelled",
      args: [
        { type: "byte[32]", name: "program_sha256" },
        { type: "uint64", name: "timestamp" },
      ],
    },
    {
      name: "UpgradeCompleted",
      args: [
        { type: "byte[32]", name: "program_sha256" },
        { type: "uint64", name: "version" },
      ],
    },
    {
      name: "RoleRevoked",
      args: [
        { type: "byte[16]", name: "role" },
        { type: "address", name: "account" },
        { type: "address", name: "sender" },
      ],
    },
  ],
  templateVariables: {},
} as unknown as Arc56Contract;

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined;
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined;
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value;
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString("utf-8") : undefined;
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never;

// Type definitions for ARC-56 structs

export type AddressRoleKey = {
  role: Uint8Array;
  address: string;
};

/**
 * Converts the ABI tuple representation of a AddressRoleKey to the struct representation
 */
export function AddressRoleKeyFromTuple(abiTuple: [Uint8Array, string]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.AddressRoleKey, APP_SPEC.structs) as AddressRoleKey;
}

export type RateLimitBucket = {
  limit: bigint;
  currentCapacity: bigint;
  duration: bigint;
  lastUpdated: bigint;
};

/**
 * Converts the ABI tuple representation of a RateLimitBucket to the struct representation
 */
export function RateLimitBucketFromTuple(abiTuple: [bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.RateLimitBucket, APP_SPEC.structs) as RateLimitBucket;
}

export type MinimumUpgradeDelay = {
  delay_0: bigint;
  delay_1: bigint;
  timestamp: bigint;
};

/**
 * Converts the ABI tuple representation of a MinimumUpgradeDelay to the struct representation
 */
export function MinimumUpgradeDelayFromTuple(abiTuple: [bigint, bigint, bigint]) {
  return getABIStructFromABITuple(
    abiTuple,
    APP_SPEC.structs.MinimumUpgradeDelay,
    APP_SPEC.structs,
  ) as MinimumUpgradeDelay;
}

export type ScheduledContractUpgrade = {
  programSha256: Uint8Array;
  timestamp: bigint;
};

/**
 * Converts the ABI tuple representation of a ScheduledContractUpgrade to the struct representation
 */
export function ScheduledContractUpgradeFromTuple(abiTuple: [Uint8Array, bigint]) {
  return getABIStructFromABITuple(
    abiTuple,
    APP_SPEC.structs.ScheduledContractUpgrade,
    APP_SPEC.structs,
  ) as ScheduledContractUpgrade;
}

export type InboundQueuedTransfer = {
  timestamp: bigint;
  amount: TrimmedAmount;
  sourceChain: number;
  recipient: string;
};

/**
 * Converts the ABI tuple representation of a InboundQueuedTransfer to the struct representation
 */
export function InboundQueuedTransferFromTuple(abiTuple: [bigint, [bigint, number], number, string]) {
  return getABIStructFromABITuple(
    abiTuple,
    APP_SPEC.structs.InboundQueuedTransfer,
    APP_SPEC.structs,
  ) as InboundQueuedTransfer;
}

export type OutboundQueuedTransfer = {
  timestamp: bigint;
  amount: TrimmedAmount;
  recipientChain: number;
  recipient: Uint8Array;
  sender: string;
  transceiverInstructions: [bigint, Uint8Array][];
};

/**
 * Converts the ABI tuple representation of a OutboundQueuedTransfer to the struct representation
 */
export function OutboundQueuedTransferFromTuple(
  abiTuple: [bigint, [bigint, number], number, Uint8Array, string, [bigint, Uint8Array][]],
) {
  return getABIStructFromABITuple(
    abiTuple,
    APP_SPEC.structs.OutboundQueuedTransfer,
    APP_SPEC.structs,
  ) as OutboundQueuedTransfer;
}

export type NttManagerPeer = {
  peerContract: Uint8Array;
  decimals: number;
};

/**
 * Converts the ABI tuple representation of a NttManagerPeer to the struct representation
 */
export function NttManagerPeerFromTuple(abiTuple: [Uint8Array, number]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.NttManagerPeer, APP_SPEC.structs) as NttManagerPeer;
}

export type MessageReceived = {
  id: Uint8Array;
  userAddress: Uint8Array;
  sourceChainId: number;
  sourceAddress: Uint8Array;
  handlerAddress: Uint8Array;
  payload: Uint8Array;
};

/**
 * Converts the ABI tuple representation of a MessageReceived to the struct representation
 */
export function MessageReceivedFromTuple(
  abiTuple: [Uint8Array, Uint8Array, number, Uint8Array, Uint8Array, Uint8Array],
) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.MessageReceived, APP_SPEC.structs) as MessageReceived;
}

export type TrimmedAmount = {
  amount: bigint;
  decimals: number;
};

/**
 * Converts the ABI tuple representation of a TrimmedAmount to the struct representation
 */
export function TrimmedAmountFromTuple(abiTuple: [bigint, number]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.TrimmedAmount, APP_SPEC.structs) as TrimmedAmount;
}

/**
 * The argument types for the NttManager contract
 */
export type NttManagerArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    "create(uint64,uint16,uint64,uint64)void": {
      nttToken: bigint | number;
      chainId: bigint | number;
      threshold: bigint | number;
      minUpgradeDelay: bigint | number;
    };
    "initialise(address,uint64)void": {
      admin: string;
      transceiverManager: bigint | number;
    };
    "pause()void": Record<string, never>;
    "unpause()void": Record<string, never>;
    "set_transceiver_manager(address,uint64)void": {
      adminInTransceiverManager: string;
      transceiverManager: bigint | number;
    };
    "set_threshold(uint64)void": {
      newThreshold: bigint | number;
    };
    "set_ntt_manager_peer(uint16,byte[32],uint8)void": {
      peerChainId: bigint | number;
      peerContract: Uint8Array;
      peerDecimals: bigint | number;
    };
    "transfer(pay,axfer,uint64,uint16,byte[32])byte[32]": {
      feePayment: AppMethodCallTransactionArgument;
      sendToken: AppMethodCallTransactionArgument;
      amount: bigint | number;
      recipientChain: bigint | number;
      recipient: Uint8Array;
    };
    "transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]": {
      feePayment: AppMethodCallTransactionArgument;
      sendToken: AppMethodCallTransactionArgument;
      amount: bigint | number;
      recipientChain: bigint | number;
      recipient: Uint8Array;
      shouldQueue: boolean;
      transceiverInstructions: [bigint | number, Uint8Array][];
    };
    "complete_outbound_queued_transfer(pay,byte[32])byte[32]": {
      feePayment: AppMethodCallTransactionArgument;
      messageId: Uint8Array;
    };
    "cancel_outbound_queued_transfer(byte[32])void": {
      messageId: Uint8Array;
    };
    "complete_inbound_queued_transfer(byte[32])void": {
      messageDigest: Uint8Array;
    };
    "ntt_manager_admin_role()byte[16]": Record<string, never>;
    "pauser_role()byte[16]": Record<string, never>;
    "unpauser_role()byte[16]": Record<string, never>;
    "get_ntt_manager_peer(uint16)(byte[32],uint8)": {
      chainId: bigint | number;
    };
    "execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void": {
      /**
       * The message to execute
       */
      message: MessageReceived;
    };
    "is_message_approved(byte[32])bool": {
      /**
       * The message digest
       */
      messageDigest: Uint8Array;
    };
    "is_message_executed(byte[32])bool": {
      /**
       * The message digest
       */
      messageDigest: Uint8Array;
    };
    "set_outbound_rate_limit(uint256)void": {
      /**
       * The rate limit to set
       */
      newLimit: bigint | number;
    };
    "set_outbound_rate_duration(uint64)void": {
      /**
       * The duration to set
       */
      newDuration: bigint | number;
    };
    "set_inbound_rate_limit(uint16,uint256)void": {
      /**
       * The chain id to set the limit for
       */
      chainId: bigint | number;
      /**
       * The limit to set
       */
      newLimit: bigint | number;
    };
    "set_inbound_rate_duration(uint16,uint64)void": {
      /**
       * The chain id to set the duration for
       */
      chainId: bigint | number;
      /**
       * The duration to set
       */
      newDuration: bigint | number;
    };
    "get_current_outbound_capacity()uint256": Record<string, never>;
    "get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))": {
      /**
       * The Ntt defined identifier for a message to send
       */
      messageId: Uint8Array;
    };
    "get_current_inbound_capacity(uint16)uint256": {
      /**
       * The chain id to get the capacity of
       */
      chainId: bigint | number;
    };
    "get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))": {
      /**
       * Unique identifier of the message received.
       */
      messageDigest: Uint8Array;
    };
    "inbound_bucket_id(uint16)byte[32]": {
      chainId: bigint | number;
    };
    "outbound_bucket_id()byte[32]": Record<string, never>;
    "rate_limiter_manager_role()byte[16]": Record<string, never>;
    "get_current_capacity(byte[32])uint256": {
      /**
       * The bucket to get the current capacity for.
       */
      bucketId: Uint8Array;
    };
    "has_capacity(byte[32],uint256)bool": {
      /**
       * The bucket to consume from.
       */
      bucketId: Uint8Array;
      /**
       * The amount to consume.
       */
      amount: bigint | number;
    };
    "get_rate_limit(byte[32])uint256": {
      /**
       * The bucket to get the rate limit of
       */
      bucketId: Uint8Array;
    };
    "get_rate_duration(byte[32])uint64": {
      /**
       * The bucket to get the rate duration of
       */
      bucketId: Uint8Array;
    };
    "update_min_upgrade_delay(uint64,uint64)void": {
      /**
       * The new delay
       */
      minUpgradeDelay: bigint | number;
      /**
       * The timestamp to schedule the change
       */
      timestamp: bigint | number;
    };
    "schedule_contract_upgrade(byte[32],uint64)void": {
      /**
       * The SHA256 of the new program
       */
      programSha256: Uint8Array;
      /**
       * The timestamp to schedule the upgrade
       */
      timestamp: bigint | number;
    };
    "cancel_contract_upgrade()void": Record<string, never>;
    "complete_contract_upgrade()void": Record<string, never>;
    "upgradable_admin_role()byte[16]": Record<string, never>;
    "max_for_min_upgrade_delay()uint64": Record<string, never>;
    "get_active_min_upgrade_delay()uint64": Record<string, never>;
    "grant_role(byte[16],address)void": {
      /**
       * The role to grant
       */
      role: Uint8Array;
      /**
       * The account to grant the role to
       */
      account: string;
    };
    "revoke_role(byte[16],address)void": {
      /**
       * The role to revoke
       */
      role: Uint8Array;
      /**
       * The account to revoke the role from
       */
      account: string;
    };
    "renounce_role(byte[16])void": {
      /**
       * The role to renounce
       */
      role: Uint8Array;
    };
    "default_admin_role()byte[16]": Record<string, never>;
    "has_role(byte[16],address)bool": {
      /**
       * The role to check
       */
      role: Uint8Array;
      /**
       * The account to check
       */
      account: string;
    };
    "get_role_admin(byte[16])byte[16]": {
      /**
       * The role to get its admin of
       */
      role: Uint8Array;
    };
  };
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    "create(uint64,uint16,uint64,uint64)void": [
      nttToken: bigint | number,
      chainId: bigint | number,
      threshold: bigint | number,
      minUpgradeDelay: bigint | number,
    ];
    "initialise(address,uint64)void": [admin: string, transceiverManager: bigint | number];
    "pause()void": [];
    "unpause()void": [];
    "set_transceiver_manager(address,uint64)void": [
      adminInTransceiverManager: string,
      transceiverManager: bigint | number,
    ];
    "set_threshold(uint64)void": [newThreshold: bigint | number];
    "set_ntt_manager_peer(uint16,byte[32],uint8)void": [
      peerChainId: bigint | number,
      peerContract: Uint8Array,
      peerDecimals: bigint | number,
    ];
    "transfer(pay,axfer,uint64,uint16,byte[32])byte[32]": [
      feePayment: AppMethodCallTransactionArgument,
      sendToken: AppMethodCallTransactionArgument,
      amount: bigint | number,
      recipientChain: bigint | number,
      recipient: Uint8Array,
    ];
    "transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]": [
      feePayment: AppMethodCallTransactionArgument,
      sendToken: AppMethodCallTransactionArgument,
      amount: bigint | number,
      recipientChain: bigint | number,
      recipient: Uint8Array,
      shouldQueue: boolean,
      transceiverInstructions: [bigint | number, Uint8Array][],
    ];
    "complete_outbound_queued_transfer(pay,byte[32])byte[32]": [
      feePayment: AppMethodCallTransactionArgument,
      messageId: Uint8Array,
    ];
    "cancel_outbound_queued_transfer(byte[32])void": [messageId: Uint8Array];
    "complete_inbound_queued_transfer(byte[32])void": [messageDigest: Uint8Array];
    "ntt_manager_admin_role()byte[16]": [];
    "pauser_role()byte[16]": [];
    "unpauser_role()byte[16]": [];
    "get_ntt_manager_peer(uint16)(byte[32],uint8)": [chainId: bigint | number];
    "execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void": [message: MessageReceived];
    "is_message_approved(byte[32])bool": [messageDigest: Uint8Array];
    "is_message_executed(byte[32])bool": [messageDigest: Uint8Array];
    "set_outbound_rate_limit(uint256)void": [newLimit: bigint | number];
    "set_outbound_rate_duration(uint64)void": [newDuration: bigint | number];
    "set_inbound_rate_limit(uint16,uint256)void": [chainId: bigint | number, newLimit: bigint | number];
    "set_inbound_rate_duration(uint16,uint64)void": [chainId: bigint | number, newDuration: bigint | number];
    "get_current_outbound_capacity()uint256": [];
    "get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))": [
      messageId: Uint8Array,
    ];
    "get_current_inbound_capacity(uint16)uint256": [chainId: bigint | number];
    "get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))": [messageDigest: Uint8Array];
    "inbound_bucket_id(uint16)byte[32]": [chainId: bigint | number];
    "outbound_bucket_id()byte[32]": [];
    "rate_limiter_manager_role()byte[16]": [];
    "get_current_capacity(byte[32])uint256": [bucketId: Uint8Array];
    "has_capacity(byte[32],uint256)bool": [bucketId: Uint8Array, amount: bigint | number];
    "get_rate_limit(byte[32])uint256": [bucketId: Uint8Array];
    "get_rate_duration(byte[32])uint64": [bucketId: Uint8Array];
    "update_min_upgrade_delay(uint64,uint64)void": [minUpgradeDelay: bigint | number, timestamp: bigint | number];
    "schedule_contract_upgrade(byte[32],uint64)void": [programSha256: Uint8Array, timestamp: bigint | number];
    "cancel_contract_upgrade()void": [];
    "complete_contract_upgrade()void": [];
    "upgradable_admin_role()byte[16]": [];
    "max_for_min_upgrade_delay()uint64": [];
    "get_active_min_upgrade_delay()uint64": [];
    "grant_role(byte[16],address)void": [role: Uint8Array, account: string];
    "revoke_role(byte[16],address)void": [role: Uint8Array, account: string];
    "renounce_role(byte[16])void": [role: Uint8Array];
    "default_admin_role()byte[16]": [];
    "has_role(byte[16],address)bool": [role: Uint8Array, account: string];
    "get_role_admin(byte[16])byte[16]": [role: Uint8Array];
  };
};

/**
 * The return type for each method
 */
export type NttManagerReturns = {
  "create(uint64,uint16,uint64,uint64)void": void;
  "initialise(address,uint64)void": void;
  "pause()void": void;
  "unpause()void": void;
  "set_transceiver_manager(address,uint64)void": void;
  "set_threshold(uint64)void": void;
  "set_ntt_manager_peer(uint16,byte[32],uint8)void": void;
  "transfer(pay,axfer,uint64,uint16,byte[32])byte[32]": Uint8Array;
  "transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]": Uint8Array;
  "complete_outbound_queued_transfer(pay,byte[32])byte[32]": Uint8Array;
  "cancel_outbound_queued_transfer(byte[32])void": void;
  "complete_inbound_queued_transfer(byte[32])void": void;
  "ntt_manager_admin_role()byte[16]": Uint8Array;
  "pauser_role()byte[16]": Uint8Array;
  "unpauser_role()byte[16]": Uint8Array;
  "get_ntt_manager_peer(uint16)(byte[32],uint8)": NttManagerPeer;
  "execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void": void;
  "is_message_approved(byte[32])bool": boolean;
  "is_message_executed(byte[32])bool": boolean;
  "set_outbound_rate_limit(uint256)void": void;
  "set_outbound_rate_duration(uint64)void": void;
  "set_inbound_rate_limit(uint16,uint256)void": void;
  "set_inbound_rate_duration(uint16,uint64)void": void;
  "get_current_outbound_capacity()uint256": bigint;
  "get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))": [
    boolean,
    [bigint, [bigint, number], number, Uint8Array, string, [bigint, Uint8Array][]],
  ];
  "get_current_inbound_capacity(uint16)uint256": bigint;
  "get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))": [
    boolean,
    [bigint, [bigint, number], number, string],
  ];
  "inbound_bucket_id(uint16)byte[32]": Uint8Array;
  "outbound_bucket_id()byte[32]": Uint8Array;
  "rate_limiter_manager_role()byte[16]": Uint8Array;
  "get_current_capacity(byte[32])uint256": bigint;
  "has_capacity(byte[32],uint256)bool": boolean;
  "get_rate_limit(byte[32])uint256": bigint;
  "get_rate_duration(byte[32])uint64": bigint;
  "update_min_upgrade_delay(uint64,uint64)void": void;
  "schedule_contract_upgrade(byte[32],uint64)void": void;
  "cancel_contract_upgrade()void": void;
  "complete_contract_upgrade()void": void;
  "upgradable_admin_role()byte[16]": Uint8Array;
  "max_for_min_upgrade_delay()uint64": bigint;
  "get_active_min_upgrade_delay()uint64": bigint;
  "grant_role(byte[16],address)void": void;
  "revoke_role(byte[16],address)void": void;
  "renounce_role(byte[16])void": void;
  "default_admin_role()byte[16]": Uint8Array;
  "has_role(byte[16],address)bool": boolean;
  "get_role_admin(byte[16])byte[16]": Uint8Array;
};

/**
 * Defines the types of available calls and state of the NttManager smart contract.
 */
export type NttManagerTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods: Record<
    "create(uint64,uint16,uint64,uint64)void" | "create",
    {
      argsObj: NttManagerArgs["obj"]["create(uint64,uint16,uint64,uint64)void"];
      argsTuple: NttManagerArgs["tuple"]["create(uint64,uint16,uint64,uint64)void"];
      returns: NttManagerReturns["create(uint64,uint16,uint64,uint64)void"];
    }
  > &
    Record<
      "initialise(address,uint64)void" | "initialise",
      {
        argsObj: NttManagerArgs["obj"]["initialise(address,uint64)void"];
        argsTuple: NttManagerArgs["tuple"]["initialise(address,uint64)void"];
        returns: NttManagerReturns["initialise(address,uint64)void"];
      }
    > &
    Record<
      "pause()void" | "pause",
      {
        argsObj: NttManagerArgs["obj"]["pause()void"];
        argsTuple: NttManagerArgs["tuple"]["pause()void"];
        returns: NttManagerReturns["pause()void"];
      }
    > &
    Record<
      "unpause()void" | "unpause",
      {
        argsObj: NttManagerArgs["obj"]["unpause()void"];
        argsTuple: NttManagerArgs["tuple"]["unpause()void"];
        returns: NttManagerReturns["unpause()void"];
      }
    > &
    Record<
      "set_transceiver_manager(address,uint64)void" | "set_transceiver_manager",
      {
        argsObj: NttManagerArgs["obj"]["set_transceiver_manager(address,uint64)void"];
        argsTuple: NttManagerArgs["tuple"]["set_transceiver_manager(address,uint64)void"];
        returns: NttManagerReturns["set_transceiver_manager(address,uint64)void"];
      }
    > &
    Record<
      "set_threshold(uint64)void" | "set_threshold",
      {
        argsObj: NttManagerArgs["obj"]["set_threshold(uint64)void"];
        argsTuple: NttManagerArgs["tuple"]["set_threshold(uint64)void"];
        returns: NttManagerReturns["set_threshold(uint64)void"];
      }
    > &
    Record<
      "set_ntt_manager_peer(uint16,byte[32],uint8)void" | "set_ntt_manager_peer",
      {
        argsObj: NttManagerArgs["obj"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"];
        argsTuple: NttManagerArgs["tuple"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"];
        returns: NttManagerReturns["set_ntt_manager_peer(uint16,byte[32],uint8)void"];
      }
    > &
    Record<
      "transfer(pay,axfer,uint64,uint16,byte[32])byte[32]" | "transfer",
      {
        argsObj: NttManagerArgs["obj"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"];
        argsTuple: NttManagerArgs["tuple"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"];
        returns: NttManagerReturns["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"];
      }
    > &
    Record<
      "transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]" | "transfer_full",
      {
        argsObj: NttManagerArgs["obj"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"];
        argsTuple: NttManagerArgs["tuple"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"];
        returns: NttManagerReturns["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"];
      }
    > &
    Record<
      "complete_outbound_queued_transfer(pay,byte[32])byte[32]" | "complete_outbound_queued_transfer",
      {
        argsObj: NttManagerArgs["obj"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"];
        argsTuple: NttManagerArgs["tuple"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"];
        returns: NttManagerReturns["complete_outbound_queued_transfer(pay,byte[32])byte[32]"];
      }
    > &
    Record<
      "cancel_outbound_queued_transfer(byte[32])void" | "cancel_outbound_queued_transfer",
      {
        argsObj: NttManagerArgs["obj"]["cancel_outbound_queued_transfer(byte[32])void"];
        argsTuple: NttManagerArgs["tuple"]["cancel_outbound_queued_transfer(byte[32])void"];
        returns: NttManagerReturns["cancel_outbound_queued_transfer(byte[32])void"];
      }
    > &
    Record<
      "complete_inbound_queued_transfer(byte[32])void" | "complete_inbound_queued_transfer",
      {
        argsObj: NttManagerArgs["obj"]["complete_inbound_queued_transfer(byte[32])void"];
        argsTuple: NttManagerArgs["tuple"]["complete_inbound_queued_transfer(byte[32])void"];
        returns: NttManagerReturns["complete_inbound_queued_transfer(byte[32])void"];
      }
    > &
    Record<
      "ntt_manager_admin_role()byte[16]" | "ntt_manager_admin_role",
      {
        argsObj: NttManagerArgs["obj"]["ntt_manager_admin_role()byte[16]"];
        argsTuple: NttManagerArgs["tuple"]["ntt_manager_admin_role()byte[16]"];
        returns: NttManagerReturns["ntt_manager_admin_role()byte[16]"];
      }
    > &
    Record<
      "pauser_role()byte[16]" | "pauser_role",
      {
        argsObj: NttManagerArgs["obj"]["pauser_role()byte[16]"];
        argsTuple: NttManagerArgs["tuple"]["pauser_role()byte[16]"];
        returns: NttManagerReturns["pauser_role()byte[16]"];
      }
    > &
    Record<
      "unpauser_role()byte[16]" | "unpauser_role",
      {
        argsObj: NttManagerArgs["obj"]["unpauser_role()byte[16]"];
        argsTuple: NttManagerArgs["tuple"]["unpauser_role()byte[16]"];
        returns: NttManagerReturns["unpauser_role()byte[16]"];
      }
    > &
    Record<
      "get_ntt_manager_peer(uint16)(byte[32],uint8)" | "get_ntt_manager_peer",
      {
        argsObj: NttManagerArgs["obj"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"];
        argsTuple: NttManagerArgs["tuple"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"];
        returns: NttManagerReturns["get_ntt_manager_peer(uint16)(byte[32],uint8)"];
      }
    > &
    Record<
      "execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void" | "execute_message",
      {
        argsObj: NttManagerArgs["obj"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"];
        argsTuple: NttManagerArgs["tuple"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"];
        returns: NttManagerReturns["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"];
      }
    > &
    Record<
      "is_message_approved(byte[32])bool" | "is_message_approved",
      {
        argsObj: NttManagerArgs["obj"]["is_message_approved(byte[32])bool"];
        argsTuple: NttManagerArgs["tuple"]["is_message_approved(byte[32])bool"];
        returns: NttManagerReturns["is_message_approved(byte[32])bool"];
      }
    > &
    Record<
      "is_message_executed(byte[32])bool" | "is_message_executed",
      {
        argsObj: NttManagerArgs["obj"]["is_message_executed(byte[32])bool"];
        argsTuple: NttManagerArgs["tuple"]["is_message_executed(byte[32])bool"];
        returns: NttManagerReturns["is_message_executed(byte[32])bool"];
      }
    > &
    Record<
      "set_outbound_rate_limit(uint256)void" | "set_outbound_rate_limit",
      {
        argsObj: NttManagerArgs["obj"]["set_outbound_rate_limit(uint256)void"];
        argsTuple: NttManagerArgs["tuple"]["set_outbound_rate_limit(uint256)void"];
        returns: NttManagerReturns["set_outbound_rate_limit(uint256)void"];
      }
    > &
    Record<
      "set_outbound_rate_duration(uint64)void" | "set_outbound_rate_duration",
      {
        argsObj: NttManagerArgs["obj"]["set_outbound_rate_duration(uint64)void"];
        argsTuple: NttManagerArgs["tuple"]["set_outbound_rate_duration(uint64)void"];
        returns: NttManagerReturns["set_outbound_rate_duration(uint64)void"];
      }
    > &
    Record<
      "set_inbound_rate_limit(uint16,uint256)void" | "set_inbound_rate_limit",
      {
        argsObj: NttManagerArgs["obj"]["set_inbound_rate_limit(uint16,uint256)void"];
        argsTuple: NttManagerArgs["tuple"]["set_inbound_rate_limit(uint16,uint256)void"];
        returns: NttManagerReturns["set_inbound_rate_limit(uint16,uint256)void"];
      }
    > &
    Record<
      "set_inbound_rate_duration(uint16,uint64)void" | "set_inbound_rate_duration",
      {
        argsObj: NttManagerArgs["obj"]["set_inbound_rate_duration(uint16,uint64)void"];
        argsTuple: NttManagerArgs["tuple"]["set_inbound_rate_duration(uint16,uint64)void"];
        returns: NttManagerReturns["set_inbound_rate_duration(uint16,uint64)void"];
      }
    > &
    Record<
      "get_current_outbound_capacity()uint256" | "get_current_outbound_capacity",
      {
        argsObj: NttManagerArgs["obj"]["get_current_outbound_capacity()uint256"];
        argsTuple: NttManagerArgs["tuple"]["get_current_outbound_capacity()uint256"];
        returns: NttManagerReturns["get_current_outbound_capacity()uint256"];
      }
    > &
    Record<
      | "get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"
      | "get_outbound_queued_transfer",
      {
        argsObj: NttManagerArgs["obj"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"];
        argsTuple: NttManagerArgs["tuple"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"];
        /**
         * Tuple of whether the transfer can be completed and the details of the transfer request.
         */
        returns: NttManagerReturns["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"];
      }
    > &
    Record<
      "get_current_inbound_capacity(uint16)uint256" | "get_current_inbound_capacity",
      {
        argsObj: NttManagerArgs["obj"]["get_current_inbound_capacity(uint16)uint256"];
        argsTuple: NttManagerArgs["tuple"]["get_current_inbound_capacity(uint16)uint256"];
        returns: NttManagerReturns["get_current_inbound_capacity(uint16)uint256"];
      }
    > &
    Record<
      | "get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"
      | "get_inbound_queued_transfer",
      {
        argsObj: NttManagerArgs["obj"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"];
        argsTuple: NttManagerArgs["tuple"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"];
        /**
         * Tuple of whether the transfer can be completed and the details of the transfer request.
         */
        returns: NttManagerReturns["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"];
      }
    > &
    Record<
      "inbound_bucket_id(uint16)byte[32]" | "inbound_bucket_id",
      {
        argsObj: NttManagerArgs["obj"]["inbound_bucket_id(uint16)byte[32]"];
        argsTuple: NttManagerArgs["tuple"]["inbound_bucket_id(uint16)byte[32]"];
        returns: NttManagerReturns["inbound_bucket_id(uint16)byte[32]"];
      }
    > &
    Record<
      "outbound_bucket_id()byte[32]" | "outbound_bucket_id",
      {
        argsObj: NttManagerArgs["obj"]["outbound_bucket_id()byte[32]"];
        argsTuple: NttManagerArgs["tuple"]["outbound_bucket_id()byte[32]"];
        returns: NttManagerReturns["outbound_bucket_id()byte[32]"];
      }
    > &
    Record<
      "rate_limiter_manager_role()byte[16]" | "rate_limiter_manager_role",
      {
        argsObj: NttManagerArgs["obj"]["rate_limiter_manager_role()byte[16]"];
        argsTuple: NttManagerArgs["tuple"]["rate_limiter_manager_role()byte[16]"];
        returns: NttManagerReturns["rate_limiter_manager_role()byte[16]"];
      }
    > &
    Record<
      "get_current_capacity(byte[32])uint256" | "get_current_capacity",
      {
        argsObj: NttManagerArgs["obj"]["get_current_capacity(byte[32])uint256"];
        argsTuple: NttManagerArgs["tuple"]["get_current_capacity(byte[32])uint256"];
        returns: NttManagerReturns["get_current_capacity(byte[32])uint256"];
      }
    > &
    Record<
      "has_capacity(byte[32],uint256)bool" | "has_capacity",
      {
        argsObj: NttManagerArgs["obj"]["has_capacity(byte[32],uint256)bool"];
        argsTuple: NttManagerArgs["tuple"]["has_capacity(byte[32],uint256)bool"];
        returns: NttManagerReturns["has_capacity(byte[32],uint256)bool"];
      }
    > &
    Record<
      "get_rate_limit(byte[32])uint256" | "get_rate_limit",
      {
        argsObj: NttManagerArgs["obj"]["get_rate_limit(byte[32])uint256"];
        argsTuple: NttManagerArgs["tuple"]["get_rate_limit(byte[32])uint256"];
        returns: NttManagerReturns["get_rate_limit(byte[32])uint256"];
      }
    > &
    Record<
      "get_rate_duration(byte[32])uint64" | "get_rate_duration",
      {
        argsObj: NttManagerArgs["obj"]["get_rate_duration(byte[32])uint64"];
        argsTuple: NttManagerArgs["tuple"]["get_rate_duration(byte[32])uint64"];
        returns: NttManagerReturns["get_rate_duration(byte[32])uint64"];
      }
    > &
    Record<
      "update_min_upgrade_delay(uint64,uint64)void" | "update_min_upgrade_delay",
      {
        argsObj: NttManagerArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"];
        argsTuple: NttManagerArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"];
        returns: NttManagerReturns["update_min_upgrade_delay(uint64,uint64)void"];
      }
    > &
    Record<
      "schedule_contract_upgrade(byte[32],uint64)void" | "schedule_contract_upgrade",
      {
        argsObj: NttManagerArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"];
        argsTuple: NttManagerArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"];
        returns: NttManagerReturns["schedule_contract_upgrade(byte[32],uint64)void"];
      }
    > &
    Record<
      "cancel_contract_upgrade()void" | "cancel_contract_upgrade",
      {
        argsObj: NttManagerArgs["obj"]["cancel_contract_upgrade()void"];
        argsTuple: NttManagerArgs["tuple"]["cancel_contract_upgrade()void"];
        returns: NttManagerReturns["cancel_contract_upgrade()void"];
      }
    > &
    Record<
      "complete_contract_upgrade()void" | "complete_contract_upgrade",
      {
        argsObj: NttManagerArgs["obj"]["complete_contract_upgrade()void"];
        argsTuple: NttManagerArgs["tuple"]["complete_contract_upgrade()void"];
        returns: NttManagerReturns["complete_contract_upgrade()void"];
      }
    > &
    Record<
      "upgradable_admin_role()byte[16]" | "upgradable_admin_role",
      {
        argsObj: NttManagerArgs["obj"]["upgradable_admin_role()byte[16]"];
        argsTuple: NttManagerArgs["tuple"]["upgradable_admin_role()byte[16]"];
        /**
         * Role bytes of length 16
         */
        returns: NttManagerReturns["upgradable_admin_role()byte[16]"];
      }
    > &
    Record<
      "max_for_min_upgrade_delay()uint64" | "max_for_min_upgrade_delay",
      {
        argsObj: NttManagerArgs["obj"]["max_for_min_upgrade_delay()uint64"];
        argsTuple: NttManagerArgs["tuple"]["max_for_min_upgrade_delay()uint64"];
        /**
         * The maximum minimum upgrade delay
         */
        returns: NttManagerReturns["max_for_min_upgrade_delay()uint64"];
      }
    > &
    Record<
      "get_active_min_upgrade_delay()uint64" | "get_active_min_upgrade_delay",
      {
        argsObj: NttManagerArgs["obj"]["get_active_min_upgrade_delay()uint64"];
        argsTuple: NttManagerArgs["tuple"]["get_active_min_upgrade_delay()uint64"];
        /**
         * The active minimum upgrade delay
         */
        returns: NttManagerReturns["get_active_min_upgrade_delay()uint64"];
      }
    > &
    Record<
      "grant_role(byte[16],address)void" | "grant_role",
      {
        argsObj: NttManagerArgs["obj"]["grant_role(byte[16],address)void"];
        argsTuple: NttManagerArgs["tuple"]["grant_role(byte[16],address)void"];
        returns: NttManagerReturns["grant_role(byte[16],address)void"];
      }
    > &
    Record<
      "revoke_role(byte[16],address)void" | "revoke_role",
      {
        argsObj: NttManagerArgs["obj"]["revoke_role(byte[16],address)void"];
        argsTuple: NttManagerArgs["tuple"]["revoke_role(byte[16],address)void"];
        returns: NttManagerReturns["revoke_role(byte[16],address)void"];
      }
    > &
    Record<
      "renounce_role(byte[16])void" | "renounce_role",
      {
        argsObj: NttManagerArgs["obj"]["renounce_role(byte[16])void"];
        argsTuple: NttManagerArgs["tuple"]["renounce_role(byte[16])void"];
        returns: NttManagerReturns["renounce_role(byte[16])void"];
      }
    > &
    Record<
      "default_admin_role()byte[16]" | "default_admin_role",
      {
        argsObj: NttManagerArgs["obj"]["default_admin_role()byte[16]"];
        argsTuple: NttManagerArgs["tuple"]["default_admin_role()byte[16]"];
        /**
         * Empty bytes of length 16
         */
        returns: NttManagerReturns["default_admin_role()byte[16]"];
      }
    > &
    Record<
      "has_role(byte[16],address)bool" | "has_role",
      {
        argsObj: NttManagerArgs["obj"]["has_role(byte[16],address)bool"];
        argsTuple: NttManagerArgs["tuple"]["has_role(byte[16],address)bool"];
        /**
         * Whether the account has been granted a role
         */
        returns: NttManagerReturns["has_role(byte[16],address)bool"];
      }
    > &
    Record<
      "get_role_admin(byte[16])byte[16]" | "get_role_admin",
      {
        argsObj: NttManagerArgs["obj"]["get_role_admin(byte[16])byte[16]"];
        argsTuple: NttManagerArgs["tuple"]["get_role_admin(byte[16])byte[16]"];
        /**
         * The role admin
         */
        returns: NttManagerReturns["get_role_admin(byte[16])byte[16]"];
      }
    >;
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        isInitialised: bigint;
        minUpgradeDelay: MinimumUpgradeDelay;
        scheduledContractUpgrade: ScheduledContractUpgrade;
        version: bigint;
        transceiverManager: bigint;
        threshold: bigint;
        isPaused: bigint;
        assetId: bigint;
        nttToken: bigint;
        messageSequence: bigint;
        chainId: number;
      };
      maps: {};
    };
    box: {
      keys: {};
      maps: {
        roles: Map<Uint8Array, Uint8Array>;
        addressesRoles: Map<AddressRoleKey, boolean>;
        rateLimitBuckets: Map<Uint8Array, RateLimitBucket>;
        outboundQueuedTransfers: Map<Uint8Array, OutboundQueuedTransfer>;
        inboundQueuedTransfers: Map<Uint8Array, InboundQueuedTransfer>;
        messagesExecuted: Map<Uint8Array, boolean>;
        nttManagerPeers: Map<bigint | number, NttManagerPeer>;
      };
    };
  };
};

/**
 * Defines the possible abi call signatures.
 */
export type NttManagerSignatures = keyof NttManagerTypes["methods"];
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type NttManagerNonVoidMethodSignatures = keyof NttManagerTypes["methods"] extends infer T
  ? T extends keyof NttManagerTypes["methods"]
    ? MethodReturn<T> extends void
      ? never
      : T
    : never
  : never;
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, "method" | "args" | "onComplete"> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
  }
>;
/**
 * Maps a method signature from the NttManager smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends NttManagerSignatures> = NttManagerTypes["methods"][TSignature][
  | "argsObj"
  | "argsTuple"];
/**
 * Maps a method signature from the NttManager smart contract to the method's return type
 */
export type MethodReturn<TSignature extends NttManagerSignatures> = NttManagerTypes["methods"][TSignature]["returns"];

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = NttManagerTypes["state"]["global"]["keys"];

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = NttManagerTypes["state"]["box"]["keys"];

/**
 * Defines supported create method params for this smart contract
 */
export type NttManagerCreateCallParams =
  | Expand<
      CallParams<
        | NttManagerArgs["obj"]["create(uint64,uint16,uint64,uint64)void"]
        | NttManagerArgs["tuple"]["create(uint64,uint16,uint64,uint64)void"]
      > & { method: "create" } & {
        onComplete?: OnApplicationComplete.NoOpOC;
      } & CreateSchema
    >
  | Expand<
      CallParams<
        | NttManagerArgs["obj"]["create(uint64,uint16,uint64,uint64)void"]
        | NttManagerArgs["tuple"]["create(uint64,uint16,uint64,uint64)void"]
      > & { method: "create(uint64,uint16,uint64,uint64)void" } & {
        onComplete?: OnApplicationComplete.NoOpOC;
      } & CreateSchema
    >;
/**
 * Defines supported update method params for this smart contract
 */
export type NttManagerUpdateCallParams =
  | Expand<
      CallParams<
        | NttManagerArgs["obj"]["complete_contract_upgrade()void"]
        | NttManagerArgs["tuple"]["complete_contract_upgrade()void"]
      > & { method: "complete_contract_upgrade" }
    >
  | Expand<
      CallParams<
        | NttManagerArgs["obj"]["complete_contract_upgrade()void"]
        | NttManagerArgs["tuple"]["complete_contract_upgrade()void"]
      > & { method: "complete_contract_upgrade()void" }
    >;
/**
 * Defines arguments required for the deploy method.
 */
export type NttManagerDeployParams = Expand<
  Omit<AppFactoryDeployParams, "createParams" | "updateParams" | "deleteParams"> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: NttManagerCreateCallParams;
    /**
     * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    updateParams?: NttManagerUpdateCallParams;
  }
>;

/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the NttManager smart contract
 */
export abstract class NttManagerParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<TParams extends NttManagerCreateCallParams & { method: string }>(params: TParams) {
        switch (params.method) {
          case "create":
          case "create(uint64,uint16,uint64,uint64)void":
            return NttManagerParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },

      /**
       * Constructs create ABI call params for the NttManager smart contract using the create(uint64,uint16,uint64,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(
        params: CallParams<
          | NttManagerArgs["obj"]["create(uint64,uint16,uint64,uint64)void"]
          | NttManagerArgs["tuple"]["create(uint64,uint16,uint64,uint64)void"]
        > &
          AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
          },
      ): AppClientMethodCallParams &
        AppClientCompilationParams & {
          onComplete?: OnApplicationComplete.NoOpOC;
        } {
        return {
          ...params,
          method: "create(uint64,uint16,uint64,uint64)void" as const,
          args: Array.isArray(params.args)
            ? params.args
            : [params.args.nttToken, params.args.chainId, params.args.threshold, params.args.minUpgradeDelay],
        };
      },
    };
  }

  /**
   * Gets available update ABI call param factories
   */
  static get update() {
    return {
      _resolveByMethod<TParams extends NttManagerUpdateCallParams & { method: string }>(params: TParams) {
        switch (params.method) {
          case "complete_contract_upgrade":
          case "complete_contract_upgrade()void":
            return NttManagerParamsFactory.update.completeContractUpgrade(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },

      /**
       * Constructs update ABI call params for the NttManager smart contract using the complete_contract_upgrade()void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      completeContractUpgrade(
        params: CallParams<
          | NttManagerArgs["obj"]["complete_contract_upgrade()void"]
          | NttManagerArgs["tuple"]["complete_contract_upgrade()void"]
        > &
          AppClientCompilationParams,
      ): AppClientMethodCallParams & AppClientCompilationParams {
        return {
          ...params,
          method: "complete_contract_upgrade()void" as const,
          args: Array.isArray(params.args) ? params.args : [],
        };
      },
    };
  }

  /**
   * Constructs a no op call for the initialise(address,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initialise(
    params: CallParams<
      | NttManagerArgs["obj"]["initialise(address,uint64)void"]
      | NttManagerArgs["tuple"]["initialise(address,uint64)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "initialise(address,uint64)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.admin, params.args.transceiverManager],
    };
  }
  /**
   * Constructs a no op call for the pause()void ABI method
   *
   * Pause incoming and outgoing transfers in case of emergency.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static pause(
    params: CallParams<NttManagerArgs["obj"]["pause()void"] | NttManagerArgs["tuple"]["pause()void"]> & CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "pause()void" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the unpause()void ABI method
   *
   * Resume incoming and outgoing transfers after previous pause.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static unpause(
    params: CallParams<NttManagerArgs["obj"]["unpause()void"] | NttManagerArgs["tuple"]["unpause()void"]> &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "unpause()void" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the set_transceiver_manager(address,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setTransceiverManager(
    params: CallParams<
      | NttManagerArgs["obj"]["set_transceiver_manager(address,uint64)void"]
      | NttManagerArgs["tuple"]["set_transceiver_manager(address,uint64)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "set_transceiver_manager(address,uint64)void" as const,
      args: Array.isArray(params.args)
        ? params.args
        : [params.args.adminInTransceiverManager, params.args.transceiverManager],
    };
  }
  /**
   * Constructs a no op call for the set_threshold(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setThreshold(
    params: CallParams<
      NttManagerArgs["obj"]["set_threshold(uint64)void"] | NttManagerArgs["tuple"]["set_threshold(uint64)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "set_threshold(uint64)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newThreshold],
    };
  }
  /**
   * Constructs a no op call for the set_ntt_manager_peer(uint16,byte[32],uint8)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setNttManagerPeer(
    params: CallParams<
      | NttManagerArgs["obj"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
      | NttManagerArgs["tuple"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "set_ntt_manager_peer(uint16,byte[32],uint8)void" as const,
      args: Array.isArray(params.args)
        ? params.args
        : [params.args.peerChainId, params.args.peerContract, params.args.peerDecimals],
    };
  }
  /**
   * Constructs a no op call for the transfer(pay,axfer,uint64,uint16,byte[32])byte[32] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static transfer(
    params: CallParams<
      | NttManagerArgs["obj"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
      | NttManagerArgs["tuple"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "transfer(pay,axfer,uint64,uint16,byte[32])byte[32]" as const,
      args: Array.isArray(params.args)
        ? params.args
        : [
            params.args.feePayment,
            params.args.sendToken,
            params.args.amount,
            params.args.recipientChain,
            params.args.recipient,
          ],
    };
  }
  /**
   * Constructs a no op call for the transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static transferFull(
    params: CallParams<
      | NttManagerArgs["obj"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
      | NttManagerArgs["tuple"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]" as const,
      args: Array.isArray(params.args)
        ? params.args
        : [
            params.args.feePayment,
            params.args.sendToken,
            params.args.amount,
            params.args.recipientChain,
            params.args.recipient,
            params.args.shouldQueue,
            params.args.transceiverInstructions,
          ],
    };
  }
  /**
   * Constructs a no op call for the complete_outbound_queued_transfer(pay,byte[32])byte[32] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static completeOutboundQueuedTransfer(
    params: CallParams<
      | NttManagerArgs["obj"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
      | NttManagerArgs["tuple"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "complete_outbound_queued_transfer(pay,byte[32])byte[32]" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.feePayment, params.args.messageId],
    };
  }
  /**
   * Constructs a no op call for the cancel_outbound_queued_transfer(byte[32])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static cancelOutboundQueuedTransfer(
    params: CallParams<
      | NttManagerArgs["obj"]["cancel_outbound_queued_transfer(byte[32])void"]
      | NttManagerArgs["tuple"]["cancel_outbound_queued_transfer(byte[32])void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "cancel_outbound_queued_transfer(byte[32])void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.messageId],
    };
  }
  /**
   * Constructs a no op call for the complete_inbound_queued_transfer(byte[32])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static completeInboundQueuedTransfer(
    params: CallParams<
      | NttManagerArgs["obj"]["complete_inbound_queued_transfer(byte[32])void"]
      | NttManagerArgs["tuple"]["complete_inbound_queued_transfer(byte[32])void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "complete_inbound_queued_transfer(byte[32])void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.messageDigest],
    };
  }
  /**
   * Constructs a no op call for the ntt_manager_admin_role()byte[16] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static nttManagerAdminRole(
    params: CallParams<
      | NttManagerArgs["obj"]["ntt_manager_admin_role()byte[16]"]
      | NttManagerArgs["tuple"]["ntt_manager_admin_role()byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "ntt_manager_admin_role()byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the pauser_role()byte[16] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static pauserRole(
    params: CallParams<
      NttManagerArgs["obj"]["pauser_role()byte[16]"] | NttManagerArgs["tuple"]["pauser_role()byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "pauser_role()byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the unpauser_role()byte[16] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static unpauserRole(
    params: CallParams<
      NttManagerArgs["obj"]["unpauser_role()byte[16]"] | NttManagerArgs["tuple"]["unpauser_role()byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "unpauser_role()byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the get_ntt_manager_peer(uint16)(byte[32],uint8) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getNttManagerPeer(
    params: CallParams<
      | NttManagerArgs["obj"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
      | NttManagerArgs["tuple"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_ntt_manager_peer(uint16)(byte[32],uint8)" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.chainId],
    };
  }
  /**
   * Constructs a no op call for the execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void ABI method
   *
   * Execute a message once the threshold number of attestations has been reached.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static executeMessage(
    params: CallParams<
      | NttManagerArgs["obj"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
      | NttManagerArgs["tuple"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.message],
    };
  }
  /**
   * Constructs a no op call for the is_message_approved(byte[32])bool ABI method
   *
   * Returns whether a message has been approved.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isMessageApproved(
    params: CallParams<
      | NttManagerArgs["obj"]["is_message_approved(byte[32])bool"]
      | NttManagerArgs["tuple"]["is_message_approved(byte[32])bool"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "is_message_approved(byte[32])bool" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.messageDigest],
    };
  }
  /**
   * Constructs a no op call for the is_message_executed(byte[32])bool ABI method
   *
  * Returns whether a message has been executed.
  Note that a message can be executed without being approved if the threshold is increased after execution.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isMessageExecuted(
    params: CallParams<
      | NttManagerArgs["obj"]["is_message_executed(byte[32])bool"]
      | NttManagerArgs["tuple"]["is_message_executed(byte[32])bool"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "is_message_executed(byte[32])bool" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.messageDigest],
    };
  }
  /**
   * Constructs a no op call for the set_outbound_rate_limit(uint256)void ABI method
   *
   * Set limit for outbound bucket.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setOutboundRateLimit(
    params: CallParams<
      | NttManagerArgs["obj"]["set_outbound_rate_limit(uint256)void"]
      | NttManagerArgs["tuple"]["set_outbound_rate_limit(uint256)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "set_outbound_rate_limit(uint256)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newLimit],
    };
  }
  /**
   * Constructs a no op call for the set_outbound_rate_duration(uint64)void ABI method
   *
   * Set duration for outbound bucket.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setOutboundRateDuration(
    params: CallParams<
      | NttManagerArgs["obj"]["set_outbound_rate_duration(uint64)void"]
      | NttManagerArgs["tuple"]["set_outbound_rate_duration(uint64)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "set_outbound_rate_duration(uint64)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newDuration],
    };
  }
  /**
   * Constructs a no op call for the set_inbound_rate_limit(uint16,uint256)void ABI method
   *
   * Set limit for inbound bucket of the given chain.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setInboundRateLimit(
    params: CallParams<
      | NttManagerArgs["obj"]["set_inbound_rate_limit(uint16,uint256)void"]
      | NttManagerArgs["tuple"]["set_inbound_rate_limit(uint16,uint256)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "set_inbound_rate_limit(uint16,uint256)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.chainId, params.args.newLimit],
    };
  }
  /**
   * Constructs a no op call for the set_inbound_rate_duration(uint16,uint64)void ABI method
   *
   * Set duration for inbound bucket of the given chain.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setInboundRateDuration(
    params: CallParams<
      | NttManagerArgs["obj"]["set_inbound_rate_duration(uint16,uint64)void"]
      | NttManagerArgs["tuple"]["set_inbound_rate_duration(uint16,uint64)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "set_inbound_rate_duration(uint16,uint64)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.chainId, params.args.newDuration],
    };
  }
  /**
   * Constructs a no op call for the get_current_outbound_capacity()uint256 ABI method
   *
   * Returns the current capacity of the outbound.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getCurrentOutboundCapacity(
    params: CallParams<
      | NttManagerArgs["obj"]["get_current_outbound_capacity()uint256"]
      | NttManagerArgs["tuple"]["get_current_outbound_capacity()uint256"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_current_outbound_capacity()uint256" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[])) ABI method
   *
   * Get the details of an outbound queued transfer.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getOutboundQueuedTransfer(
    params: CallParams<
      | NttManagerArgs["obj"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
      | NttManagerArgs["tuple"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method:
        "get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.messageId],
    };
  }
  /**
   * Constructs a no op call for the get_current_inbound_capacity(uint16)uint256 ABI method
   *
   * Returns the current capacity of the inbound bucket of the given chain.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getCurrentInboundCapacity(
    params: CallParams<
      | NttManagerArgs["obj"]["get_current_inbound_capacity(uint16)uint256"]
      | NttManagerArgs["tuple"]["get_current_inbound_capacity(uint16)uint256"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_current_inbound_capacity(uint16)uint256" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.chainId],
    };
  }
  /**
   * Constructs a no op call for the get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address)) ABI method
   *
   * Get the details of an inbound queued transfer.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getInboundQueuedTransfer(
    params: CallParams<
      | NttManagerArgs["obj"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
      | NttManagerArgs["tuple"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.messageDigest],
    };
  }
  /**
   * Constructs a no op call for the inbound_bucket_id(uint16)byte[32] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static inboundBucketId(
    params: CallParams<
      | NttManagerArgs["obj"]["inbound_bucket_id(uint16)byte[32]"]
      | NttManagerArgs["tuple"]["inbound_bucket_id(uint16)byte[32]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "inbound_bucket_id(uint16)byte[32]" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.chainId],
    };
  }
  /**
   * Constructs a no op call for the outbound_bucket_id()byte[32] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static outboundBucketId(
    params: CallParams<
      NttManagerArgs["obj"]["outbound_bucket_id()byte[32]"] | NttManagerArgs["tuple"]["outbound_bucket_id()byte[32]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "outbound_bucket_id()byte[32]" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the rate_limiter_manager_role()byte[16] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static rateLimiterManagerRole(
    params: CallParams<
      | NttManagerArgs["obj"]["rate_limiter_manager_role()byte[16]"]
      | NttManagerArgs["tuple"]["rate_limiter_manager_role()byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "rate_limiter_manager_role()byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the get_current_capacity(byte[32])uint256 ABI method
   *
  * Returns the current capacity of the bucket were it to be updated.
  If you call this method (as opposed to simulate) then the capacity will be updated on chain.
  You should NOT use this method to determine if there is sufficient capacity because a `duration` of zero is interpreted as an infinite bucket regardless of the `current_capacity. Instead, use `has_capacity()`.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getCurrentCapacity(
    params: CallParams<
      | NttManagerArgs["obj"]["get_current_capacity(byte[32])uint256"]
      | NttManagerArgs["tuple"]["get_current_capacity(byte[32])uint256"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_current_capacity(byte[32])uint256" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.bucketId],
    };
  }
  /**
   * Constructs a no op call for the has_capacity(byte[32],uint256)bool ABI method
   *
  * Returns whether there's sufficient capacity inside bucket for amount.
  If you call this method (as opposed to simulate) then the capacity will be updated on chain.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static hasCapacity(
    params: CallParams<
      | NttManagerArgs["obj"]["has_capacity(byte[32],uint256)bool"]
      | NttManagerArgs["tuple"]["has_capacity(byte[32],uint256)bool"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "has_capacity(byte[32],uint256)bool" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.bucketId, params.args.amount],
    };
  }
  /**
   * Constructs a no op call for the get_rate_limit(byte[32])uint256 ABI method
   *
   * Returns the rate limit of the bucket
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getRateLimit(
    params: CallParams<
      | NttManagerArgs["obj"]["get_rate_limit(byte[32])uint256"]
      | NttManagerArgs["tuple"]["get_rate_limit(byte[32])uint256"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_rate_limit(byte[32])uint256" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.bucketId],
    };
  }
  /**
   * Constructs a no op call for the get_rate_duration(byte[32])uint64 ABI method
   *
   * Returns the rate duration of the bucket
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getRateDuration(
    params: CallParams<
      | NttManagerArgs["obj"]["get_rate_duration(byte[32])uint64"]
      | NttManagerArgs["tuple"]["get_rate_duration(byte[32])uint64"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_rate_duration(byte[32])uint64" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.bucketId],
    };
  }
  /**
   * Constructs a no op call for the update_min_upgrade_delay(uint64,uint64)void ABI method
   *
  * Schedule a change in the minimum delay needed for an upgrade.
  Automatically comes into effect at given timestamp.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateMinUpgradeDelay(
    params: CallParams<
      | NttManagerArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
      | NttManagerArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "update_min_upgrade_delay(uint64,uint64)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.minUpgradeDelay, params.args.timestamp],
    };
  }
  /**
   * Constructs a no op call for the schedule_contract_upgrade(byte[32],uint64)void ABI method
   *
  * Schedule the upgrade of the contract.
  The upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static scheduleContractUpgrade(
    params: CallParams<
      | NttManagerArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
      | NttManagerArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "schedule_contract_upgrade(byte[32],uint64)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.programSha256, params.args.timestamp],
    };
  }
  /**
   * Constructs a no op call for the cancel_contract_upgrade()void ABI method
   *
   * Cancel the scheduled upgrade
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static cancelContractUpgrade(
    params: CallParams<
      NttManagerArgs["obj"]["cancel_contract_upgrade()void"] | NttManagerArgs["tuple"]["cancel_contract_upgrade()void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "cancel_contract_upgrade()void" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the upgradable_admin_role()byte[16] ABI method
   *
   * Returns the role identifier for the upgradeable admin role
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static upgradableAdminRole(
    params: CallParams<
      | NttManagerArgs["obj"]["upgradable_admin_role()byte[16]"]
      | NttManagerArgs["tuple"]["upgradable_admin_role()byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "upgradable_admin_role()byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the max_for_min_upgrade_delay()uint64 ABI method
   *
  * Returns the maximum delay allowed for the minimum upgrade delay
  This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static maxForMinUpgradeDelay(
    params: CallParams<
      | NttManagerArgs["obj"]["max_for_min_upgrade_delay()uint64"]
      | NttManagerArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "max_for_min_upgrade_delay()uint64" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the get_active_min_upgrade_delay()uint64 ABI method
   *
   * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getActiveMinUpgradeDelay(
    params: CallParams<
      | NttManagerArgs["obj"]["get_active_min_upgrade_delay()uint64"]
      | NttManagerArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_active_min_upgrade_delay()uint64" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the grant_role(byte[16],address)void ABI method
   *
  * Grant a role to an account
  Increases the MBR for the contract's ledger balance.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static grantRole(
    params: CallParams<
      | NttManagerArgs["obj"]["grant_role(byte[16],address)void"]
      | NttManagerArgs["tuple"]["grant_role(byte[16],address)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "grant_role(byte[16],address)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.role, params.args.account],
    };
  }
  /**
   * Constructs a no op call for the revoke_role(byte[16],address)void ABI method
   *
  * Revokes a role from an account
  Reduces the MBR for the contract's ledger balance.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static revokeRole(
    params: CallParams<
      | NttManagerArgs["obj"]["revoke_role(byte[16],address)void"]
      | NttManagerArgs["tuple"]["revoke_role(byte[16],address)void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "revoke_role(byte[16],address)void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.role, params.args.account],
    };
  }
  /**
   * Constructs a no op call for the renounce_role(byte[16])void ABI method
   *
  * Revokes a role from the caller
  Reduces the MBR for the contract's ledger balance.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static renounceRole(
    params: CallParams<
      NttManagerArgs["obj"]["renounce_role(byte[16])void"] | NttManagerArgs["tuple"]["renounce_role(byte[16])void"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "renounce_role(byte[16])void" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.role],
    };
  }
  /**
   * Constructs a no op call for the default_admin_role()byte[16] ABI method
   *
   * Returns the role identifier for the default admin role
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static defaultAdminRole(
    params: CallParams<
      NttManagerArgs["obj"]["default_admin_role()byte[16]"] | NttManagerArgs["tuple"]["default_admin_role()byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "default_admin_role()byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [],
    };
  }
  /**
   * Constructs a no op call for the has_role(byte[16],address)bool ABI method
   *
   * Returns whether the account has been granted a role
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static hasRole(
    params: CallParams<
      | NttManagerArgs["obj"]["has_role(byte[16],address)bool"]
      | NttManagerArgs["tuple"]["has_role(byte[16],address)bool"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "has_role(byte[16],address)bool" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.role, params.args.account],
    };
  }
  /**
   * Constructs a no op call for the get_role_admin(byte[16])byte[16] ABI method
   *
   * Returns the admin role that controls a role
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getRoleAdmin(
    params: CallParams<
      | NttManagerArgs["obj"]["get_role_admin(byte[16])byte[16]"]
      | NttManagerArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: "get_role_admin(byte[16])byte[16]" as const,
      args: Array.isArray(params.args) ? params.args : [params.args.role],
    };
  }
}

/**
 * A factory to create and deploy one or more instance of the NttManager smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class NttManagerFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory;

  /**
   * Creates a new instance of `NttManagerFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, "appSpec">) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    });
  }

  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName;
  }

  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC;
  }

  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand;
  }

  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new NttManagerClient(this.appFactory.getAppClientById(params));
  }

  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams) {
    return new NttManagerClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }

  /**
   * Idempotently deploys the NttManager smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: NttManagerDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method
        ? NttManagerParamsFactory.create._resolveByMethod(params.createParams)
        : params.createParams
          ? (params.createParams as NttManagerCreateCallParams & {
              args: Uint8Array[];
            })
          : undefined,
      updateParams: params.updateParams?.method
        ? NttManagerParamsFactory.update._resolveByMethod(params.updateParams)
        : params.updateParams
          ? (params.updateParams as NttManagerUpdateCallParams & {
              args: Uint8Array[];
            })
          : undefined,
    });
    return {
      result: result.result,
      appClient: new NttManagerClient(result.appClient),
    };
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NttManager smart contract using the create(uint64,uint16,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (
        params: CallParams<
          | NttManagerArgs["obj"]["create(uint64,uint16,uint64,uint64)void"]
          | NttManagerArgs["tuple"]["create(uint64,uint16,uint64,uint64)void"]
        > &
          AppClientCompilationParams &
          CreateSchema & { onComplete?: OnApplicationComplete.NoOpOC },
      ) => {
        return this.appFactory.params.create(NttManagerParamsFactory.create.create(params));
      },
    },

    /**
     * Gets available deployUpdate methods
     */
    deployUpdate: {
      /**
       * Updates an existing instance of the NttManager smart contract using the complete_contract_upgrade()void ABI method.
       *
       * Complete the scheduled upgrade
       *
       * @param params The params for the smart contract call
       * @returns The deployUpdate params
       */
      completeContractUpgrade: (
        params: CallParams<
          | NttManagerArgs["obj"]["complete_contract_upgrade()void"]
          | NttManagerArgs["tuple"]["complete_contract_upgrade()void"]
        > &
          AppClientCompilationParams = { args: [] },
      ) => {
        return this.appFactory.params.deployUpdate(NttManagerParamsFactory.update.completeContractUpgrade(params));
      },
    },
  };

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NttManager smart contract using the create(uint64,uint16,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (
        params: CallParams<
          | NttManagerArgs["obj"]["create(uint64,uint16,uint64,uint64)void"]
          | NttManagerArgs["tuple"]["create(uint64,uint16,uint64,uint64)void"]
        > &
          AppClientCompilationParams &
          CreateSchema & { onComplete?: OnApplicationComplete.NoOpOC },
      ) => {
        return this.appFactory.createTransaction.create(NttManagerParamsFactory.create.create(params));
      },
    },
  };

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NttManager smart contract using an ABI method call using the create(uint64,uint16,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (
        params: CallParams<
          | NttManagerArgs["obj"]["create(uint64,uint16,uint64,uint64)void"]
          | NttManagerArgs["tuple"]["create(uint64,uint16,uint64,uint64)void"]
        > &
          AppClientCompilationParams &
          CreateSchema &
          SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
      ) => {
        const result = await this.appFactory.send.create(NttManagerParamsFactory.create.create(params));
        return {
          result: {
            ...result.result,
            return: result.result.return as unknown as
              | undefined
              | NttManagerReturns["create(uint64,uint16,uint64,uint64)void"],
          },
          appClient: new NttManagerClient(result.appClient),
        };
      },
    },
  };
}
/**
 * A client to make calls to the NttManager smart contract
 */
export class NttManagerClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient;

  /**
   * Creates a new instance of `NttManagerClient`
   *
   * @param appClient An `AppClient` instance which has been created with the NttManager app spec
   */
  constructor(appClient: _AppClient);
  /**
   * Creates a new instance of `NttManagerClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, "appSpec">);
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, "appSpec">) {
    this.appClient =
      appClientOrParams instanceof _AppClient
        ? appClientOrParams
        : new _AppClient({
            ...appClientOrParams,
            appSpec: APP_SPEC,
          });
  }

  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends NttManagerNonVoidMethodSignatures>(
    method: TSignature,
    returnValue: ABIReturn | undefined,
  ) {
    return returnValue !== undefined
      ? getArc56ReturnValue<MethodReturn<TSignature>>(
          returnValue,
          this.appClient.getABIMethod(method),
          APP_SPEC.structs,
        )
      : undefined;
  }

  /**
   * Returns a new `NttManagerClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(
    params: Omit<ResolveAppClientByCreatorAndName, "appSpec">,
  ): Promise<NttManagerClient> {
    return new NttManagerClient(await _AppClient.fromCreatorAndName({ ...params, appSpec: APP_SPEC }));
  }

  /**
   * Returns an `NttManagerClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params: Omit<ResolveAppClientByNetwork, "appSpec">): Promise<NttManagerClient> {
    return new NttManagerClient(await _AppClient.fromNetwork({ ...params, appSpec: APP_SPEC }));
  }

  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId;
  }

  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress;
  }

  /** The name of the app. */
  public get appName() {
    return this.appClient.appName;
  }

  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec;
  }

  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand;
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the NttManager smart contract using the `complete_contract_upgrade()void` ABI method.
       *
       * Complete the scheduled upgrade
       *
       * @param params The params for the smart contract call
       * @returns The update params
       */
      completeContractUpgrade: (
        params: CallParams<
          | NttManagerArgs["obj"]["complete_contract_upgrade()void"]
          | NttManagerArgs["tuple"]["complete_contract_upgrade()void"]
        > &
          AppClientCompilationParams = { args: [] },
      ) => {
        return this.appClient.params.update(NttManagerParamsFactory.update.completeContractUpgrade(params));
      },
    },

    /**
     * Makes a clear_state call to an existing instance of the NttManager smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params);
    },

    /**
     * Makes a call to the NttManager smart contract using the `initialise(address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initialise: (
      params: CallParams<
        | NttManagerArgs["obj"]["initialise(address,uint64)void"]
        | NttManagerArgs["tuple"]["initialise(address,uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.initialise(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `pause()void` ABI method.
     *
     * Pause incoming and outgoing transfers in case of emergency.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    pause: (
      params: CallParams<NttManagerArgs["obj"]["pause()void"] | NttManagerArgs["tuple"]["pause()void"]> & {
        onComplete?: OnApplicationComplete.NoOpOC;
      } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.pause(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `unpause()void` ABI method.
     *
     * Resume incoming and outgoing transfers after previous pause.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    unpause: (
      params: CallParams<NttManagerArgs["obj"]["unpause()void"] | NttManagerArgs["tuple"]["unpause()void"]> & {
        onComplete?: OnApplicationComplete.NoOpOC;
      } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.unpause(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_transceiver_manager(address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setTransceiverManager: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_transceiver_manager(address,uint64)void"]
        | NttManagerArgs["tuple"]["set_transceiver_manager(address,uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.setTransceiverManager(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_threshold(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setThreshold: (
      params: CallParams<
        NttManagerArgs["obj"]["set_threshold(uint64)void"] | NttManagerArgs["tuple"]["set_threshold(uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.setThreshold(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_ntt_manager_peer(uint16,byte[32],uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setNttManagerPeer: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
        | NttManagerArgs["tuple"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.setNttManagerPeer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `transfer(pay,axfer,uint64,uint16,byte[32])byte[32]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    transfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
        | NttManagerArgs["tuple"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.transfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    transferFull: (
      params: CallParams<
        | NttManagerArgs["obj"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
        | NttManagerArgs["tuple"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.transferFull(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `complete_outbound_queued_transfer(pay,byte[32])byte[32]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    completeOutboundQueuedTransfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
        | NttManagerArgs["tuple"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.completeOutboundQueuedTransfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `cancel_outbound_queued_transfer(byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    cancelOutboundQueuedTransfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["cancel_outbound_queued_transfer(byte[32])void"]
        | NttManagerArgs["tuple"]["cancel_outbound_queued_transfer(byte[32])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.cancelOutboundQueuedTransfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `complete_inbound_queued_transfer(byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    completeInboundQueuedTransfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["complete_inbound_queued_transfer(byte[32])void"]
        | NttManagerArgs["tuple"]["complete_inbound_queued_transfer(byte[32])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.completeInboundQueuedTransfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `ntt_manager_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    nttManagerAdminRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["ntt_manager_admin_role()byte[16]"]
        | NttManagerArgs["tuple"]["ntt_manager_admin_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.nttManagerAdminRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `pauser_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    pauserRole: (
      params: CallParams<
        NttManagerArgs["obj"]["pauser_role()byte[16]"] | NttManagerArgs["tuple"]["pauser_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.pauserRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `unpauser_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    unpauserRole: (
      params: CallParams<
        NttManagerArgs["obj"]["unpauser_role()byte[16]"] | NttManagerArgs["tuple"]["unpauser_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.unpauserRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_ntt_manager_peer(uint16)(byte[32],uint8)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getNttManagerPeer: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
        | NttManagerArgs["tuple"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.getNttManagerPeer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void` ABI method.
     *
     * Execute a message once the threshold number of attestations has been reached.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    executeMessage: (
      params: CallParams<
        | NttManagerArgs["obj"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
        | NttManagerArgs["tuple"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.executeMessage(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `is_message_approved(byte[32])bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns whether a message has been approved.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    isMessageApproved: (
      params: CallParams<
        | NttManagerArgs["obj"]["is_message_approved(byte[32])bool"]
        | NttManagerArgs["tuple"]["is_message_approved(byte[32])bool"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.isMessageApproved(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `is_message_executed(byte[32])bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns whether a message has been executed.
    Note that a message can be executed without being approved if the threshold is increased after execution.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    isMessageExecuted: (
      params: CallParams<
        | NttManagerArgs["obj"]["is_message_executed(byte[32])bool"]
        | NttManagerArgs["tuple"]["is_message_executed(byte[32])bool"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.isMessageExecuted(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_outbound_rate_limit(uint256)void` ABI method.
     *
     * Set limit for outbound bucket.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setOutboundRateLimit: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_outbound_rate_limit(uint256)void"]
        | NttManagerArgs["tuple"]["set_outbound_rate_limit(uint256)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.setOutboundRateLimit(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_outbound_rate_duration(uint64)void` ABI method.
     *
     * Set duration for outbound bucket.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setOutboundRateDuration: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_outbound_rate_duration(uint64)void"]
        | NttManagerArgs["tuple"]["set_outbound_rate_duration(uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.setOutboundRateDuration(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_inbound_rate_limit(uint16,uint256)void` ABI method.
     *
     * Set limit for inbound bucket of the given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setInboundRateLimit: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_inbound_rate_limit(uint16,uint256)void"]
        | NttManagerArgs["tuple"]["set_inbound_rate_limit(uint16,uint256)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.setInboundRateLimit(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_inbound_rate_duration(uint16,uint64)void` ABI method.
     *
     * Set duration for inbound bucket of the given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setInboundRateDuration: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_inbound_rate_duration(uint16,uint64)void"]
        | NttManagerArgs["tuple"]["set_inbound_rate_duration(uint16,uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.setInboundRateDuration(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_current_outbound_capacity()uint256` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current capacity of the outbound.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getCurrentOutboundCapacity: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_current_outbound_capacity()uint256"]
        | NttManagerArgs["tuple"]["get_current_outbound_capacity()uint256"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.getCurrentOutboundCapacity(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the details of an outbound queued transfer.
     *
     * @param params The params for the smart contract call
     * @returns The call params: Tuple of whether the transfer can be completed and the details of the transfer request.
     */
    getOutboundQueuedTransfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
        | NttManagerArgs["tuple"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.getOutboundQueuedTransfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_current_inbound_capacity(uint16)uint256` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current capacity of the inbound bucket of the given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getCurrentInboundCapacity: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_current_inbound_capacity(uint16)uint256"]
        | NttManagerArgs["tuple"]["get_current_inbound_capacity(uint16)uint256"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.getCurrentInboundCapacity(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the details of an inbound queued transfer.
     *
     * @param params The params for the smart contract call
     * @returns The call params: Tuple of whether the transfer can be completed and the details of the transfer request.
     */
    getInboundQueuedTransfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
        | NttManagerArgs["tuple"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.getInboundQueuedTransfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `inbound_bucket_id(uint16)byte[32]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    inboundBucketId: (
      params: CallParams<
        | NttManagerArgs["obj"]["inbound_bucket_id(uint16)byte[32]"]
        | NttManagerArgs["tuple"]["inbound_bucket_id(uint16)byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.inboundBucketId(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `outbound_bucket_id()byte[32]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    outboundBucketId: (
      params: CallParams<
        NttManagerArgs["obj"]["outbound_bucket_id()byte[32]"] | NttManagerArgs["tuple"]["outbound_bucket_id()byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.outboundBucketId(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `rate_limiter_manager_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    rateLimiterManagerRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["rate_limiter_manager_role()byte[16]"]
        | NttManagerArgs["tuple"]["rate_limiter_manager_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.rateLimiterManagerRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_current_capacity(byte[32])uint256` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the current capacity of the bucket were it to be updated.
    If you call this method (as opposed to simulate) then the capacity will be updated on chain.
    You should NOT use this method to determine if there is sufficient capacity because a `duration` of zero is interpreted as an infinite bucket regardless of the `current_capacity. Instead, use `has_capacity()`.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getCurrentCapacity: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_current_capacity(byte[32])uint256"]
        | NttManagerArgs["tuple"]["get_current_capacity(byte[32])uint256"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.getCurrentCapacity(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `has_capacity(byte[32],uint256)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns whether there's sufficient capacity inside bucket for amount.
    If you call this method (as opposed to simulate) then the capacity will be updated on chain.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    hasCapacity: (
      params: CallParams<
        | NttManagerArgs["obj"]["has_capacity(byte[32],uint256)bool"]
        | NttManagerArgs["tuple"]["has_capacity(byte[32],uint256)bool"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.hasCapacity(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_rate_limit(byte[32])uint256` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the rate limit of the bucket
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getRateLimit: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_rate_limit(byte[32])uint256"]
        | NttManagerArgs["tuple"]["get_rate_limit(byte[32])uint256"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.getRateLimit(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_rate_duration(byte[32])uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the rate duration of the bucket
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getRateDuration: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_rate_duration(byte[32])uint64"]
        | NttManagerArgs["tuple"]["get_rate_duration(byte[32])uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.getRateDuration(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `update_min_upgrade_delay(uint64,uint64)void` ABI method.
     *
    * Schedule a change in the minimum delay needed for an upgrade.
    Automatically comes into effect at given timestamp.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateMinUpgradeDelay: (
      params: CallParams<
        | NttManagerArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
        | NttManagerArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.updateMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `schedule_contract_upgrade(byte[32],uint64)void` ABI method.
     *
    * Schedule the upgrade of the contract.
    The upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    scheduleContractUpgrade: (
      params: CallParams<
        | NttManagerArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
        | NttManagerArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.scheduleContractUpgrade(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `cancel_contract_upgrade()void` ABI method.
     *
     * Cancel the scheduled upgrade
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    cancelContractUpgrade: (
      params: CallParams<
        | NttManagerArgs["obj"]["cancel_contract_upgrade()void"]
        | NttManagerArgs["tuple"]["cancel_contract_upgrade()void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.cancelContractUpgrade(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `upgradable_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the upgradeable admin role
     *
     * @param params The params for the smart contract call
     * @returns The call params: Role bytes of length 16
     */
    upgradableAdminRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["upgradable_admin_role()byte[16]"]
        | NttManagerArgs["tuple"]["upgradable_admin_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.upgradableAdminRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `max_for_min_upgrade_delay()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the maximum delay allowed for the minimum upgrade delay
    This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

     *
     * @param params The params for the smart contract call
     * @returns The call params: The maximum minimum upgrade delay
     */
    maxForMinUpgradeDelay: (
      params: CallParams<
        | NttManagerArgs["obj"]["max_for_min_upgrade_delay()uint64"]
        | NttManagerArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.maxForMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_active_min_upgrade_delay()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
     *
     * @param params The params for the smart contract call
     * @returns The call params: The active minimum upgrade delay
     */
    getActiveMinUpgradeDelay: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_active_min_upgrade_delay()uint64"]
        | NttManagerArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.getActiveMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `grant_role(byte[16],address)void` ABI method.
     *
    * Grant a role to an account
    Increases the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    grantRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["grant_role(byte[16],address)void"]
        | NttManagerArgs["tuple"]["grant_role(byte[16],address)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.grantRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `revoke_role(byte[16],address)void` ABI method.
     *
    * Revokes a role from an account
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    revokeRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["revoke_role(byte[16],address)void"]
        | NttManagerArgs["tuple"]["revoke_role(byte[16],address)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.revokeRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `renounce_role(byte[16])void` ABI method.
     *
    * Revokes a role from the caller
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    renounceRole: (
      params: CallParams<
        NttManagerArgs["obj"]["renounce_role(byte[16])void"] | NttManagerArgs["tuple"]["renounce_role(byte[16])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.renounceRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `default_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the default admin role
     *
     * @param params The params for the smart contract call
     * @returns The call params: Empty bytes of length 16
     */
    defaultAdminRole: (
      params: CallParams<
        NttManagerArgs["obj"]["default_admin_role()byte[16]"] | NttManagerArgs["tuple"]["default_admin_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.defaultAdminRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `has_role(byte[16],address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns whether the account has been granted a role
     *
     * @param params The params for the smart contract call
     * @returns The call params: Whether the account has been granted a role
     */
    hasRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["has_role(byte[16],address)bool"]
        | NttManagerArgs["tuple"]["has_role(byte[16],address)bool"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.hasRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_role_admin(byte[16])byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the admin role that controls a role
     *
     * @param params The params for the smart contract call
     * @returns The call params: The role admin
     */
    getRoleAdmin: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_role_admin(byte[16])byte[16]"]
        | NttManagerArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.params.call(NttManagerParamsFactory.getRoleAdmin(params));
    },
  };

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the NttManager smart contract using the `complete_contract_upgrade()void` ABI method.
       *
       * Complete the scheduled upgrade
       *
       * @param params The params for the smart contract call
       * @returns The update transaction
       */
      completeContractUpgrade: (
        params: CallParams<
          | NttManagerArgs["obj"]["complete_contract_upgrade()void"]
          | NttManagerArgs["tuple"]["complete_contract_upgrade()void"]
        > &
          AppClientCompilationParams = { args: [] },
      ) => {
        return this.appClient.createTransaction.update(NttManagerParamsFactory.update.completeContractUpgrade(params));
      },
    },

    /**
     * Makes a clear_state call to an existing instance of the NttManager smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },

    /**
     * Makes a call to the NttManager smart contract using the `initialise(address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initialise: (
      params: CallParams<
        | NttManagerArgs["obj"]["initialise(address,uint64)void"]
        | NttManagerArgs["tuple"]["initialise(address,uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.initialise(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `pause()void` ABI method.
     *
     * Pause incoming and outgoing transfers in case of emergency.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    pause: (
      params: CallParams<NttManagerArgs["obj"]["pause()void"] | NttManagerArgs["tuple"]["pause()void"]> & {
        onComplete?: OnApplicationComplete.NoOpOC;
      } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.pause(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `unpause()void` ABI method.
     *
     * Resume incoming and outgoing transfers after previous pause.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    unpause: (
      params: CallParams<NttManagerArgs["obj"]["unpause()void"] | NttManagerArgs["tuple"]["unpause()void"]> & {
        onComplete?: OnApplicationComplete.NoOpOC;
      } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.unpause(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_transceiver_manager(address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setTransceiverManager: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_transceiver_manager(address,uint64)void"]
        | NttManagerArgs["tuple"]["set_transceiver_manager(address,uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.setTransceiverManager(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_threshold(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setThreshold: (
      params: CallParams<
        NttManagerArgs["obj"]["set_threshold(uint64)void"] | NttManagerArgs["tuple"]["set_threshold(uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.setThreshold(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_ntt_manager_peer(uint16,byte[32],uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setNttManagerPeer: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
        | NttManagerArgs["tuple"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.setNttManagerPeer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `transfer(pay,axfer,uint64,uint16,byte[32])byte[32]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    transfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
        | NttManagerArgs["tuple"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.transfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    transferFull: (
      params: CallParams<
        | NttManagerArgs["obj"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
        | NttManagerArgs["tuple"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.transferFull(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `complete_outbound_queued_transfer(pay,byte[32])byte[32]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    completeOutboundQueuedTransfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
        | NttManagerArgs["tuple"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.completeOutboundQueuedTransfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `cancel_outbound_queued_transfer(byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    cancelOutboundQueuedTransfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["cancel_outbound_queued_transfer(byte[32])void"]
        | NttManagerArgs["tuple"]["cancel_outbound_queued_transfer(byte[32])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.cancelOutboundQueuedTransfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `complete_inbound_queued_transfer(byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    completeInboundQueuedTransfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["complete_inbound_queued_transfer(byte[32])void"]
        | NttManagerArgs["tuple"]["complete_inbound_queued_transfer(byte[32])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.completeInboundQueuedTransfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `ntt_manager_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    nttManagerAdminRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["ntt_manager_admin_role()byte[16]"]
        | NttManagerArgs["tuple"]["ntt_manager_admin_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.nttManagerAdminRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `pauser_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    pauserRole: (
      params: CallParams<
        NttManagerArgs["obj"]["pauser_role()byte[16]"] | NttManagerArgs["tuple"]["pauser_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.pauserRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `unpauser_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    unpauserRole: (
      params: CallParams<
        NttManagerArgs["obj"]["unpauser_role()byte[16]"] | NttManagerArgs["tuple"]["unpauser_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.unpauserRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_ntt_manager_peer(uint16)(byte[32],uint8)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getNttManagerPeer: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
        | NttManagerArgs["tuple"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.getNttManagerPeer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void` ABI method.
     *
     * Execute a message once the threshold number of attestations has been reached.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    executeMessage: (
      params: CallParams<
        | NttManagerArgs["obj"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
        | NttManagerArgs["tuple"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.executeMessage(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `is_message_approved(byte[32])bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns whether a message has been approved.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    isMessageApproved: (
      params: CallParams<
        | NttManagerArgs["obj"]["is_message_approved(byte[32])bool"]
        | NttManagerArgs["tuple"]["is_message_approved(byte[32])bool"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.isMessageApproved(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `is_message_executed(byte[32])bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns whether a message has been executed.
    Note that a message can be executed without being approved if the threshold is increased after execution.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    isMessageExecuted: (
      params: CallParams<
        | NttManagerArgs["obj"]["is_message_executed(byte[32])bool"]
        | NttManagerArgs["tuple"]["is_message_executed(byte[32])bool"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.isMessageExecuted(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_outbound_rate_limit(uint256)void` ABI method.
     *
     * Set limit for outbound bucket.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setOutboundRateLimit: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_outbound_rate_limit(uint256)void"]
        | NttManagerArgs["tuple"]["set_outbound_rate_limit(uint256)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.setOutboundRateLimit(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_outbound_rate_duration(uint64)void` ABI method.
     *
     * Set duration for outbound bucket.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setOutboundRateDuration: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_outbound_rate_duration(uint64)void"]
        | NttManagerArgs["tuple"]["set_outbound_rate_duration(uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.setOutboundRateDuration(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_inbound_rate_limit(uint16,uint256)void` ABI method.
     *
     * Set limit for inbound bucket of the given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setInboundRateLimit: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_inbound_rate_limit(uint16,uint256)void"]
        | NttManagerArgs["tuple"]["set_inbound_rate_limit(uint16,uint256)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.setInboundRateLimit(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_inbound_rate_duration(uint16,uint64)void` ABI method.
     *
     * Set duration for inbound bucket of the given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setInboundRateDuration: (
      params: CallParams<
        | NttManagerArgs["obj"]["set_inbound_rate_duration(uint16,uint64)void"]
        | NttManagerArgs["tuple"]["set_inbound_rate_duration(uint16,uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.setInboundRateDuration(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_current_outbound_capacity()uint256` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current capacity of the outbound.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getCurrentOutboundCapacity: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_current_outbound_capacity()uint256"]
        | NttManagerArgs["tuple"]["get_current_outbound_capacity()uint256"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.getCurrentOutboundCapacity(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the details of an outbound queued transfer.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Tuple of whether the transfer can be completed and the details of the transfer request.
     */
    getOutboundQueuedTransfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
        | NttManagerArgs["tuple"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.getOutboundQueuedTransfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_current_inbound_capacity(uint16)uint256` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current capacity of the inbound bucket of the given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getCurrentInboundCapacity: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_current_inbound_capacity(uint16)uint256"]
        | NttManagerArgs["tuple"]["get_current_inbound_capacity(uint16)uint256"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.getCurrentInboundCapacity(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the details of an inbound queued transfer.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Tuple of whether the transfer can be completed and the details of the transfer request.
     */
    getInboundQueuedTransfer: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
        | NttManagerArgs["tuple"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.getInboundQueuedTransfer(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `inbound_bucket_id(uint16)byte[32]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    inboundBucketId: (
      params: CallParams<
        | NttManagerArgs["obj"]["inbound_bucket_id(uint16)byte[32]"]
        | NttManagerArgs["tuple"]["inbound_bucket_id(uint16)byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.inboundBucketId(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `outbound_bucket_id()byte[32]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    outboundBucketId: (
      params: CallParams<
        NttManagerArgs["obj"]["outbound_bucket_id()byte[32]"] | NttManagerArgs["tuple"]["outbound_bucket_id()byte[32]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.outboundBucketId(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `rate_limiter_manager_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    rateLimiterManagerRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["rate_limiter_manager_role()byte[16]"]
        | NttManagerArgs["tuple"]["rate_limiter_manager_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.rateLimiterManagerRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_current_capacity(byte[32])uint256` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the current capacity of the bucket were it to be updated.
    If you call this method (as opposed to simulate) then the capacity will be updated on chain.
    You should NOT use this method to determine if there is sufficient capacity because a `duration` of zero is interpreted as an infinite bucket regardless of the `current_capacity. Instead, use `has_capacity()`.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getCurrentCapacity: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_current_capacity(byte[32])uint256"]
        | NttManagerArgs["tuple"]["get_current_capacity(byte[32])uint256"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.getCurrentCapacity(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `has_capacity(byte[32],uint256)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns whether there's sufficient capacity inside bucket for amount.
    If you call this method (as opposed to simulate) then the capacity will be updated on chain.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    hasCapacity: (
      params: CallParams<
        | NttManagerArgs["obj"]["has_capacity(byte[32],uint256)bool"]
        | NttManagerArgs["tuple"]["has_capacity(byte[32],uint256)bool"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.hasCapacity(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_rate_limit(byte[32])uint256` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the rate limit of the bucket
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getRateLimit: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_rate_limit(byte[32])uint256"]
        | NttManagerArgs["tuple"]["get_rate_limit(byte[32])uint256"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.getRateLimit(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_rate_duration(byte[32])uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the rate duration of the bucket
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getRateDuration: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_rate_duration(byte[32])uint64"]
        | NttManagerArgs["tuple"]["get_rate_duration(byte[32])uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.getRateDuration(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `update_min_upgrade_delay(uint64,uint64)void` ABI method.
     *
    * Schedule a change in the minimum delay needed for an upgrade.
    Automatically comes into effect at given timestamp.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateMinUpgradeDelay: (
      params: CallParams<
        | NttManagerArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
        | NttManagerArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.updateMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `schedule_contract_upgrade(byte[32],uint64)void` ABI method.
     *
    * Schedule the upgrade of the contract.
    The upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    scheduleContractUpgrade: (
      params: CallParams<
        | NttManagerArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
        | NttManagerArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.scheduleContractUpgrade(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `cancel_contract_upgrade()void` ABI method.
     *
     * Cancel the scheduled upgrade
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    cancelContractUpgrade: (
      params: CallParams<
        | NttManagerArgs["obj"]["cancel_contract_upgrade()void"]
        | NttManagerArgs["tuple"]["cancel_contract_upgrade()void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.cancelContractUpgrade(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `upgradable_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the upgradeable admin role
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Role bytes of length 16
     */
    upgradableAdminRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["upgradable_admin_role()byte[16]"]
        | NttManagerArgs["tuple"]["upgradable_admin_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.upgradableAdminRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `max_for_min_upgrade_delay()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the maximum delay allowed for the minimum upgrade delay
    This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The maximum minimum upgrade delay
     */
    maxForMinUpgradeDelay: (
      params: CallParams<
        | NttManagerArgs["obj"]["max_for_min_upgrade_delay()uint64"]
        | NttManagerArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.maxForMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_active_min_upgrade_delay()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The active minimum upgrade delay
     */
    getActiveMinUpgradeDelay: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_active_min_upgrade_delay()uint64"]
        | NttManagerArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.getActiveMinUpgradeDelay(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `grant_role(byte[16],address)void` ABI method.
     *
    * Grant a role to an account
    Increases the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    grantRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["grant_role(byte[16],address)void"]
        | NttManagerArgs["tuple"]["grant_role(byte[16],address)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.grantRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `revoke_role(byte[16],address)void` ABI method.
     *
    * Revokes a role from an account
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    revokeRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["revoke_role(byte[16],address)void"]
        | NttManagerArgs["tuple"]["revoke_role(byte[16],address)void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.revokeRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `renounce_role(byte[16])void` ABI method.
     *
    * Revokes a role from the caller
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    renounceRole: (
      params: CallParams<
        NttManagerArgs["obj"]["renounce_role(byte[16])void"] | NttManagerArgs["tuple"]["renounce_role(byte[16])void"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.renounceRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `default_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the default admin role
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Empty bytes of length 16
     */
    defaultAdminRole: (
      params: CallParams<
        NttManagerArgs["obj"]["default_admin_role()byte[16]"] | NttManagerArgs["tuple"]["default_admin_role()byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.defaultAdminRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `has_role(byte[16],address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns whether the account has been granted a role
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Whether the account has been granted a role
     */
    hasRole: (
      params: CallParams<
        | NttManagerArgs["obj"]["has_role(byte[16],address)bool"]
        | NttManagerArgs["tuple"]["has_role(byte[16],address)bool"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.hasRole(params));
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_role_admin(byte[16])byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the admin role that controls a role
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The role admin
     */
    getRoleAdmin: (
      params: CallParams<
        | NttManagerArgs["obj"]["get_role_admin(byte[16])byte[16]"]
        | NttManagerArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
      > & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      return this.appClient.createTransaction.call(NttManagerParamsFactory.getRoleAdmin(params));
    },
  };

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the NttManager smart contract using the `complete_contract_upgrade()void` ABI method.
       *
       * Complete the scheduled upgrade
       *
       * @param params The params for the smart contract call
       * @returns The update result
       */
      completeContractUpgrade: async (
        params: CallParams<
          | NttManagerArgs["obj"]["complete_contract_upgrade()void"]
          | NttManagerArgs["tuple"]["complete_contract_upgrade()void"]
        > &
          AppClientCompilationParams &
          SendParams = { args: [] },
      ) => {
        const result = await this.appClient.send.update(NttManagerParamsFactory.update.completeContractUpgrade(params));
        return {
          ...result,
          return: result.return as unknown as undefined | NttManagerReturns["complete_contract_upgrade()void"],
        };
      },
    },

    /**
     * Makes a clear_state call to an existing instance of the NttManager smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params);
    },

    /**
     * Makes a call to the NttManager smart contract using the `initialise(address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initialise: async (
      params: CallParams<
        | NttManagerArgs["obj"]["initialise(address,uint64)void"]
        | NttManagerArgs["tuple"]["initialise(address,uint64)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.initialise(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["initialise(address,uint64)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `pause()void` ABI method.
     *
     * Pause incoming and outgoing transfers in case of emergency.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    pause: async (
      params: CallParams<NttManagerArgs["obj"]["pause()void"] | NttManagerArgs["tuple"]["pause()void"]> &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.pause(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["pause()void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `unpause()void` ABI method.
     *
     * Resume incoming and outgoing transfers after previous pause.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    unpause: async (
      params: CallParams<NttManagerArgs["obj"]["unpause()void"] | NttManagerArgs["tuple"]["unpause()void"]> &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.unpause(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["unpause()void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_transceiver_manager(address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setTransceiverManager: async (
      params: CallParams<
        | NttManagerArgs["obj"]["set_transceiver_manager(address,uint64)void"]
        | NttManagerArgs["tuple"]["set_transceiver_manager(address,uint64)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.setTransceiverManager(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["set_transceiver_manager(address,uint64)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_threshold(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setThreshold: async (
      params: CallParams<
        NttManagerArgs["obj"]["set_threshold(uint64)void"] | NttManagerArgs["tuple"]["set_threshold(uint64)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.setThreshold(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["set_threshold(uint64)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_ntt_manager_peer(uint16,byte[32],uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setNttManagerPeer: async (
      params: CallParams<
        | NttManagerArgs["obj"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
        | NttManagerArgs["tuple"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.setNttManagerPeer(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["set_ntt_manager_peer(uint16,byte[32],uint8)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `transfer(pay,axfer,uint64,uint16,byte[32])byte[32]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    transfer: async (
      params: CallParams<
        | NttManagerArgs["obj"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
        | NttManagerArgs["tuple"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.transfer(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    transferFull: async (
      params: CallParams<
        | NttManagerArgs["obj"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
        | NttManagerArgs["tuple"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.transferFull(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `complete_outbound_queued_transfer(pay,byte[32])byte[32]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    completeOutboundQueuedTransfer: async (
      params: CallParams<
        | NttManagerArgs["obj"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
        | NttManagerArgs["tuple"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.completeOutboundQueuedTransfer(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["complete_outbound_queued_transfer(pay,byte[32])byte[32]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `cancel_outbound_queued_transfer(byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    cancelOutboundQueuedTransfer: async (
      params: CallParams<
        | NttManagerArgs["obj"]["cancel_outbound_queued_transfer(byte[32])void"]
        | NttManagerArgs["tuple"]["cancel_outbound_queued_transfer(byte[32])void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.cancelOutboundQueuedTransfer(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["cancel_outbound_queued_transfer(byte[32])void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `complete_inbound_queued_transfer(byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    completeInboundQueuedTransfer: async (
      params: CallParams<
        | NttManagerArgs["obj"]["complete_inbound_queued_transfer(byte[32])void"]
        | NttManagerArgs["tuple"]["complete_inbound_queued_transfer(byte[32])void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.completeInboundQueuedTransfer(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["complete_inbound_queued_transfer(byte[32])void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `ntt_manager_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    nttManagerAdminRole: async (
      params: CallParams<
        | NttManagerArgs["obj"]["ntt_manager_admin_role()byte[16]"]
        | NttManagerArgs["tuple"]["ntt_manager_admin_role()byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.nttManagerAdminRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["ntt_manager_admin_role()byte[16]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `pauser_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    pauserRole: async (
      params: CallParams<
        NttManagerArgs["obj"]["pauser_role()byte[16]"] | NttManagerArgs["tuple"]["pauser_role()byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.pauserRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["pauser_role()byte[16]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `unpauser_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    unpauserRole: async (
      params: CallParams<
        NttManagerArgs["obj"]["unpauser_role()byte[16]"] | NttManagerArgs["tuple"]["unpauser_role()byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.unpauserRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["unpauser_role()byte[16]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_ntt_manager_peer(uint16)(byte[32],uint8)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getNttManagerPeer: async (
      params: CallParams<
        | NttManagerArgs["obj"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
        | NttManagerArgs["tuple"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.getNttManagerPeer(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["get_ntt_manager_peer(uint16)(byte[32],uint8)"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void` ABI method.
     *
     * Execute a message once the threshold number of attestations has been reached.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    executeMessage: async (
      params: CallParams<
        | NttManagerArgs["obj"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
        | NttManagerArgs["tuple"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.executeMessage(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `is_message_approved(byte[32])bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns whether a message has been approved.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    isMessageApproved: async (
      params: CallParams<
        | NttManagerArgs["obj"]["is_message_approved(byte[32])bool"]
        | NttManagerArgs["tuple"]["is_message_approved(byte[32])bool"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.isMessageApproved(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["is_message_approved(byte[32])bool"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `is_message_executed(byte[32])bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns whether a message has been executed.
    Note that a message can be executed without being approved if the threshold is increased after execution.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    isMessageExecuted: async (
      params: CallParams<
        | NttManagerArgs["obj"]["is_message_executed(byte[32])bool"]
        | NttManagerArgs["tuple"]["is_message_executed(byte[32])bool"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.isMessageExecuted(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["is_message_executed(byte[32])bool"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_outbound_rate_limit(uint256)void` ABI method.
     *
     * Set limit for outbound bucket.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setOutboundRateLimit: async (
      params: CallParams<
        | NttManagerArgs["obj"]["set_outbound_rate_limit(uint256)void"]
        | NttManagerArgs["tuple"]["set_outbound_rate_limit(uint256)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.setOutboundRateLimit(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["set_outbound_rate_limit(uint256)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_outbound_rate_duration(uint64)void` ABI method.
     *
     * Set duration for outbound bucket.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setOutboundRateDuration: async (
      params: CallParams<
        | NttManagerArgs["obj"]["set_outbound_rate_duration(uint64)void"]
        | NttManagerArgs["tuple"]["set_outbound_rate_duration(uint64)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.setOutboundRateDuration(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["set_outbound_rate_duration(uint64)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_inbound_rate_limit(uint16,uint256)void` ABI method.
     *
     * Set limit for inbound bucket of the given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setInboundRateLimit: async (
      params: CallParams<
        | NttManagerArgs["obj"]["set_inbound_rate_limit(uint16,uint256)void"]
        | NttManagerArgs["tuple"]["set_inbound_rate_limit(uint16,uint256)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.setInboundRateLimit(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["set_inbound_rate_limit(uint16,uint256)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `set_inbound_rate_duration(uint16,uint64)void` ABI method.
     *
     * Set duration for inbound bucket of the given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setInboundRateDuration: async (
      params: CallParams<
        | NttManagerArgs["obj"]["set_inbound_rate_duration(uint16,uint64)void"]
        | NttManagerArgs["tuple"]["set_inbound_rate_duration(uint16,uint64)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.setInboundRateDuration(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["set_inbound_rate_duration(uint16,uint64)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_current_outbound_capacity()uint256` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current capacity of the outbound.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getCurrentOutboundCapacity: async (
      params: CallParams<
        | NttManagerArgs["obj"]["get_current_outbound_capacity()uint256"]
        | NttManagerArgs["tuple"]["get_current_outbound_capacity()uint256"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.getCurrentOutboundCapacity(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["get_current_outbound_capacity()uint256"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the details of an outbound queued transfer.
     *
     * @param params The params for the smart contract call
     * @returns The call result: Tuple of whether the transfer can be completed and the details of the transfer request.
     */
    getOutboundQueuedTransfer: async (
      params: CallParams<
        | NttManagerArgs["obj"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
        | NttManagerArgs["tuple"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.getOutboundQueuedTransfer(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_current_inbound_capacity(uint16)uint256` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current capacity of the inbound bucket of the given chain.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getCurrentInboundCapacity: async (
      params: CallParams<
        | NttManagerArgs["obj"]["get_current_inbound_capacity(uint16)uint256"]
        | NttManagerArgs["tuple"]["get_current_inbound_capacity(uint16)uint256"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.getCurrentInboundCapacity(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["get_current_inbound_capacity(uint16)uint256"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the details of an inbound queued transfer.
     *
     * @param params The params for the smart contract call
     * @returns The call result: Tuple of whether the transfer can be completed and the details of the transfer request.
     */
    getInboundQueuedTransfer: async (
      params: CallParams<
        | NttManagerArgs["obj"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
        | NttManagerArgs["tuple"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.getInboundQueuedTransfer(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `inbound_bucket_id(uint16)byte[32]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    inboundBucketId: async (
      params: CallParams<
        | NttManagerArgs["obj"]["inbound_bucket_id(uint16)byte[32]"]
        | NttManagerArgs["tuple"]["inbound_bucket_id(uint16)byte[32]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.inboundBucketId(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["inbound_bucket_id(uint16)byte[32]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `outbound_bucket_id()byte[32]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    outboundBucketId: async (
      params: CallParams<
        NttManagerArgs["obj"]["outbound_bucket_id()byte[32]"] | NttManagerArgs["tuple"]["outbound_bucket_id()byte[32]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.outboundBucketId(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["outbound_bucket_id()byte[32]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `rate_limiter_manager_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    rateLimiterManagerRole: async (
      params: CallParams<
        | NttManagerArgs["obj"]["rate_limiter_manager_role()byte[16]"]
        | NttManagerArgs["tuple"]["rate_limiter_manager_role()byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.rateLimiterManagerRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["rate_limiter_manager_role()byte[16]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_current_capacity(byte[32])uint256` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the current capacity of the bucket were it to be updated.
    If you call this method (as opposed to simulate) then the capacity will be updated on chain.
    You should NOT use this method to determine if there is sufficient capacity because a `duration` of zero is interpreted as an infinite bucket regardless of the `current_capacity. Instead, use `has_capacity()`.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getCurrentCapacity: async (
      params: CallParams<
        | NttManagerArgs["obj"]["get_current_capacity(byte[32])uint256"]
        | NttManagerArgs["tuple"]["get_current_capacity(byte[32])uint256"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.getCurrentCapacity(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["get_current_capacity(byte[32])uint256"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `has_capacity(byte[32],uint256)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns whether there's sufficient capacity inside bucket for amount.
    If you call this method (as opposed to simulate) then the capacity will be updated on chain.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    hasCapacity: async (
      params: CallParams<
        | NttManagerArgs["obj"]["has_capacity(byte[32],uint256)bool"]
        | NttManagerArgs["tuple"]["has_capacity(byte[32],uint256)bool"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.hasCapacity(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["has_capacity(byte[32],uint256)bool"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_rate_limit(byte[32])uint256` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the rate limit of the bucket
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getRateLimit: async (
      params: CallParams<
        | NttManagerArgs["obj"]["get_rate_limit(byte[32])uint256"]
        | NttManagerArgs["tuple"]["get_rate_limit(byte[32])uint256"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.getRateLimit(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["get_rate_limit(byte[32])uint256"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_rate_duration(byte[32])uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the rate duration of the bucket
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getRateDuration: async (
      params: CallParams<
        | NttManagerArgs["obj"]["get_rate_duration(byte[32])uint64"]
        | NttManagerArgs["tuple"]["get_rate_duration(byte[32])uint64"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.getRateDuration(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["get_rate_duration(byte[32])uint64"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `update_min_upgrade_delay(uint64,uint64)void` ABI method.
     *
    * Schedule a change in the minimum delay needed for an upgrade.
    Automatically comes into effect at given timestamp.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateMinUpgradeDelay: async (
      params: CallParams<
        | NttManagerArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
        | NttManagerArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.updateMinUpgradeDelay(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["update_min_upgrade_delay(uint64,uint64)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `schedule_contract_upgrade(byte[32],uint64)void` ABI method.
     *
    * Schedule the upgrade of the contract.
    The upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    scheduleContractUpgrade: async (
      params: CallParams<
        | NttManagerArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
        | NttManagerArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.scheduleContractUpgrade(params));
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | NttManagerReturns["schedule_contract_upgrade(byte[32],uint64)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `cancel_contract_upgrade()void` ABI method.
     *
     * Cancel the scheduled upgrade
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    cancelContractUpgrade: async (
      params: CallParams<
        | NttManagerArgs["obj"]["cancel_contract_upgrade()void"]
        | NttManagerArgs["tuple"]["cancel_contract_upgrade()void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.cancelContractUpgrade(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["cancel_contract_upgrade()void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `upgradable_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the upgradeable admin role
     *
     * @param params The params for the smart contract call
     * @returns The call result: Role bytes of length 16
     */
    upgradableAdminRole: async (
      params: CallParams<
        | NttManagerArgs["obj"]["upgradable_admin_role()byte[16]"]
        | NttManagerArgs["tuple"]["upgradable_admin_role()byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.upgradableAdminRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["upgradable_admin_role()byte[16]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `max_for_min_upgrade_delay()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the maximum delay allowed for the minimum upgrade delay
    This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

     *
     * @param params The params for the smart contract call
     * @returns The call result: The maximum minimum upgrade delay
     */
    maxForMinUpgradeDelay: async (
      params: CallParams<
        | NttManagerArgs["obj"]["max_for_min_upgrade_delay()uint64"]
        | NttManagerArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.maxForMinUpgradeDelay(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["max_for_min_upgrade_delay()uint64"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_active_min_upgrade_delay()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
     *
     * @param params The params for the smart contract call
     * @returns The call result: The active minimum upgrade delay
     */
    getActiveMinUpgradeDelay: async (
      params: CallParams<
        | NttManagerArgs["obj"]["get_active_min_upgrade_delay()uint64"]
        | NttManagerArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.getActiveMinUpgradeDelay(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["get_active_min_upgrade_delay()uint64"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `grant_role(byte[16],address)void` ABI method.
     *
    * Grant a role to an account
    Increases the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    grantRole: async (
      params: CallParams<
        | NttManagerArgs["obj"]["grant_role(byte[16],address)void"]
        | NttManagerArgs["tuple"]["grant_role(byte[16],address)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.grantRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["grant_role(byte[16],address)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `revoke_role(byte[16],address)void` ABI method.
     *
    * Revokes a role from an account
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    revokeRole: async (
      params: CallParams<
        | NttManagerArgs["obj"]["revoke_role(byte[16],address)void"]
        | NttManagerArgs["tuple"]["revoke_role(byte[16],address)void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.revokeRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["revoke_role(byte[16],address)void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `renounce_role(byte[16])void` ABI method.
     *
    * Revokes a role from the caller
    Reduces the MBR for the contract's ledger balance.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    renounceRole: async (
      params: CallParams<
        NttManagerArgs["obj"]["renounce_role(byte[16])void"] | NttManagerArgs["tuple"]["renounce_role(byte[16])void"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.renounceRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["renounce_role(byte[16])void"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `default_admin_role()byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the role identifier for the default admin role
     *
     * @param params The params for the smart contract call
     * @returns The call result: Empty bytes of length 16
     */
    defaultAdminRole: async (
      params: CallParams<
        NttManagerArgs["obj"]["default_admin_role()byte[16]"] | NttManagerArgs["tuple"]["default_admin_role()byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC } = {
        args: [],
      },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.defaultAdminRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["default_admin_role()byte[16]"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `has_role(byte[16],address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns whether the account has been granted a role
     *
     * @param params The params for the smart contract call
     * @returns The call result: Whether the account has been granted a role
     */
    hasRole: async (
      params: CallParams<
        | NttManagerArgs["obj"]["has_role(byte[16],address)bool"]
        | NttManagerArgs["tuple"]["has_role(byte[16],address)bool"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.hasRole(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["has_role(byte[16],address)bool"],
      };
    },

    /**
     * Makes a call to the NttManager smart contract using the `get_role_admin(byte[16])byte[16]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the admin role that controls a role
     *
     * @param params The params for the smart contract call
     * @returns The call result: The role admin
     */
    getRoleAdmin: async (
      params: CallParams<
        | NttManagerArgs["obj"]["get_role_admin(byte[16])byte[16]"]
        | NttManagerArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOpOC },
    ) => {
      const result = await this.appClient.send.call(NttManagerParamsFactory.getRoleAdmin(params));
      return {
        ...result,
        return: result.return as unknown as undefined | NttManagerReturns["get_role_admin(byte[16])byte[16]"],
      };
    },
  };

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new NttManagerClient(this.appClient.clone(params));
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `ntt_manager_admin_role()byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async nttManagerAdminRole(
    params: CallParams<
      | NttManagerArgs["obj"]["ntt_manager_admin_role()byte[16]"]
      | NttManagerArgs["tuple"]["ntt_manager_admin_role()byte[16]"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.nttManagerAdminRole(params));
    return result.return as unknown as NttManagerReturns["ntt_manager_admin_role()byte[16]"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `pauser_role()byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async pauserRole(
    params: CallParams<
      NttManagerArgs["obj"]["pauser_role()byte[16]"] | NttManagerArgs["tuple"]["pauser_role()byte[16]"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.pauserRole(params));
    return result.return as unknown as NttManagerReturns["pauser_role()byte[16]"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `unpauser_role()byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async unpauserRole(
    params: CallParams<
      NttManagerArgs["obj"]["unpauser_role()byte[16]"] | NttManagerArgs["tuple"]["unpauser_role()byte[16]"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.unpauserRole(params));
    return result.return as unknown as NttManagerReturns["unpauser_role()byte[16]"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `get_ntt_manager_peer(uint16)(byte[32],uint8)` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getNttManagerPeer(
    params: CallParams<
      | NttManagerArgs["obj"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
      | NttManagerArgs["tuple"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.getNttManagerPeer(params));
    return result.return as unknown as NttManagerReturns["get_ntt_manager_peer(uint16)(byte[32],uint8)"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `is_message_approved(byte[32])bool` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns whether a message has been approved.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async isMessageApproved(
    params: CallParams<
      | NttManagerArgs["obj"]["is_message_approved(byte[32])bool"]
      | NttManagerArgs["tuple"]["is_message_approved(byte[32])bool"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.isMessageApproved(params));
    return result.return as unknown as NttManagerReturns["is_message_approved(byte[32])bool"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `is_message_executed(byte[32])bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Returns whether a message has been executed.
  Note that a message can be executed without being approved if the threshold is increased after execution.

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async isMessageExecuted(
    params: CallParams<
      | NttManagerArgs["obj"]["is_message_executed(byte[32])bool"]
      | NttManagerArgs["tuple"]["is_message_executed(byte[32])bool"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.isMessageExecuted(params));
    return result.return as unknown as NttManagerReturns["is_message_executed(byte[32])bool"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `get_current_outbound_capacity()uint256` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the current capacity of the outbound.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getCurrentOutboundCapacity(
    params: CallParams<
      | NttManagerArgs["obj"]["get_current_outbound_capacity()uint256"]
      | NttManagerArgs["tuple"]["get_current_outbound_capacity()uint256"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.getCurrentOutboundCapacity(params));
    return result.return as unknown as NttManagerReturns["get_current_outbound_capacity()uint256"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get the details of an outbound queued transfer.
   *
   * @param params The params for the smart contract call
   * @returns The call result: Tuple of whether the transfer can be completed and the details of the transfer request.
   */
  async getOutboundQueuedTransfer(
    params: CallParams<
      | NttManagerArgs["obj"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
      | NttManagerArgs["tuple"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.getOutboundQueuedTransfer(params));
    return result.return as unknown as NttManagerReturns["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `get_current_inbound_capacity(uint16)uint256` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the current capacity of the inbound bucket of the given chain.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getCurrentInboundCapacity(
    params: CallParams<
      | NttManagerArgs["obj"]["get_current_inbound_capacity(uint16)uint256"]
      | NttManagerArgs["tuple"]["get_current_inbound_capacity(uint16)uint256"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.getCurrentInboundCapacity(params));
    return result.return as unknown as NttManagerReturns["get_current_inbound_capacity(uint16)uint256"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get the details of an inbound queued transfer.
   *
   * @param params The params for the smart contract call
   * @returns The call result: Tuple of whether the transfer can be completed and the details of the transfer request.
   */
  async getInboundQueuedTransfer(
    params: CallParams<
      | NttManagerArgs["obj"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
      | NttManagerArgs["tuple"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.getInboundQueuedTransfer(params));
    return result.return as unknown as NttManagerReturns["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `inbound_bucket_id(uint16)byte[32]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async inboundBucketId(
    params: CallParams<
      | NttManagerArgs["obj"]["inbound_bucket_id(uint16)byte[32]"]
      | NttManagerArgs["tuple"]["inbound_bucket_id(uint16)byte[32]"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.inboundBucketId(params));
    return result.return as unknown as NttManagerReturns["inbound_bucket_id(uint16)byte[32]"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `outbound_bucket_id()byte[32]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async outboundBucketId(
    params: CallParams<
      NttManagerArgs["obj"]["outbound_bucket_id()byte[32]"] | NttManagerArgs["tuple"]["outbound_bucket_id()byte[32]"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.outboundBucketId(params));
    return result.return as unknown as NttManagerReturns["outbound_bucket_id()byte[32]"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `rate_limiter_manager_role()byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async rateLimiterManagerRole(
    params: CallParams<
      | NttManagerArgs["obj"]["rate_limiter_manager_role()byte[16]"]
      | NttManagerArgs["tuple"]["rate_limiter_manager_role()byte[16]"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.rateLimiterManagerRole(params));
    return result.return as unknown as NttManagerReturns["rate_limiter_manager_role()byte[16]"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `get_current_capacity(byte[32])uint256` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Returns the current capacity of the bucket were it to be updated.
  If you call this method (as opposed to simulate) then the capacity will be updated on chain.
  You should NOT use this method to determine if there is sufficient capacity because a `duration` of zero is interpreted as an infinite bucket regardless of the `current_capacity. Instead, use `has_capacity()`.

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getCurrentCapacity(
    params: CallParams<
      | NttManagerArgs["obj"]["get_current_capacity(byte[32])uint256"]
      | NttManagerArgs["tuple"]["get_current_capacity(byte[32])uint256"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.getCurrentCapacity(params));
    return result.return as unknown as NttManagerReturns["get_current_capacity(byte[32])uint256"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `has_capacity(byte[32],uint256)bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Returns whether there's sufficient capacity inside bucket for amount.
  If you call this method (as opposed to simulate) then the capacity will be updated on chain.

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async hasCapacity(
    params: CallParams<
      | NttManagerArgs["obj"]["has_capacity(byte[32],uint256)bool"]
      | NttManagerArgs["tuple"]["has_capacity(byte[32],uint256)bool"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.hasCapacity(params));
    return result.return as unknown as NttManagerReturns["has_capacity(byte[32],uint256)bool"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `get_rate_limit(byte[32])uint256` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the rate limit of the bucket
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getRateLimit(
    params: CallParams<
      | NttManagerArgs["obj"]["get_rate_limit(byte[32])uint256"]
      | NttManagerArgs["tuple"]["get_rate_limit(byte[32])uint256"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.getRateLimit(params));
    return result.return as unknown as NttManagerReturns["get_rate_limit(byte[32])uint256"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `get_rate_duration(byte[32])uint64` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the rate duration of the bucket
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getRateDuration(
    params: CallParams<
      | NttManagerArgs["obj"]["get_rate_duration(byte[32])uint64"]
      | NttManagerArgs["tuple"]["get_rate_duration(byte[32])uint64"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.getRateDuration(params));
    return result.return as unknown as NttManagerReturns["get_rate_duration(byte[32])uint64"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `upgradable_admin_role()byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the role identifier for the upgradeable admin role
   *
   * @param params The params for the smart contract call
   * @returns The call result: Role bytes of length 16
   */
  async upgradableAdminRole(
    params: CallParams<
      | NttManagerArgs["obj"]["upgradable_admin_role()byte[16]"]
      | NttManagerArgs["tuple"]["upgradable_admin_role()byte[16]"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.upgradableAdminRole(params));
    return result.return as unknown as NttManagerReturns["upgradable_admin_role()byte[16]"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `max_for_min_upgrade_delay()uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Returns the maximum delay allowed for the minimum upgrade delay
  This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

   *
   * @param params The params for the smart contract call
   * @returns The call result: The maximum minimum upgrade delay
   */
  async maxForMinUpgradeDelay(
    params: CallParams<
      | NttManagerArgs["obj"]["max_for_min_upgrade_delay()uint64"]
      | NttManagerArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.maxForMinUpgradeDelay(params));
    return result.return as unknown as NttManagerReturns["max_for_min_upgrade_delay()uint64"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `get_active_min_upgrade_delay()uint64` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
   *
   * @param params The params for the smart contract call
   * @returns The call result: The active minimum upgrade delay
   */
  async getActiveMinUpgradeDelay(
    params: CallParams<
      | NttManagerArgs["obj"]["get_active_min_upgrade_delay()uint64"]
      | NttManagerArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.getActiveMinUpgradeDelay(params));
    return result.return as unknown as NttManagerReturns["get_active_min_upgrade_delay()uint64"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `default_admin_role()byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the role identifier for the default admin role
   *
   * @param params The params for the smart contract call
   * @returns The call result: Empty bytes of length 16
   */
  async defaultAdminRole(
    params: CallParams<
      NttManagerArgs["obj"]["default_admin_role()byte[16]"] | NttManagerArgs["tuple"]["default_admin_role()byte[16]"]
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.defaultAdminRole(params));
    return result.return as unknown as NttManagerReturns["default_admin_role()byte[16]"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `has_role(byte[16],address)bool` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns whether the account has been granted a role
   *
   * @param params The params for the smart contract call
   * @returns The call result: Whether the account has been granted a role
   */
  async hasRole(
    params: CallParams<
      | NttManagerArgs["obj"]["has_role(byte[16],address)bool"]
      | NttManagerArgs["tuple"]["has_role(byte[16],address)bool"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.hasRole(params));
    return result.return as unknown as NttManagerReturns["has_role(byte[16],address)bool"];
  }

  /**
   * Makes a readonly (simulated) call to the NttManager smart contract using the `get_role_admin(byte[16])byte[16]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the admin role that controls a role
   *
   * @param params The params for the smart contract call
   * @returns The call result: The role admin
   */
  async getRoleAdmin(
    params: CallParams<
      | NttManagerArgs["obj"]["get_role_admin(byte[16])byte[16]"]
      | NttManagerArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
    >,
  ) {
    const result = await this.appClient.send.call(NttManagerParamsFactory.getRoleAdmin(params));
    return result.return as unknown as NttManagerReturns["get_role_admin(byte[16])byte[16]"];
  }

  /**
   * Methods to access state for the current NttManager app
   */
  state = {
    /**
     * Methods to access global state for the current NttManager app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll();
        return {
          isInitialised: result.is_initialised,
          minUpgradeDelay: result.min_upgrade_delay,
          scheduledContractUpgrade: result.scheduled_contract_upgrade,
          version: result.version,
          transceiverManager: result.transceiver_manager,
          threshold: result.threshold,
          isPaused: result.is_paused,
          assetId: result.asset_id,
          nttToken: result.ntt_token,
          messageSequence: result.message_sequence,
          chainId: result.chain_id,
        };
      },
      /**
       * Get the current value of the is_initialised key in global state
       */
      isInitialised: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("is_initialised")) as bigint | undefined;
      },
      /**
       * Get the current value of the min_upgrade_delay key in global state
       */
      minUpgradeDelay: async (): Promise<MinimumUpgradeDelay | undefined> => {
        return (await this.appClient.state.global.getValue("min_upgrade_delay")) as MinimumUpgradeDelay | undefined;
      },
      /**
       * Get the current value of the scheduled_contract_upgrade key in global state
       */
      scheduledContractUpgrade: async (): Promise<ScheduledContractUpgrade | undefined> => {
        return (await this.appClient.state.global.getValue("scheduled_contract_upgrade")) as
          | ScheduledContractUpgrade
          | undefined;
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("version")) as bigint | undefined;
      },
      /**
       * Get the current value of the transceiver_manager key in global state
       */
      transceiverManager: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("transceiver_manager")) as bigint | undefined;
      },
      /**
       * Get the current value of the threshold key in global state
       */
      threshold: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("threshold")) as bigint | undefined;
      },
      /**
       * Get the current value of the is_paused key in global state
       */
      isPaused: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("is_paused")) as bigint | undefined;
      },
      /**
       * Get the current value of the asset_id key in global state
       */
      assetId: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("asset_id")) as bigint | undefined;
      },
      /**
       * Get the current value of the ntt_token key in global state
       */
      nttToken: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("ntt_token")) as bigint | undefined;
      },
      /**
       * Get the current value of the message_sequence key in global state
       */
      messageSequence: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue("message_sequence")) as bigint | undefined;
      },
      /**
       * Get the current value of the chain_id key in global state
       */
      chainId: async (): Promise<number | undefined> => {
        return (await this.appClient.state.global.getValue("chain_id")) as number | undefined;
      },
    },
    /**
     * Methods to access box state for the current NttManager app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll();
        return {};
      },
      /**
       * Get values from the roles map in box state
       */
      roles: {
        /**
         * Get all current values of the roles map in box state
         */
        getMap: async (): Promise<Map<Uint8Array, Uint8Array>> => {
          return (await this.appClient.state.box.getMap("roles")) as Map<Uint8Array, Uint8Array>;
        },
        /**
         * Get a current value of the roles map by key from box state
         */
        value: async (key: Uint8Array): Promise<Uint8Array | undefined> => {
          return (await this.appClient.state.box.getMapValue("roles", key)) as Uint8Array | undefined;
        },
      },
      /**
       * Get values from the addresses_roles map in box state
       */
      addressesRoles: {
        /**
         * Get all current values of the addresses_roles map in box state
         */
        getMap: async (): Promise<Map<AddressRoleKey, boolean>> => {
          return (await this.appClient.state.box.getMap("addresses_roles")) as Map<AddressRoleKey, boolean>;
        },
        /**
         * Get a current value of the addresses_roles map by key from box state
         */
        value: async (key: AddressRoleKey): Promise<boolean | undefined> => {
          return (await this.appClient.state.box.getMapValue("addresses_roles", key)) as boolean | undefined;
        },
      },
      /**
       * Get values from the rate_limit_buckets map in box state
       */
      rateLimitBuckets: {
        /**
         * Get all current values of the rate_limit_buckets map in box state
         */
        getMap: async (): Promise<Map<Uint8Array, RateLimitBucket>> => {
          return (await this.appClient.state.box.getMap("rate_limit_buckets")) as Map<Uint8Array, RateLimitBucket>;
        },
        /**
         * Get a current value of the rate_limit_buckets map by key from box state
         */
        value: async (key: Uint8Array): Promise<RateLimitBucket | undefined> => {
          return (await this.appClient.state.box.getMapValue("rate_limit_buckets", key)) as RateLimitBucket | undefined;
        },
      },
      /**
       * Get values from the outbound_queued_transfers map in box state
       */
      outboundQueuedTransfers: {
        /**
         * Get all current values of the outbound_queued_transfers map in box state
         */
        getMap: async (): Promise<Map<Uint8Array, OutboundQueuedTransfer>> => {
          return (await this.appClient.state.box.getMap("outbound_queued_transfers")) as Map<
            Uint8Array,
            OutboundQueuedTransfer
          >;
        },
        /**
         * Get a current value of the outbound_queued_transfers map by key from box state
         */
        value: async (key: Uint8Array): Promise<OutboundQueuedTransfer | undefined> => {
          return (await this.appClient.state.box.getMapValue("outbound_queued_transfers", key)) as
            | OutboundQueuedTransfer
            | undefined;
        },
      },
      /**
       * Get values from the inbound_queued_transfers map in box state
       */
      inboundQueuedTransfers: {
        /**
         * Get all current values of the inbound_queued_transfers map in box state
         */
        getMap: async (): Promise<Map<Uint8Array, InboundQueuedTransfer>> => {
          return (await this.appClient.state.box.getMap("inbound_queued_transfers")) as Map<
            Uint8Array,
            InboundQueuedTransfer
          >;
        },
        /**
         * Get a current value of the inbound_queued_transfers map by key from box state
         */
        value: async (key: Uint8Array): Promise<InboundQueuedTransfer | undefined> => {
          return (await this.appClient.state.box.getMapValue("inbound_queued_transfers", key)) as
            | InboundQueuedTransfer
            | undefined;
        },
      },
      /**
       * Get values from the messages_executed map in box state
       */
      messagesExecuted: {
        /**
         * Get all current values of the messages_executed map in box state
         */
        getMap: async (): Promise<Map<Uint8Array, boolean>> => {
          return (await this.appClient.state.box.getMap("messages_executed")) as Map<Uint8Array, boolean>;
        },
        /**
         * Get a current value of the messages_executed map by key from box state
         */
        value: async (key: Uint8Array): Promise<boolean | undefined> => {
          return (await this.appClient.state.box.getMapValue("messages_executed", key)) as boolean | undefined;
        },
      },
      /**
       * Get values from the ntt_manager_peers map in box state
       */
      nttManagerPeers: {
        /**
         * Get all current values of the ntt_manager_peers map in box state
         */
        getMap: async (): Promise<Map<number, NttManagerPeer>> => {
          return (await this.appClient.state.box.getMap("ntt_manager_peers")) as Map<number, NttManagerPeer>;
        },
        /**
         * Get a current value of the ntt_manager_peers map by key from box state
         */
        value: async (key: bigint | number): Promise<NttManagerPeer | undefined> => {
          return (await this.appClient.state.box.getMapValue("ntt_manager_peers", key)) as NttManagerPeer | undefined;
        },
      },
    },
  };

  public newGroup(): NttManagerComposer {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain: Promise<unknown> = Promise.resolve();
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = [];
    return {
      /**
       * Add a initialise(address,uint64)void method call against the NttManager contract
       */
      initialise(
        params: CallParams<
          | NttManagerArgs["obj"]["initialise(address,uint64)void"]
          | NttManagerArgs["tuple"]["initialise(address,uint64)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.initialise(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a pause()void method call against the NttManager contract
       */
      pause(
        params: CallParams<NttManagerArgs["obj"]["pause()void"] | NttManagerArgs["tuple"]["pause()void"]> & {
          onComplete?: OnApplicationComplete.NoOpOC;
        },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.pause(params)));
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a unpause()void method call against the NttManager contract
       */
      unpause(
        params: CallParams<NttManagerArgs["obj"]["unpause()void"] | NttManagerArgs["tuple"]["unpause()void"]> & {
          onComplete?: OnApplicationComplete.NoOpOC;
        },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.unpause(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a set_transceiver_manager(address,uint64)void method call against the NttManager contract
       */
      setTransceiverManager(
        params: CallParams<
          | NttManagerArgs["obj"]["set_transceiver_manager(address,uint64)void"]
          | NttManagerArgs["tuple"]["set_transceiver_manager(address,uint64)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.setTransceiverManager(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a set_threshold(uint64)void method call against the NttManager contract
       */
      setThreshold(
        params: CallParams<
          NttManagerArgs["obj"]["set_threshold(uint64)void"] | NttManagerArgs["tuple"]["set_threshold(uint64)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.setThreshold(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a set_ntt_manager_peer(uint16,byte[32],uint8)void method call against the NttManager contract
       */
      setNttManagerPeer(
        params: CallParams<
          | NttManagerArgs["obj"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
          | NttManagerArgs["tuple"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.setNttManagerPeer(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a transfer(pay,axfer,uint64,uint16,byte[32])byte[32] method call against the NttManager contract
       */
      transfer(
        params: CallParams<
          | NttManagerArgs["obj"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
          | NttManagerArgs["tuple"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.transfer(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("transfer(pay,axfer,uint64,uint16,byte[32])byte[32]", v));
        return this;
      },
      /**
       * Add a transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32] method call against the NttManager contract
       */
      transferFull(
        params: CallParams<
          | NttManagerArgs["obj"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
          | NttManagerArgs["tuple"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.transferFull(params)),
        );
        resultMappers.push((v) =>
          client.decodeReturnValue("transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]", v),
        );
        return this;
      },
      /**
       * Add a complete_outbound_queued_transfer(pay,byte[32])byte[32] method call against the NttManager contract
       */
      completeOutboundQueuedTransfer(
        params: CallParams<
          | NttManagerArgs["obj"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
          | NttManagerArgs["tuple"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.completeOutboundQueuedTransfer(params)),
        );
        resultMappers.push((v) =>
          client.decodeReturnValue("complete_outbound_queued_transfer(pay,byte[32])byte[32]", v),
        );
        return this;
      },
      /**
       * Add a cancel_outbound_queued_transfer(byte[32])void method call against the NttManager contract
       */
      cancelOutboundQueuedTransfer(
        params: CallParams<
          | NttManagerArgs["obj"]["cancel_outbound_queued_transfer(byte[32])void"]
          | NttManagerArgs["tuple"]["cancel_outbound_queued_transfer(byte[32])void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.cancelOutboundQueuedTransfer(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a complete_inbound_queued_transfer(byte[32])void method call against the NttManager contract
       */
      completeInboundQueuedTransfer(
        params: CallParams<
          | NttManagerArgs["obj"]["complete_inbound_queued_transfer(byte[32])void"]
          | NttManagerArgs["tuple"]["complete_inbound_queued_transfer(byte[32])void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.completeInboundQueuedTransfer(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a ntt_manager_admin_role()byte[16] method call against the NttManager contract
       */
      nttManagerAdminRole(
        params: CallParams<
          | NttManagerArgs["obj"]["ntt_manager_admin_role()byte[16]"]
          | NttManagerArgs["tuple"]["ntt_manager_admin_role()byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.nttManagerAdminRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("ntt_manager_admin_role()byte[16]", v));
        return this;
      },
      /**
       * Add a pauser_role()byte[16] method call against the NttManager contract
       */
      pauserRole(
        params: CallParams<
          NttManagerArgs["obj"]["pauser_role()byte[16]"] | NttManagerArgs["tuple"]["pauser_role()byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.pauserRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("pauser_role()byte[16]", v));
        return this;
      },
      /**
       * Add a unpauser_role()byte[16] method call against the NttManager contract
       */
      unpauserRole(
        params: CallParams<
          NttManagerArgs["obj"]["unpauser_role()byte[16]"] | NttManagerArgs["tuple"]["unpauser_role()byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.unpauserRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("unpauser_role()byte[16]", v));
        return this;
      },
      /**
       * Add a get_ntt_manager_peer(uint16)(byte[32],uint8) method call against the NttManager contract
       */
      getNttManagerPeer(
        params: CallParams<
          | NttManagerArgs["obj"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
          | NttManagerArgs["tuple"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getNttManagerPeer(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_ntt_manager_peer(uint16)(byte[32],uint8)", v));
        return this;
      },
      /**
       * Add a execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void method call against the NttManager contract
       */
      executeMessage(
        params: CallParams<
          | NttManagerArgs["obj"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
          | NttManagerArgs["tuple"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.executeMessage(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a is_message_approved(byte[32])bool method call against the NttManager contract
       */
      isMessageApproved(
        params: CallParams<
          | NttManagerArgs["obj"]["is_message_approved(byte[32])bool"]
          | NttManagerArgs["tuple"]["is_message_approved(byte[32])bool"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.isMessageApproved(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("is_message_approved(byte[32])bool", v));
        return this;
      },
      /**
       * Add a is_message_executed(byte[32])bool method call against the NttManager contract
       */
      isMessageExecuted(
        params: CallParams<
          | NttManagerArgs["obj"]["is_message_executed(byte[32])bool"]
          | NttManagerArgs["tuple"]["is_message_executed(byte[32])bool"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.isMessageExecuted(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("is_message_executed(byte[32])bool", v));
        return this;
      },
      /**
       * Add a set_outbound_rate_limit(uint256)void method call against the NttManager contract
       */
      setOutboundRateLimit(
        params: CallParams<
          | NttManagerArgs["obj"]["set_outbound_rate_limit(uint256)void"]
          | NttManagerArgs["tuple"]["set_outbound_rate_limit(uint256)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.setOutboundRateLimit(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a set_outbound_rate_duration(uint64)void method call against the NttManager contract
       */
      setOutboundRateDuration(
        params: CallParams<
          | NttManagerArgs["obj"]["set_outbound_rate_duration(uint64)void"]
          | NttManagerArgs["tuple"]["set_outbound_rate_duration(uint64)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.setOutboundRateDuration(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a set_inbound_rate_limit(uint16,uint256)void method call against the NttManager contract
       */
      setInboundRateLimit(
        params: CallParams<
          | NttManagerArgs["obj"]["set_inbound_rate_limit(uint16,uint256)void"]
          | NttManagerArgs["tuple"]["set_inbound_rate_limit(uint16,uint256)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.setInboundRateLimit(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a set_inbound_rate_duration(uint16,uint64)void method call against the NttManager contract
       */
      setInboundRateDuration(
        params: CallParams<
          | NttManagerArgs["obj"]["set_inbound_rate_duration(uint16,uint64)void"]
          | NttManagerArgs["tuple"]["set_inbound_rate_duration(uint16,uint64)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.setInboundRateDuration(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a get_current_outbound_capacity()uint256 method call against the NttManager contract
       */
      getCurrentOutboundCapacity(
        params: CallParams<
          | NttManagerArgs["obj"]["get_current_outbound_capacity()uint256"]
          | NttManagerArgs["tuple"]["get_current_outbound_capacity()uint256"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getCurrentOutboundCapacity(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_current_outbound_capacity()uint256", v));
        return this;
      },
      /**
       * Add a get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[])) method call against the NttManager contract
       */
      getOutboundQueuedTransfer(
        params: CallParams<
          | NttManagerArgs["obj"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
          | NttManagerArgs["tuple"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getOutboundQueuedTransfer(params)),
        );
        resultMappers.push((v) =>
          client.decodeReturnValue(
            "get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))",
            v,
          ),
        );
        return this;
      },
      /**
       * Add a get_current_inbound_capacity(uint16)uint256 method call against the NttManager contract
       */
      getCurrentInboundCapacity(
        params: CallParams<
          | NttManagerArgs["obj"]["get_current_inbound_capacity(uint16)uint256"]
          | NttManagerArgs["tuple"]["get_current_inbound_capacity(uint16)uint256"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getCurrentInboundCapacity(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_current_inbound_capacity(uint16)uint256", v));
        return this;
      },
      /**
       * Add a get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address)) method call against the NttManager contract
       */
      getInboundQueuedTransfer(
        params: CallParams<
          | NttManagerArgs["obj"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
          | NttManagerArgs["tuple"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getInboundQueuedTransfer(params)),
        );
        resultMappers.push((v) =>
          client.decodeReturnValue(
            "get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))",
            v,
          ),
        );
        return this;
      },
      /**
       * Add a inbound_bucket_id(uint16)byte[32] method call against the NttManager contract
       */
      inboundBucketId(
        params: CallParams<
          | NttManagerArgs["obj"]["inbound_bucket_id(uint16)byte[32]"]
          | NttManagerArgs["tuple"]["inbound_bucket_id(uint16)byte[32]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.inboundBucketId(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("inbound_bucket_id(uint16)byte[32]", v));
        return this;
      },
      /**
       * Add a outbound_bucket_id()byte[32] method call against the NttManager contract
       */
      outboundBucketId(
        params: CallParams<
          | NttManagerArgs["obj"]["outbound_bucket_id()byte[32]"]
          | NttManagerArgs["tuple"]["outbound_bucket_id()byte[32]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.outboundBucketId(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("outbound_bucket_id()byte[32]", v));
        return this;
      },
      /**
       * Add a rate_limiter_manager_role()byte[16] method call against the NttManager contract
       */
      rateLimiterManagerRole(
        params: CallParams<
          | NttManagerArgs["obj"]["rate_limiter_manager_role()byte[16]"]
          | NttManagerArgs["tuple"]["rate_limiter_manager_role()byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.rateLimiterManagerRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("rate_limiter_manager_role()byte[16]", v));
        return this;
      },
      /**
       * Add a get_current_capacity(byte[32])uint256 method call against the NttManager contract
       */
      getCurrentCapacity(
        params: CallParams<
          | NttManagerArgs["obj"]["get_current_capacity(byte[32])uint256"]
          | NttManagerArgs["tuple"]["get_current_capacity(byte[32])uint256"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getCurrentCapacity(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_current_capacity(byte[32])uint256", v));
        return this;
      },
      /**
       * Add a has_capacity(byte[32],uint256)bool method call against the NttManager contract
       */
      hasCapacity(
        params: CallParams<
          | NttManagerArgs["obj"]["has_capacity(byte[32],uint256)bool"]
          | NttManagerArgs["tuple"]["has_capacity(byte[32],uint256)bool"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.hasCapacity(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("has_capacity(byte[32],uint256)bool", v));
        return this;
      },
      /**
       * Add a get_rate_limit(byte[32])uint256 method call against the NttManager contract
       */
      getRateLimit(
        params: CallParams<
          | NttManagerArgs["obj"]["get_rate_limit(byte[32])uint256"]
          | NttManagerArgs["tuple"]["get_rate_limit(byte[32])uint256"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getRateLimit(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_rate_limit(byte[32])uint256", v));
        return this;
      },
      /**
       * Add a get_rate_duration(byte[32])uint64 method call against the NttManager contract
       */
      getRateDuration(
        params: CallParams<
          | NttManagerArgs["obj"]["get_rate_duration(byte[32])uint64"]
          | NttManagerArgs["tuple"]["get_rate_duration(byte[32])uint64"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getRateDuration(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_rate_duration(byte[32])uint64", v));
        return this;
      },
      /**
       * Add a update_min_upgrade_delay(uint64,uint64)void method call against the NttManager contract
       */
      updateMinUpgradeDelay(
        params: CallParams<
          | NttManagerArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
          | NttManagerArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.updateMinUpgradeDelay(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a schedule_contract_upgrade(byte[32],uint64)void method call against the NttManager contract
       */
      scheduleContractUpgrade(
        params: CallParams<
          | NttManagerArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
          | NttManagerArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.scheduleContractUpgrade(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a cancel_contract_upgrade()void method call against the NttManager contract
       */
      cancelContractUpgrade(
        params: CallParams<
          | NttManagerArgs["obj"]["cancel_contract_upgrade()void"]
          | NttManagerArgs["tuple"]["cancel_contract_upgrade()void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.cancelContractUpgrade(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a upgradable_admin_role()byte[16] method call against the NttManager contract
       */
      upgradableAdminRole(
        params: CallParams<
          | NttManagerArgs["obj"]["upgradable_admin_role()byte[16]"]
          | NttManagerArgs["tuple"]["upgradable_admin_role()byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.upgradableAdminRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("upgradable_admin_role()byte[16]", v));
        return this;
      },
      /**
       * Add a max_for_min_upgrade_delay()uint64 method call against the NttManager contract
       */
      maxForMinUpgradeDelay(
        params: CallParams<
          | NttManagerArgs["obj"]["max_for_min_upgrade_delay()uint64"]
          | NttManagerArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.maxForMinUpgradeDelay(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("max_for_min_upgrade_delay()uint64", v));
        return this;
      },
      /**
       * Add a get_active_min_upgrade_delay()uint64 method call against the NttManager contract
       */
      getActiveMinUpgradeDelay(
        params: CallParams<
          | NttManagerArgs["obj"]["get_active_min_upgrade_delay()uint64"]
          | NttManagerArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getActiveMinUpgradeDelay(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_active_min_upgrade_delay()uint64", v));
        return this;
      },
      /**
       * Add a grant_role(byte[16],address)void method call against the NttManager contract
       */
      grantRole(
        params: CallParams<
          | NttManagerArgs["obj"]["grant_role(byte[16],address)void"]
          | NttManagerArgs["tuple"]["grant_role(byte[16],address)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.grantRole(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a revoke_role(byte[16],address)void method call against the NttManager contract
       */
      revokeRole(
        params: CallParams<
          | NttManagerArgs["obj"]["revoke_role(byte[16],address)void"]
          | NttManagerArgs["tuple"]["revoke_role(byte[16],address)void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.revokeRole(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a renounce_role(byte[16])void method call against the NttManager contract
       */
      renounceRole(
        params: CallParams<
          NttManagerArgs["obj"]["renounce_role(byte[16])void"] | NttManagerArgs["tuple"]["renounce_role(byte[16])void"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.renounceRole(params)),
        );
        resultMappers.push(undefined);
        return this;
      },
      /**
       * Add a default_admin_role()byte[16] method call against the NttManager contract
       */
      defaultAdminRole(
        params: CallParams<
          | NttManagerArgs["obj"]["default_admin_role()byte[16]"]
          | NttManagerArgs["tuple"]["default_admin_role()byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.defaultAdminRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("default_admin_role()byte[16]", v));
        return this;
      },
      /**
       * Add a has_role(byte[16],address)bool method call against the NttManager contract
       */
      hasRole(
        params: CallParams<
          | NttManagerArgs["obj"]["has_role(byte[16],address)bool"]
          | NttManagerArgs["tuple"]["has_role(byte[16],address)bool"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.hasRole(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("has_role(byte[16],address)bool", v));
        return this;
      },
      /**
       * Add a get_role_admin(byte[16])byte[16] method call against the NttManager contract
       */
      getRoleAdmin(
        params: CallParams<
          | NttManagerArgs["obj"]["get_role_admin(byte[16])byte[16]"]
          | NttManagerArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
        > & { onComplete?: OnApplicationComplete.NoOpOC },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.getRoleAdmin(params)),
        );
        resultMappers.push((v) => client.decodeReturnValue("get_role_admin(byte[16])byte[16]", v));
        return this;
      },
      get update() {
        return {
          completeContractUpgrade: (
            params: CallParams<
              | NttManagerArgs["obj"]["complete_contract_upgrade()void"]
              | NttManagerArgs["tuple"]["complete_contract_upgrade()void"]
            > &
              AppClientCompilationParams,
          ) => {
            promiseChain = promiseChain.then(async () =>
              composer.addAppUpdateMethodCall(await client.params.update.completeContractUpgrade(params)),
            );
            resultMappers.push(undefined);
            return this;
          },
        };
      },
      /**
       * Add a clear state call to the NttManager contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: result.returns?.map((val, i) =>
            resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue,
          ),
        };
      },
      async send(params?: SendParams) {
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: result.returns?.map((val, i) =>
            resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue,
          ),
        };
      },
    } as unknown as NttManagerComposer;
  }
}
export type NttManagerComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the initialise(address,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  initialise(
    params?: CallParams<
      | NttManagerArgs["obj"]["initialise(address,uint64)void"]
      | NttManagerArgs["tuple"]["initialise(address,uint64)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["initialise(address,uint64)void"] | undefined]>;

  /**
   * Calls the pause()void ABI method.
   *
   * Pause incoming and outgoing transfers in case of emergency.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  pause(
    params?: CallParams<NttManagerArgs["obj"]["pause()void"] | NttManagerArgs["tuple"]["pause()void"]>,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["pause()void"] | undefined]>;

  /**
   * Calls the unpause()void ABI method.
   *
   * Resume incoming and outgoing transfers after previous pause.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  unpause(
    params?: CallParams<NttManagerArgs["obj"]["unpause()void"] | NttManagerArgs["tuple"]["unpause()void"]>,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["unpause()void"] | undefined]>;

  /**
   * Calls the set_transceiver_manager(address,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setTransceiverManager(
    params?: CallParams<
      | NttManagerArgs["obj"]["set_transceiver_manager(address,uint64)void"]
      | NttManagerArgs["tuple"]["set_transceiver_manager(address,uint64)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["set_transceiver_manager(address,uint64)void"] | undefined]>;

  /**
   * Calls the set_threshold(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setThreshold(
    params?: CallParams<
      NttManagerArgs["obj"]["set_threshold(uint64)void"] | NttManagerArgs["tuple"]["set_threshold(uint64)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["set_threshold(uint64)void"] | undefined]>;

  /**
   * Calls the set_ntt_manager_peer(uint16,byte[32],uint8)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setNttManagerPeer(
    params?: CallParams<
      | NttManagerArgs["obj"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
      | NttManagerArgs["tuple"]["set_ntt_manager_peer(uint16,byte[32],uint8)void"]
    >,
  ): NttManagerComposer<
    [...TReturns, NttManagerReturns["set_ntt_manager_peer(uint16,byte[32],uint8)void"] | undefined]
  >;

  /**
   * Calls the transfer(pay,axfer,uint64,uint16,byte[32])byte[32] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  transfer(
    params?: CallParams<
      | NttManagerArgs["obj"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
      | NttManagerArgs["tuple"]["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"]
    >,
  ): NttManagerComposer<
    [...TReturns, NttManagerReturns["transfer(pay,axfer,uint64,uint16,byte[32])byte[32]"] | undefined]
  >;

  /**
   * Calls the transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  transferFull(
    params?: CallParams<
      | NttManagerArgs["obj"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
      | NttManagerArgs["tuple"]["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"]
    >,
  ): NttManagerComposer<
    [
      ...TReturns,
      NttManagerReturns["transfer_full(pay,axfer,uint64,uint16,byte[32],bool,(uint64,byte[])[])byte[32]"] | undefined,
    ]
  >;

  /**
   * Calls the complete_outbound_queued_transfer(pay,byte[32])byte[32] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  completeOutboundQueuedTransfer(
    params?: CallParams<
      | NttManagerArgs["obj"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
      | NttManagerArgs["tuple"]["complete_outbound_queued_transfer(pay,byte[32])byte[32]"]
    >,
  ): NttManagerComposer<
    [...TReturns, NttManagerReturns["complete_outbound_queued_transfer(pay,byte[32])byte[32]"] | undefined]
  >;

  /**
   * Calls the cancel_outbound_queued_transfer(byte[32])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  cancelOutboundQueuedTransfer(
    params?: CallParams<
      | NttManagerArgs["obj"]["cancel_outbound_queued_transfer(byte[32])void"]
      | NttManagerArgs["tuple"]["cancel_outbound_queued_transfer(byte[32])void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["cancel_outbound_queued_transfer(byte[32])void"] | undefined]>;

  /**
   * Calls the complete_inbound_queued_transfer(byte[32])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  completeInboundQueuedTransfer(
    params?: CallParams<
      | NttManagerArgs["obj"]["complete_inbound_queued_transfer(byte[32])void"]
      | NttManagerArgs["tuple"]["complete_inbound_queued_transfer(byte[32])void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["complete_inbound_queued_transfer(byte[32])void"] | undefined]>;

  /**
   * Calls the ntt_manager_admin_role()byte[16] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nttManagerAdminRole(
    params?: CallParams<
      | NttManagerArgs["obj"]["ntt_manager_admin_role()byte[16]"]
      | NttManagerArgs["tuple"]["ntt_manager_admin_role()byte[16]"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["ntt_manager_admin_role()byte[16]"] | undefined]>;

  /**
   * Calls the pauser_role()byte[16] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  pauserRole(
    params?: CallParams<
      NttManagerArgs["obj"]["pauser_role()byte[16]"] | NttManagerArgs["tuple"]["pauser_role()byte[16]"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["pauser_role()byte[16]"] | undefined]>;

  /**
   * Calls the unpauser_role()byte[16] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  unpauserRole(
    params?: CallParams<
      NttManagerArgs["obj"]["unpauser_role()byte[16]"] | NttManagerArgs["tuple"]["unpauser_role()byte[16]"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["unpauser_role()byte[16]"] | undefined]>;

  /**
   * Calls the get_ntt_manager_peer(uint16)(byte[32],uint8) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNttManagerPeer(
    params?: CallParams<
      | NttManagerArgs["obj"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
      | NttManagerArgs["tuple"]["get_ntt_manager_peer(uint16)(byte[32],uint8)"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["get_ntt_manager_peer(uint16)(byte[32],uint8)"] | undefined]>;

  /**
   * Calls the execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void ABI method.
   *
   * Execute a message once the threshold number of attestations has been reached.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  executeMessage(
    params?: CallParams<
      | NttManagerArgs["obj"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
      | NttManagerArgs["tuple"]["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"]
    >,
  ): NttManagerComposer<
    [
      ...TReturns,
      NttManagerReturns["execute_message((byte[32],byte[32],uint16,byte[32],byte[32],byte[]))void"] | undefined,
    ]
  >;

  /**
   * Calls the is_message_approved(byte[32])bool ABI method.
   *
   * Returns whether a message has been approved.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isMessageApproved(
    params?: CallParams<
      | NttManagerArgs["obj"]["is_message_approved(byte[32])bool"]
      | NttManagerArgs["tuple"]["is_message_approved(byte[32])bool"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["is_message_approved(byte[32])bool"] | undefined]>;

  /**
   * Calls the is_message_executed(byte[32])bool ABI method.
   *
  * Returns whether a message has been executed.
  Note that a message can be executed without being approved if the threshold is increased after execution.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isMessageExecuted(
    params?: CallParams<
      | NttManagerArgs["obj"]["is_message_executed(byte[32])bool"]
      | NttManagerArgs["tuple"]["is_message_executed(byte[32])bool"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["is_message_executed(byte[32])bool"] | undefined]>;

  /**
   * Calls the set_outbound_rate_limit(uint256)void ABI method.
   *
   * Set limit for outbound bucket.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setOutboundRateLimit(
    params?: CallParams<
      | NttManagerArgs["obj"]["set_outbound_rate_limit(uint256)void"]
      | NttManagerArgs["tuple"]["set_outbound_rate_limit(uint256)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["set_outbound_rate_limit(uint256)void"] | undefined]>;

  /**
   * Calls the set_outbound_rate_duration(uint64)void ABI method.
   *
   * Set duration for outbound bucket.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setOutboundRateDuration(
    params?: CallParams<
      | NttManagerArgs["obj"]["set_outbound_rate_duration(uint64)void"]
      | NttManagerArgs["tuple"]["set_outbound_rate_duration(uint64)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["set_outbound_rate_duration(uint64)void"] | undefined]>;

  /**
   * Calls the set_inbound_rate_limit(uint16,uint256)void ABI method.
   *
   * Set limit for inbound bucket of the given chain.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setInboundRateLimit(
    params?: CallParams<
      | NttManagerArgs["obj"]["set_inbound_rate_limit(uint16,uint256)void"]
      | NttManagerArgs["tuple"]["set_inbound_rate_limit(uint16,uint256)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["set_inbound_rate_limit(uint16,uint256)void"] | undefined]>;

  /**
   * Calls the set_inbound_rate_duration(uint16,uint64)void ABI method.
   *
   * Set duration for inbound bucket of the given chain.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setInboundRateDuration(
    params?: CallParams<
      | NttManagerArgs["obj"]["set_inbound_rate_duration(uint16,uint64)void"]
      | NttManagerArgs["tuple"]["set_inbound_rate_duration(uint16,uint64)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["set_inbound_rate_duration(uint16,uint64)void"] | undefined]>;

  /**
   * Calls the get_current_outbound_capacity()uint256 ABI method.
   *
   * Returns the current capacity of the outbound.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getCurrentOutboundCapacity(
    params?: CallParams<
      | NttManagerArgs["obj"]["get_current_outbound_capacity()uint256"]
      | NttManagerArgs["tuple"]["get_current_outbound_capacity()uint256"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["get_current_outbound_capacity()uint256"] | undefined]>;

  /**
   * Calls the get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[])) ABI method.
   *
   * Get the details of an outbound queued transfer.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getOutboundQueuedTransfer(
    params?: CallParams<
      | NttManagerArgs["obj"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
      | NttManagerArgs["tuple"]["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
    >,
  ): NttManagerComposer<
    [
      ...TReturns,
      (
        | NttManagerReturns["get_outbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,byte[32],address,(uint64,byte[])[]))"]
        | undefined
      ),
    ]
  >;

  /**
   * Calls the get_current_inbound_capacity(uint16)uint256 ABI method.
   *
   * Returns the current capacity of the inbound bucket of the given chain.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getCurrentInboundCapacity(
    params?: CallParams<
      | NttManagerArgs["obj"]["get_current_inbound_capacity(uint16)uint256"]
      | NttManagerArgs["tuple"]["get_current_inbound_capacity(uint16)uint256"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["get_current_inbound_capacity(uint16)uint256"] | undefined]>;

  /**
   * Calls the get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address)) ABI method.
   *
   * Get the details of an inbound queued transfer.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getInboundQueuedTransfer(
    params?: CallParams<
      | NttManagerArgs["obj"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
      | NttManagerArgs["tuple"]["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
    >,
  ): NttManagerComposer<
    [
      ...TReturns,
      (
        | NttManagerReturns["get_inbound_queued_transfer(byte[32])(bool,(uint64,(uint64,uint8),uint16,address))"]
        | undefined
      ),
    ]
  >;

  /**
   * Calls the inbound_bucket_id(uint16)byte[32] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  inboundBucketId(
    params?: CallParams<
      | NttManagerArgs["obj"]["inbound_bucket_id(uint16)byte[32]"]
      | NttManagerArgs["tuple"]["inbound_bucket_id(uint16)byte[32]"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["inbound_bucket_id(uint16)byte[32]"] | undefined]>;

  /**
   * Calls the outbound_bucket_id()byte[32] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  outboundBucketId(
    params?: CallParams<
      NttManagerArgs["obj"]["outbound_bucket_id()byte[32]"] | NttManagerArgs["tuple"]["outbound_bucket_id()byte[32]"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["outbound_bucket_id()byte[32]"] | undefined]>;

  /**
   * Calls the rate_limiter_manager_role()byte[16] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  rateLimiterManagerRole(
    params?: CallParams<
      | NttManagerArgs["obj"]["rate_limiter_manager_role()byte[16]"]
      | NttManagerArgs["tuple"]["rate_limiter_manager_role()byte[16]"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["rate_limiter_manager_role()byte[16]"] | undefined]>;

  /**
   * Calls the get_current_capacity(byte[32])uint256 ABI method.
   *
  * Returns the current capacity of the bucket were it to be updated.
  If you call this method (as opposed to simulate) then the capacity will be updated on chain.
  You should NOT use this method to determine if there is sufficient capacity because a `duration` of zero is interpreted as an infinite bucket regardless of the `current_capacity. Instead, use `has_capacity()`.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getCurrentCapacity(
    params?: CallParams<
      | NttManagerArgs["obj"]["get_current_capacity(byte[32])uint256"]
      | NttManagerArgs["tuple"]["get_current_capacity(byte[32])uint256"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["get_current_capacity(byte[32])uint256"] | undefined]>;

  /**
   * Calls the has_capacity(byte[32],uint256)bool ABI method.
   *
  * Returns whether there's sufficient capacity inside bucket for amount.
  If you call this method (as opposed to simulate) then the capacity will be updated on chain.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  hasCapacity(
    params?: CallParams<
      | NttManagerArgs["obj"]["has_capacity(byte[32],uint256)bool"]
      | NttManagerArgs["tuple"]["has_capacity(byte[32],uint256)bool"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["has_capacity(byte[32],uint256)bool"] | undefined]>;

  /**
   * Calls the get_rate_limit(byte[32])uint256 ABI method.
   *
   * Returns the rate limit of the bucket
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getRateLimit(
    params?: CallParams<
      | NttManagerArgs["obj"]["get_rate_limit(byte[32])uint256"]
      | NttManagerArgs["tuple"]["get_rate_limit(byte[32])uint256"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["get_rate_limit(byte[32])uint256"] | undefined]>;

  /**
   * Calls the get_rate_duration(byte[32])uint64 ABI method.
   *
   * Returns the rate duration of the bucket
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getRateDuration(
    params?: CallParams<
      | NttManagerArgs["obj"]["get_rate_duration(byte[32])uint64"]
      | NttManagerArgs["tuple"]["get_rate_duration(byte[32])uint64"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["get_rate_duration(byte[32])uint64"] | undefined]>;

  /**
   * Calls the update_min_upgrade_delay(uint64,uint64)void ABI method.
   *
  * Schedule a change in the minimum delay needed for an upgrade.
  Automatically comes into effect at given timestamp.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateMinUpgradeDelay(
    params?: CallParams<
      | NttManagerArgs["obj"]["update_min_upgrade_delay(uint64,uint64)void"]
      | NttManagerArgs["tuple"]["update_min_upgrade_delay(uint64,uint64)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["update_min_upgrade_delay(uint64,uint64)void"] | undefined]>;

  /**
   * Calls the schedule_contract_upgrade(byte[32],uint64)void ABI method.
   *
  * Schedule the upgrade of the contract.
  The upgrade will not automatically come into effect at the scheduled timestamp. Instead, the `complete_contract_upgrade()` must be called to complete the process.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  scheduleContractUpgrade(
    params?: CallParams<
      | NttManagerArgs["obj"]["schedule_contract_upgrade(byte[32],uint64)void"]
      | NttManagerArgs["tuple"]["schedule_contract_upgrade(byte[32],uint64)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["schedule_contract_upgrade(byte[32],uint64)void"] | undefined]>;

  /**
   * Calls the cancel_contract_upgrade()void ABI method.
   *
   * Cancel the scheduled upgrade
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  cancelContractUpgrade(
    params?: CallParams<
      NttManagerArgs["obj"]["cancel_contract_upgrade()void"] | NttManagerArgs["tuple"]["cancel_contract_upgrade()void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["cancel_contract_upgrade()void"] | undefined]>;

  /**
   * Calls the upgradable_admin_role()byte[16] ABI method.
   *
   * Returns the role identifier for the upgradeable admin role
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  upgradableAdminRole(
    params?: CallParams<
      | NttManagerArgs["obj"]["upgradable_admin_role()byte[16]"]
      | NttManagerArgs["tuple"]["upgradable_admin_role()byte[16]"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["upgradable_admin_role()byte[16]"] | undefined]>;

  /**
   * Calls the max_for_min_upgrade_delay()uint64 ABI method.
   *
  * Returns the maximum delay allowed for the minimum upgrade delay
  This is used to prevent the scenario where `get_active_min_upgrade_delay()` is set to a very large value such that it becomes effectively impossible to ever update and schedule an upgrade.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  maxForMinUpgradeDelay(
    params?: CallParams<
      | NttManagerArgs["obj"]["max_for_min_upgrade_delay()uint64"]
      | NttManagerArgs["tuple"]["max_for_min_upgrade_delay()uint64"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["max_for_min_upgrade_delay()uint64"] | undefined]>;

  /**
   * Calls the get_active_min_upgrade_delay()uint64 ABI method.
   *
   * Clarifies the active minimum upgrade delay in cases where there was a scheduled update.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getActiveMinUpgradeDelay(
    params?: CallParams<
      | NttManagerArgs["obj"]["get_active_min_upgrade_delay()uint64"]
      | NttManagerArgs["tuple"]["get_active_min_upgrade_delay()uint64"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["get_active_min_upgrade_delay()uint64"] | undefined]>;

  /**
   * Calls the grant_role(byte[16],address)void ABI method.
   *
  * Grant a role to an account
  Increases the MBR for the contract's ledger balance.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  grantRole(
    params?: CallParams<
      | NttManagerArgs["obj"]["grant_role(byte[16],address)void"]
      | NttManagerArgs["tuple"]["grant_role(byte[16],address)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["grant_role(byte[16],address)void"] | undefined]>;

  /**
   * Calls the revoke_role(byte[16],address)void ABI method.
   *
  * Revokes a role from an account
  Reduces the MBR for the contract's ledger balance.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  revokeRole(
    params?: CallParams<
      | NttManagerArgs["obj"]["revoke_role(byte[16],address)void"]
      | NttManagerArgs["tuple"]["revoke_role(byte[16],address)void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["revoke_role(byte[16],address)void"] | undefined]>;

  /**
   * Calls the renounce_role(byte[16])void ABI method.
   *
  * Revokes a role from the caller
  Reduces the MBR for the contract's ledger balance.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  renounceRole(
    params?: CallParams<
      NttManagerArgs["obj"]["renounce_role(byte[16])void"] | NttManagerArgs["tuple"]["renounce_role(byte[16])void"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["renounce_role(byte[16])void"] | undefined]>;

  /**
   * Calls the default_admin_role()byte[16] ABI method.
   *
   * Returns the role identifier for the default admin role
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  defaultAdminRole(
    params?: CallParams<
      NttManagerArgs["obj"]["default_admin_role()byte[16]"] | NttManagerArgs["tuple"]["default_admin_role()byte[16]"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["default_admin_role()byte[16]"] | undefined]>;

  /**
   * Calls the has_role(byte[16],address)bool ABI method.
   *
   * Returns whether the account has been granted a role
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  hasRole(
    params?: CallParams<
      | NttManagerArgs["obj"]["has_role(byte[16],address)bool"]
      | NttManagerArgs["tuple"]["has_role(byte[16],address)bool"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["has_role(byte[16],address)bool"] | undefined]>;

  /**
   * Calls the get_role_admin(byte[16])byte[16] ABI method.
   *
   * Returns the admin role that controls a role
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getRoleAdmin(
    params?: CallParams<
      | NttManagerArgs["obj"]["get_role_admin(byte[16])byte[16]"]
      | NttManagerArgs["tuple"]["get_role_admin(byte[16])byte[16]"]
    >,
  ): NttManagerComposer<[...TReturns, NttManagerReturns["get_role_admin(byte[16])byte[16]"] | undefined]>;

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the NttManager smart contract using the complete_contract_upgrade()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    completeContractUpgrade(
      params?: CallParams<
        | NttManagerArgs["obj"]["complete_contract_upgrade()void"]
        | NttManagerArgs["tuple"]["complete_contract_upgrade()void"]
      >,
    ): NttManagerComposer<[...TReturns, NttManagerReturns["complete_contract_upgrade()void"] | undefined]>;
  };

  /**
   * Makes a clear_state call to an existing instance of the NttManager smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): NttManagerComposer<[...TReturns, undefined]>;

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): NttManagerComposer<TReturns>;
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>;
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<
    NttManagerComposerResults<TReturns> & {
      simulateResponse: modelsv2.SimulateResponse;
    }
  >;
  simulate(options: SkipSignaturesSimulateOptions): Promise<
    NttManagerComposerResults<TReturns> & {
      simulateResponse: modelsv2.SimulateResponse;
    }
  >;
  simulate(options: RawSimulateOptions): Promise<
    NttManagerComposerResults<TReturns> & {
      simulateResponse: modelsv2.SimulateResponse;
    }
  >;
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<NttManagerComposerResults<TReturns>>;
};
export type NttManagerComposerResults<TReturns extends [...any[]]> = Expand<
  SendAtomicTransactionComposerResults & {
    returns: TReturns;
  }
>;
